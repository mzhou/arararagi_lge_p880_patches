diff --git a/Android.mk b/Android.mk
index e1663e5..1d58208 100644
--- a/Android.mk
+++ b/Android.mk
@@ -55,6 +55,7 @@ LOCAL_SRC_FILES := $(filter-out \
 ## across process boundaries.
 ##
 ## READ ME: ########################################################
+# BEGIN privacy-added: IPrivacySettingsManager.aidl
 LOCAL_SRC_FILES += \
 	core/java/android/accessibilityservice/IAccessibilityServiceConnection.aidl \
 	core/java/android/accessibilityservice/IAccessibilityServiceClient.aidl \
@@ -233,6 +234,7 @@ LOCAL_SRC_FILES += \
 	media/java/android/media/IRemoteControlDisplay.aidl \
 	media/java/android/media/IRemoteVolumeObserver.aidl \
 	media/java/android/media/IRingtonePlayer.aidl \
+	privacy/java/android/privacy/IPrivacySettingsManager.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneStateListener.aidl \
 	telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	telephony/java/com/android/internal/telephony/ITelephony.aidl \
@@ -256,6 +258,7 @@ LOCAL_SRC_FILES += \
 	fmradio/java/com/stericsson/hardware/fm/IOnExtraCommandListener.aidl \
 	fmradio/java/com/stericsson/hardware/fm/IOnAutomaticSwitchListener.aidl
 #
+# END privacy-added: IPrivacySettingsManager.aidl
 
 
 # FRAMEWORKS_BASE_JAVA_SRC_DIRS comes from build/core/pathmap.mk
@@ -295,6 +298,7 @@ framework_built := $(call java-lib-deps,framework)
 # AIDL files to be preprocessed and included in the SDK,
 # relative to the root of the build tree.
 # ============================================================
+# BEGIN privacy-added: PrivacySettings.aidl
 aidl_files := \
 	frameworks/base/core/java/android/accounts/IAccountManager.aidl \
 	frameworks/base/core/java/android/accounts/IAccountManagerResponse.aidl \
@@ -347,11 +351,14 @@ aidl_files := \
 	frameworks/base/location/java/android/location/LocationRequest.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderProperties.aidl \
 	frameworks/base/location/java/com/android/internal/location/ProviderRequest.aidl \
+	frameworks/base/privacy/java/android/privacy/PrivacySettings.aidl \
 	frameworks/base/telephony/java/android/telephony/ServiceState.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/IPhoneSubInfo.aidl \
 	frameworks/base/telephony/java/com/android/internal/telephony/ITelephony.aidl \
 
 gen := $(TARGET_OUT_COMMON_INTERMEDIATES)/framework.aidl
+# END privacy-added: PrivacySettings.aidl
+
 $(gen): PRIVATE_SRC_FILES := $(aidl_files)
 ALL_SDK_FILES += $(gen)
 $(gen): $(aidl_files) | $(AIDL)
diff --git a/api/current.txt b/api/current.txt
index 71d6346..46d16c1 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -21638,6 +21638,7 @@ package android.telephony {
   public final class CellInfoGsm extends android.telephony.CellInfo implements android.os.Parcelable {
     method public android.telephony.CellIdentityGsm getCellIdentity();
     method public android.telephony.CellSignalStrengthGsm getCellSignalStrength();
+    method public void setCellIdentity(android.telephony.CellIdentityGsm);
     method public void writeToParcel(android.os.Parcel, int);
     field public static final android.os.Parcelable.Creator CREATOR;
   }
diff --git a/core/java/android/app/Activity.java b/core/java/android/app/Activity.java
index 6b5df7f..7522127 100644
--- a/core/java/android/app/Activity.java
+++ b/core/java/android/app/Activity.java
@@ -55,13 +55,17 @@ import android.text.TextUtils;
 import android.text.method.TextKeyListener;
 import android.util.AttributeSet;
 import android.util.EventLog;
+import android.util.DisplayMetrics;
 import android.util.Log;
+import android.util.TypedValue;
 import android.util.Slog;
 import android.util.SparseArray;
 import android.view.ActionMode;
 import android.view.ContextMenu;
 import android.view.ContextMenu.ContextMenuInfo;
 import android.view.ContextThemeWrapper;
+import android.view.Display;
+import android.view.Gravity;
 import android.view.KeyEvent;
 import android.view.LayoutInflater;
 import android.view.Menu;
@@ -1473,6 +1477,9 @@ public class Activity extends ContextThemeWrapper
         if (mWindow != null) {
             // Pass the configuration changed event to the window
             mWindow.onConfigurationChanged(newConfig);
+            if (mWindow.mIsFloatingWindow) {
+                scaleFloatingWindow(null);
+            }
         }
 
         if (mActionBar != null) {
@@ -5085,11 +5092,49 @@ public class Activity extends ContextThemeWrapper
             CharSequence title, Activity parent, String id,
             NonConfigurationInstances lastNonConfigurationInstances,
             Configuration config) {
+
         attachBaseContext(context);
 
         mFragments.attachActivity(this, mContainer, null);
-        
-        mWindow = PolicyManager.makeNewWindow(this);
+
+        boolean floating = (intent.getFlags()&Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+        if (intent != null && floating) {
+            TypedArray styleArray = context.obtainStyledAttributes(info.theme, com.android.internal.R.styleable.Window);
+            TypedValue backgroundValue = styleArray.peekValue(com.android.internal.R.styleable.Window_windowBackground);
+
+            // Apps that have no title don't need no title bar
+            TypedValue outValue = new TypedValue();
+            boolean result = styleArray.getValue(com.android.internal.R.styleable.Window_windowNoTitle, outValue);
+
+            if (backgroundValue != null && backgroundValue.toString().contains("light")) {
+                context.getTheme().applyStyle(com.android.internal.R.style.Theme_DeviceDefault_FloatingWindowLight, true);
+            } else {
+                context.getTheme().applyStyle(com.android.internal.R.style.Theme_DeviceDefault_FloatingWindow, true);
+            }
+
+            parent = null;
+
+            // Create our new window
+            mWindow = PolicyManager.makeNewWindow(this);
+            mWindow.mIsFloatingWindow = true;
+            mWindow.setCloseOnTouchOutsideIfNotSet(true);
+            mWindow.setGravity(Gravity.CENTER);
+
+            if (this instanceof LayerActivity || android.os.Process.myUid() == android.os.Process.SYSTEM_UID) {
+                mWindow.setFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND,
+                        WindowManager.LayoutParams.FLAG_DIM_BEHIND);
+                WindowManager.LayoutParams params = mWindow.getAttributes();
+                params.alpha = 1f;
+                params.dimAmount = 0.25f;
+                mWindow.setAttributes((android.view.WindowManager.LayoutParams) params);
+            }
+
+            // Scale it
+            scaleFloatingWindow(context);
+        } else {
+            mWindow = PolicyManager.makeNewWindow(this);
+        }
+
         mWindow.setCallback(this);
         mWindow.getLayoutInflater().setPrivateFactory(this);
         if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
@@ -5124,6 +5169,26 @@ public class Activity extends ContextThemeWrapper
         mCurrentConfig = config;
     }
 
+    private void scaleFloatingWindow(Context context) {
+        if (!mWindow.mIsFloatingWindow) {
+            return;
+        }
+        WindowManager wm = null;
+        if (context != null) {
+            wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        } else {
+            wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
+        }
+        Display display = wm.getDefaultDisplay();
+        DisplayMetrics metrics = new DisplayMetrics();
+        display.getMetrics(metrics);
+        if (metrics.heightPixels > metrics.widthPixels) {
+            mWindow.setLayout((int)(metrics.widthPixels * 0.9f), (int)(metrics.heightPixels * 0.7f));
+        } else {
+            mWindow.setLayout((int)(metrics.widthPixels * 0.7f), (int)(metrics.heightPixels * 0.8f));
+        }
+    }
+
     /** @hide */
     public final IBinder getActivityToken() {
         return mParent != null ? mParent.getActivityToken() : mToken;
@@ -5247,7 +5312,7 @@ public class Activity extends ContextThemeWrapper
         onUserInteraction();
         onUserLeaveHint();
     }
-    
+
     final void performStop() {
         if (mLoadersStarted) {
             mLoadersStarted = false;
@@ -5293,6 +5358,14 @@ public class Activity extends ContextThemeWrapper
             mStopped = true;
         }
         mResumed = false;
+
+        // Floatingwindows activities should be kept volatile to prevent new activities taking
+        // up front in a minimized space. Every stop call, for instance when pressing home,
+        // will terminate the activity. If the activity is already finishing we might just
+        // as well let it go.
+        if (!mChangingConfigurations && mWindow != null && mWindow.mIsFloatingWindow && !isFinishing()) {
+            finish();
+        }
     }
 
     final void performDestroy() {
diff --git a/core/java/android/app/ActivityThread.java b/core/java/android/app/ActivityThread.java
index d254095..cba931d 100644
--- a/core/java/android/app/ActivityThread.java
+++ b/core/java/android/app/ActivityThread.java
@@ -2914,12 +2914,7 @@ public final class ActivityThread {
                 r.stopped = false;
                 r.state = null;
             } catch (Exception e) {
-                if (!mInstrumentation.onException(r.activity, e)) {
-                    throw new RuntimeException(
-                        "Unable to resume activity "
-                        + r.intent.getComponent().toShortString()
-                        + ": " + e.toString(), e);
-                }
+                // Unable to resume activity
             }
         }
         return r;
diff --git a/core/java/android/app/ContextImpl.java b/core/java/android/app/ContextImpl.java
index 6cdd43f..8f72bf9 100644
--- a/core/java/android/app/ContextImpl.java
+++ b/core/java/android/app/ContextImpl.java
@@ -63,7 +63,7 @@ import android.location.ILocationManager;
 import android.location.LocationManager;
 import android.media.AudioManager;
 import android.media.MediaRouter;
-import android.net.ConnectivityManager;
+//import android.net.ConnectivityManager;
 import android.net.IConnectivityManager;
 import android.net.INetworkPolicyManager;
 import android.net.NetworkPolicyManager;
@@ -115,6 +115,16 @@ import android.app.admin.DevicePolicyManager;
 import com.android.internal.app.IAppOpsService;
 import com.android.internal.os.IDropBoxManagerService;
 
+// BEGIN privacy-added
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.surrogate.PrivacyAccountManager;
+import android.privacy.surrogate.PrivacyLocationManager;
+import android.privacy.surrogate.PrivacyTelephonyManager;
+import android.privacy.surrogate.PrivacyWifiManager;
+import android.privacy.surrogate.PrivacyConnectivityManager;
+// END privacy-added
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -190,6 +200,9 @@ class ContextImpl extends Context {
     private Resources mResources;
     /*package*/ ActivityThread mMainThread;
     private Context mOuterContext;
+    // BEGIN privacy-added
+    private static Context sOuterContext = null;
+    // END privacy-added
     private IBinder mActivityToken = null;
     private ApplicationContentResolver mContentResolver;
     private int mThemeResource = 0;
@@ -305,7 +318,11 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(ACCOUNT_SERVICE);
                     IAccountManager service = IAccountManager.Stub.asInterface(b);
-                    return new AccountManager(ctx, service);
+                    // BEGIN privacy-modified
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyAccountManager rather than AccountManager");
+                    //return new AccountManager(ctx, service);
+                    return new PrivacyAccountManager(ctx, service);
+                    // END privacy-modified
                 }});
 
         registerService(ACTIVITY_SERVICE, new ServiceFetcher() {
@@ -344,7 +361,14 @@ class ContextImpl extends Context {
         registerService(CONNECTIVITY_SERVICE, new StaticServiceFetcher() {
                 public Object createStaticService() {
                     IBinder b = ServiceManager.getService(CONNECTIVITY_SERVICE);
-                    return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    // BEGIN privacy-modified
+                    // SM: Having a 'static outer context' may be problematic if
+                    //      there is more than one instance of this class, ever.
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyConnectivityManager");
+                    //return new ConnectivityManager(IConnectivityManager.Stub.asInterface(b));
+                    IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
+                    return new PrivacyConnectivityManager(service, getStaticOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(COUNTRY_DETECTOR, new StaticServiceFetcher() {
@@ -410,8 +434,16 @@ class ContextImpl extends Context {
 
         registerService(LOCATION_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    IBinder b = ServiceManager.getService(LOCATION_SERVICE);
-                    return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+    	            IBinder b = ServiceManager.getService(LOCATION_SERVICE);
+    
+    	            // BEGIN privacy-modified
+    	            //return new LocationManager(ctx, ILocationManager.Stub.asInterface(b));
+    	            Log.d(TAG, "PDroid:ContextImpl: returning PrivacyLocationManager");
+    	            // SM: I'm not sure whyt this is using getStaticOuterContext rather than getOuterContext.
+    	            // Would have thought it should have been the following line:
+    	            // return new PrivacyLocationManager(ILocationManager.Stub.asInterface(b), ctx.getOuterContext());
+    	            return new PrivacyLocationManager(ILocationManager.Stub.asInterface(b), getStaticOuterContext());
+    	            // END privacy-modified                    
                 }});
 
         registerService(NETWORK_POLICY_SERVICE, new ServiceFetcher() {
@@ -484,7 +516,11 @@ class ContextImpl extends Context {
 
         registerService(TELEPHONY_SERVICE, new ServiceFetcher() {
                 public Object createService(ContextImpl ctx) {
-                    return new TelephonyManager(ctx.getOuterContext());
+                    // BEGIN privacy-modified
+                    //return new TelephonyManager(ctx.getOuterContext());
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyTelephonyManager");
+                    return new PrivacyTelephonyManager(ctx.getOuterContext());
+                    // END privacy-modified
                 }});
 
         registerService(UI_MODE_SERVICE, new ServiceFetcher() {
@@ -515,7 +551,11 @@ class ContextImpl extends Context {
                 public Object createService(ContextImpl ctx) {
                     IBinder b = ServiceManager.getService(WIFI_SERVICE);
                     IWifiManager service = IWifiManager.Stub.asInterface(b);
-                    return new WifiManager(ctx.getOuterContext(), service);
+                    // BEGIN privacy-modified
+                    //return new WifiManager(ctx.getOuterContext(), service);
+                    Log.d(TAG, "PDroid:ContextImpl: returning PrivacyWifiManager");
+                    return new PrivacyWifiManager(ctx.getOuterContext(), service);
+                    // END privacy-modified
                 }});
 
         registerService(WIFI_P2P_SERVICE, new ServiceFetcher() {
@@ -525,6 +565,16 @@ class ContextImpl extends Context {
                     return new WifiP2pManager(service);
                 }});
 
+        // BEGIN privacy-added
+        registerService("privacy", new StaticServiceFetcher() {
+                public Object createStaticService() {
+                    Log.d(TAG, "PDroid:ContextImpl: Creating static privacy service");
+                    IBinder b = ServiceManager.getService("privacy");
+                    IPrivacySettingsManager service = IPrivacySettingsManager.Stub.asInterface(b);
+                    return new PrivacySettingsManager(getStaticOuterContext(), service);
+                }});
+        // END privacy-added
+
         registerService(WINDOW_SERVICE, new ServiceFetcher() {
                 public Object getService(ContextImpl ctx) {
                     Display display = ctx.mDisplay;
@@ -1930,7 +1980,10 @@ class ContextImpl extends Context {
     }
 
     ContextImpl() {
-        mOuterContext = this;
+        if (sOuterContext != null) {
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+        }
+        sOuterContext = mOuterContext = this;
     }
 
     /**
@@ -1947,7 +2000,12 @@ class ContextImpl extends Context {
         mContentResolver = context.mContentResolver;
         mUser = context.mUser;
         mDisplay = context.mDisplay;
-        mOuterContext = this;
+        
+        if (sOuterContext != null) {
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+        }
+        
+        sOuterContext = mOuterContext = this;
     }
 
     final void init(LoadedApk packageInfo, IBinder activityToken, ActivityThread mainThread) {
@@ -2003,13 +2061,21 @@ class ContextImpl extends Context {
     }
 
     final void setOuterContext(Context context) {
-        mOuterContext = context;
+        if (sOuterContext != null) {
+            Log.w(TAG, "PDroid:ContextImpl: ContextImpl being created but already has sOuterContext");
+        }
+
+        sOuterContext = mOuterContext = context;
     }
 
     final Context getOuterContext() {
         return mOuterContext;
     }
 
+    final static Context getStaticOuterContext() {
+        return sOuterContext;
+    }
+
     final IBinder getActivityToken() {
         return mActivityToken;
     }
diff --git a/core/java/android/app/INotificationManager.aidl b/core/java/android/app/INotificationManager.aidl
index 9f933ca..471087d 100644
--- a/core/java/android/app/INotificationManager.aidl
+++ b/core/java/android/app/INotificationManager.aidl
@@ -38,6 +38,13 @@ interface INotificationManager
     void setNotificationsEnabledForPackage(String pkg, int uid, boolean enabled);
     boolean areNotificationsEnabledForPackage(String pkg, int uid);
 
+    void setHaloPolicyBlack(boolean state);
+    void setHaloStatus(String pkg, boolean status);
+    void setHaloBlacklistStatus(String pkg, boolean status);
+    void setHaloWhitelistStatus(String pkg, boolean status);
+    boolean isHaloPolicyBlack();
+    boolean isPackageAllowedForHalo(String pkg);
+
     StatusBarNotification[] getActiveNotifications(String callingPkg);
     StatusBarNotification[] getHistoricalNotifications(String callingPkg, int count);
 
@@ -48,4 +55,4 @@ interface INotificationManager
     void cancelAllNotificationsFromListener(in INotificationListener token);
 
     StatusBarNotification[] getActiveNotificationsFromListener(in INotificationListener token);
-}
\ No newline at end of file
+}
diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index a307a73..b7b2ab0 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -49,6 +49,14 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
+///////////////////////////////////////////////////
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.TelephonyManager;
+///////////////////////////////////////////////////
+
+
 /**
  * Base class for implementing application instrumentation code.  When running
  * with instrumentation turned on, this class will be instantiated for you
@@ -91,6 +99,10 @@ public class Instrumentation {
     private PerformanceCollector mPerformanceCollector;
     private Bundle mPerfMetrics = new Bundle();
     private UiAutomation mUiAutomation;
+    
+    //---------------------------------------------------------------------------------------------------------------------------------------------------------
+    private PrivacySettingsManager mPrvSvc;
+    //---------------------------------------------------------------------------------------------------------------------------------------------------------
 
     public Instrumentation() {
     }
@@ -1398,6 +1410,79 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+        	Log.d(TAG,"PDroid:Instrumentation:execStartActivity: execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+        		if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+        		    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+        		    if (mPrvSvc != null) {
+        		        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Obtained privacy service");
+        		    } else {
+        		        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Privacy service not obtained");
+        		    }
+        		} else {
+        		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Already had privacy service");
+        		}
+        		
+        		if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+        		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Privacy service not available: rejecting call attempt");
+        		    allowIntent = false;
+        		    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+        		} else {
+            		PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+            		if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+            		} else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+            		} else {
+            		    Log.d(TAG,"PDroid:Instrumentation:execStartActivity: Call denied: Settings deny " + who.getPackageName());
+            		    // No settings = allowed; any phone call setting but real == disallowed
+            		    
+                		allowIntent = false;
+                		
+                		// test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                		// Send the notification intent
+                		final Context tmp = who;
+                		// SM: the BLOCKED_PHONE_CALL intent is handled by the privacy service to fake a change in call state
+                		new Thread(new Runnable() {
+                		    public void run() {
+                		        // SM: Not clear why there is this delay
+                		    	try{
+                 		    		Thread.sleep(1000); //wait 1 Second
+                 		    	} catch(Exception e){
+                 		    		//nothing here
+                 		    	}  
+                		    	Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                        		Bundle extras = new Bundle();
+                        		extras.putString("packageName", tmp.getPackageName());
+                        		extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                        		privacy.putExtras(extras);
+                        		tmp.sendBroadcast(privacy);
+                        		Log.i("PrivacyContext","sent privacy intent");
+                		    }
+                		}).start();
+                		mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+            		}
+        		}
+            }
+        } catch(Exception e){
+        	 if(who != null) {
+        	     Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred handling intent for " + who.getPackageName(), e);
+        	 } else {
+        	     Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred handling intent for unknown package", e);
+        	 }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1413,6 +1498,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+        	if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity: Exception occurred while trying to create ActivityResult", e);
+        	return null;
+        }
+    	// END privacy-added
+        
         try {
             intent.migrateExtraStreamToClipData();
             intent.prepareToLeaveProcess();
@@ -1453,6 +1548,109 @@ public class Instrumentation {
             IBinder token, Activity target, Intent[] intents, Bundle options,
             int userId) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+
+        // BEGIN privacy-added
+        
+        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: execStartActivitiesAsUser for " + who.getPackageName());
+        if (intents != null) {
+            boolean checkPrivacySettings = false;
+
+            // If any intents are Intent.ACTION_CALL or Intent.ACTION_DIAL, need to check permissions
+            for (Intent intent : intents) {
+                try {
+                    if (intent.getAction() != null && (
+                            intent.getAction().equals(Intent.ACTION_CALL) ||
+                            intent.getAction().equals(Intent.ACTION_DIAL))) {
+                        checkPrivacySettings = true;
+                        break;
+                    }
+                } catch (Exception e) {
+                    Log.e(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Exception occurred when checking intents for " + who.getPackageName(), e);
+                    // If an exception occurred, then check the privacy settings as the default action
+                    checkPrivacySettings = true;
+                }
+            }
+
+            if (!checkPrivacySettings) {
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: No provided intents triggered checking for " + who.getPackageName());
+            } else {
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: One or more intents triggered checking for " + who.getPackageName());
+
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Already had privacy service");
+                }
+
+                boolean allowCallIntents = false; 
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Privacy service not available - assuming permission denied");
+                    allowCallIntents = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents allowed: No settings for package: " + who.getPackageName());
+                        allowCallIntents = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents allowed: Settings permit " + who.getPackageName());
+                        allowCallIntents = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Call intents denied: Settings deny " + who.getPackageName());
+                        allowCallIntents = false;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+
+                // If call intents are not allowed, need to regenerate the
+                // intents list to remove call-related intents
+                if (!allowCallIntents) {
+                    List<Intent> filteredIntents = new ArrayList<Intent>(intents.length);
+                    for (Intent intent : intents) {
+                        try {
+                            if (intent.getAction() == null || !(
+                                    intent.getAction().equals(Intent.ACTION_CALL) ||
+                                    intent.getAction().equals(Intent.ACTION_DIAL))) {
+                                filteredIntents.add(intent);
+                            }
+                        } catch (Exception e) {
+                            Log.e(TAG,"PDroid:Instrumentation:execStartActivitiesAsUser: Exception occurred when checking intent for " + who.getPackageName(), e);
+                        }
+                    }
+                    intents = filteredIntents.toArray(new Intent [filteredIntents.size()]);
+                    
+                    // Send the notification intent
+                    final Context tmp = who;
+                    // SM: the BLOCKED_PHONE_CALL intent is handled by the privacy service to fake a change in call state
+                    new Thread(new Runnable() {
+                        public void run() {
+                            // SM: Not clear why there is this delay
+                            try{
+                                Thread.sleep(1000); //wait 1 Second
+                            } catch(Exception e){
+                                //nothing here
+                            }  
+                            Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                            Bundle extras = new Bundle();
+                            extras.putString("packageName", tmp.getPackageName());
+                            extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                            privacy.putExtras(extras);
+                            tmp.sendBroadcast(privacy);
+                            Log.i("PrivacyContext","sent privacy intent");
+                        }
+                    }).start();
+                }
+            }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1515,6 +1713,77 @@ public class Instrumentation {
         Context who, IBinder contextThread, IBinder token, Fragment target,
         Intent intent, int requestCode, Bundle options) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Already had privacy service");
+                }
+                
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Privacy service not available: rejecting call attempt");
+                    allowIntent = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Call denied: Settings deny " + who.getPackageName());
+                        // No settings = allowed; any phone call setting but real == disallowed
+                        
+                        // test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                        // Send the notification intent
+                        final Context tmp = who;
+                        allowIntent = false;
+                        // SM: Why is all of this done? It seems like a weirdly unnecessary bit of code...
+                        new Thread(new Runnable() {
+                            public void run() {
+                                // SM: Not clear why there is this delay
+                                try{
+                                    Thread.sleep(1000); //wait 1 Second
+                                } catch(Exception e){
+                                    //nothing here
+                                }  
+                                Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                                Bundle extras = new Bundle();
+                                extras.putString("packageName", tmp.getPackageName());
+                                extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                                privacy.putExtras(extras);
+                                tmp.sendBroadcast(privacy);
+                                Log.i("PrivacyContext","sent privacy intent");
+                            }
+                        }).start();
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+            }
+        } catch(Exception e){
+             if(who != null) {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred handling intent for " + who.getPackageName(), e);
+             } else {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred handling intent for unknown package", e);
+             }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1530,6 +1799,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+            if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with Fragments): Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+        // END privacy-added
+        
         try {
             intent.migrateExtraStreamToClipData();
             intent.prepareToLeaveProcess();
@@ -1575,6 +1854,78 @@ public class Instrumentation {
             Context who, IBinder contextThread, IBinder token, Activity target,
             Intent intent, int requestCode, Bundle options, UserHandle user) {
         IApplicationThread whoThread = (IApplicationThread) contextThread;
+        
+        // BEGIN privacy-added
+        boolean allowIntent = true;
+        try{
+            Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): execStartActivity for " + who.getPackageName());
+            if (intent.getAction() != null && (intent.getAction().equals(Intent.ACTION_CALL) || intent.getAction().equals(Intent.ACTION_DIAL))){
+                allowIntent = false;
+                Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Intent action = Intent.ACTION_CALL or Intent.ACTION_DIAL for " + who.getPackageName());
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    mPrvSvc = new PrivacySettingsManager(who, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+                    if (mPrvSvc != null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Obtained privacy service");
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Privacy service not obtained");
+                    }
+                } else {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Already had privacy service");
+                }
+                
+                if (mPrvSvc == null || !mPrvSvc.isServiceAvailable()) {
+                    Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Privacy service not available: rejecting call attempt");
+                    allowIntent = false;
+                    mPrvSvc.notification(who.getPackageName(), PrivacySettings.EMPTY, PrivacySettings.DATA_PHONE_CALL, null);
+                } else {
+                    PrivacySettings privacySettings = mPrvSvc.getSettings(who.getPackageName());
+                    if (privacySettings == null) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call allowed: No settings for package: " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), PrivacySettings.REAL, PrivacySettings.DATA_PHONE_CALL, null);
+                    } else if (privacySettings.getPhoneCallSetting() == PrivacySettings.REAL) {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call allowed: Settings permit " + who.getPackageName());
+                        allowIntent = true;
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    } else {
+                        Log.d(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Call denied: Settings deny " + who.getPackageName());
+                        // No settings = allowed; any phone call setting but real == disallowed
+                        
+                        // test if broadcasting works! SM: I don't know what 'test if broadcasting works' means.
+                        // Send the notification intent
+                        final Context tmp = who;
+                        allowIntent = false;
+                        // SM: Why is all of this done? It seems like a weirdly unnecessary bit of code...
+                        new Thread(new Runnable() {
+                            public void run() {
+                                // SM: Not clear why there is this delay
+                                try{
+                                    Thread.sleep(1000); //wait 1 Second
+                                } catch(Exception e){
+                                    //nothing here
+                                }  
+                                Intent privacy = new Intent("android.privacy.BLOCKED_PHONE_CALL");
+                                Bundle extras = new Bundle();
+                                extras.putString("packageName", tmp.getPackageName());
+                                extras.putInt("phoneState", TelephonyManager.CALL_STATE_IDLE);
+                                privacy.putExtras(extras);
+                                tmp.sendBroadcast(privacy);
+                                Log.i("PrivacyContext","sent privacy intent");
+                            }
+                        }).start();
+                        mPrvSvc.notification(who.getPackageName(), privacySettings.getPhoneCallSetting(), PrivacySettings.DATA_PHONE_CALL, null);
+                    }
+                }
+            }
+        } catch(Exception e){
+             if(who != null) {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred handling intent for " + who.getPackageName(), e);
+             } else {
+                 Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred handling intent for unknown package", e);
+             }
+        }
+        // END privacy-added
+        
         if (mActivityMonitors != null) {
             synchronized (mSync) {
                 final int N = mActivityMonitors.size();
@@ -1590,6 +1941,16 @@ public class Instrumentation {
                 }
             }
         }
+        
+        // BEGIN privacy-added
+        try{
+            if (!allowIntent) return new ActivityResult(requestCode, intent);
+        } catch(Exception e) {
+            Log.e(TAG,"PDroid:Instrumentation:execStartActivity (with UserHandle): Exception occurred while trying to create ActivityResult", e);
+            return null;
+        }
+        // END privacy-added
+        
         try {
             intent.migrateExtraStreamToClipData();
             intent.prepareToLeaveProcess();
diff --git a/core/java/android/app/LayerActivity.java b/core/java/android/app/LayerActivity.java
new file mode 100644
index 0000000..c460f6b
--- /dev/null
+++ b/core/java/android/app/LayerActivity.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 ParanoidAndroid Project.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.app;
+
+import android.app.Activity;
+import android.os.Bundle;
+
+public class LayerActivity extends Activity {
+
+    private Bundle mSavedInstanceState;
+    private boolean mShouldFinish = false;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mSavedInstanceState = savedInstanceState;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        mShouldFinish = false;
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (!mShouldFinish) {
+            mShouldFinish = true;
+            return;
+        }
+        mShouldFinish = false;
+        finish();
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        if (mSavedInstanceState != null) {
+            finish();
+        }
+    }
+}
diff --git a/core/java/android/app/TaskStackBuilder.java b/core/java/android/app/TaskStackBuilder.java
index 3e0ac7e..f3d07cc 100644
--- a/core/java/android/app/TaskStackBuilder.java
+++ b/core/java/android/app/TaskStackBuilder.java
@@ -62,6 +62,7 @@ public class TaskStackBuilder {
 
     private final ArrayList<Intent> mIntents = new ArrayList<Intent>();
     private final Context mSourceContext;
+    private boolean mFirstTaskOnHome = true;
 
     private TaskStackBuilder(Context a) {
         mSourceContext = a;
@@ -78,6 +79,10 @@ public class TaskStackBuilder {
         return new TaskStackBuilder(context);
     }
 
+    public void setTaskOnHome(boolean firstTaskOnHome) {
+        mFirstTaskOnHome = firstTaskOnHome;
+    }
+
     /**
      * Add a new Intent to the task stack. The most recently added Intent will invoke
      * the Activity at the top of the final task stack.
@@ -298,9 +303,16 @@ public class TaskStackBuilder {
         Intent[] intents = new Intent[mIntents.size()];
         if (intents.length == 0) return intents;
 
-        intents[0] = new Intent(mIntents.get(0)).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK |
-                Intent.FLAG_ACTIVITY_CLEAR_TASK |
-                Intent.FLAG_ACTIVITY_TASK_ON_HOME);
+        Intent newIntent = new Intent(mIntents.get(0));
+        newIntent.addFlags(
+                Intent.FLAG_ACTIVITY_NEW_TASK |
+                Intent.FLAG_ACTIVITY_CLEAR_TASK);
+
+        if (mFirstTaskOnHome) {
+            newIntent.addFlags(Intent.FLAG_ACTIVITY_TASK_ON_HOME);
+        }
+
+        intents[0] = newIntent;
         for (int i = 1; i < intents.length; i++) {
             intents[i] = new Intent(mIntents.get(i));
         }
diff --git a/core/java/android/content/ContentResolver.java b/core/java/android/content/ContentResolver.java
index fefd343..71aca4b 100644
--- a/core/java/android/content/ContentResolver.java
+++ b/core/java/android/content/ContentResolver.java
@@ -45,6 +45,10 @@ import android.text.TextUtils;
 import android.util.EventLog;
 import android.util.Log;
 
+// BEGIN privacy-added
+import android.privacy.surrogate.PrivacyContentResolver;
+// END privacy-added
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -413,6 +417,10 @@ public abstract class ContentResolver {
             try {
                 qCursor = unstableProvider.query(mPackageName, uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+                // BEGIN privacy-added
+                // Log.d(TAG, "PDroid:ContentResolver:wrapping content resolver in PrivacyContentResolver");
+                qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+                // END privacy-added
             } catch (DeadObjectException e) {
                 // The remote process has died...  but we only hold an unstable
                 // reference though, so we might recover!!!  Let's try!!!!
@@ -424,6 +432,11 @@ public abstract class ContentResolver {
                 }
                 qCursor = stableProvider.query(mPackageName, uri, projection,
                         selection, selectionArgs, sortOrder, remoteCancellationSignal);
+                // BEGIN privacy-added
+                // Log.d(TAG, "PDroid:ContentResolver:wrapping content resolver in PrivacyContentResolver");
+        		qCursor = PrivacyContentResolver.enforcePrivacyPermission(uri, projection, mContext, qCursor);
+        		// END privacy-added
+
             }
             if (qCursor == null) {
                 return null;
diff --git a/core/java/android/content/Intent.java b/core/java/android/content/Intent.java
index 088cdb9..af5a342 100644
--- a/core/java/android/content/Intent.java
+++ b/core/java/android/content/Intent.java
@@ -3316,7 +3316,6 @@ public class Intent implements Parcelable, Cloneable {
      * places where the framework may automatically set the exclude flag).
      */
     public static final int FLAG_INCLUDE_STOPPED_PACKAGES = 0x00000020;
-
     /**
      * If set, the new activity is not kept in the history stack.  As soon as
      * the user navigates away from it, the activity is finished.  This may also
@@ -3533,6 +3532,11 @@ public class Intent implements Parcelable, Cloneable {
      */
     public static final int FLAG_ACTIVITY_TASK_ON_HOME = 0X00004000;
     /**
+     * If set, this intent will always match start up as a floating window
+     * in mutil window scenarios.
+     */
+    public static final int FLAG_FLOATING_WINDOW = 0x00002000;
+    /**
      * If set, when sending a broadcast only registered receivers will be
      * called -- no BroadcastReceiver components will be launched.
      */
diff --git a/core/java/android/hardware/Camera.java b/core/java/android/hardware/Camera.java
index 7bf5246..f5a0ed4 100644
--- a/core/java/android/hardware/Camera.java
+++ b/core/java/android/hardware/Camera.java
@@ -43,6 +43,26 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.concurrent.locks.ReentrantLock;
 
+///////////////////////////////////////////////////////
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import java.util.Random;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+///////////////////////////////////////////////////////
+
 /**
  * The Camera class is used to set image capture settings, start/stop preview,
  * snap pictures, and retrieve frames for encoding for video.  This class is a
@@ -171,6 +191,157 @@ public class Camera {
     private CameraMetaDataCallback mCameraMetaDataCallback;
     /* ### QC ADD-ONS: END */
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PM,Camera";
+
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * This method returns the fake image which should be in system folder! 
+     * @return byte array of jpeg fake image or null if something went wrong
+     * {@hide}
+     */
+    private byte[] getFakeImage(){
+	try{
+		String filepath = "/system/media/PDroid.jpeg";
+        	File imagefile = new File(filepath);
+        	FileInputStream fis = null;
+        	
+          	fis = new FileInputStream(imagefile);
+        	
+       	 	Bitmap bm = BitmapFactory.decodeStream(fis);
+        	ByteArrayOutputStream helper = new ByteArrayOutputStream();  
+        	bm.compress(Bitmap.CompressFormat.JPEG, 100 , helper);    
+		return helper.toByteArray();
+	}
+	catch (Exception e){
+		Log.e(PRIVACY_TAG,"something went wrong with getting the picture!");
+		e.printStackTrace();
+		return null;
+	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getCameraSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing camera.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing camera.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
     /**
      * Broadcast Action:  A new picture is taken by the camera, and the entry of
      * the picture has been added to the media store.
@@ -352,6 +523,14 @@ public class Camera {
         mCameraMetaDataCallback = null;
         /* ### QC ADD-ONS: END */
 
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+        
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         Looper looper;
         if ((looper = Looper.myLooper()) != null) {
             mEventHandler = new EventHandler(this, looper);
@@ -778,6 +957,27 @@ public class Camera {
 
         @Override
         public void handleMessage(Message msg) {
+	    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+            //BEGIN PRIVACY
+
+	    boolean access = true;
+	    if(!privacyMode){
+		initiate();
+	    }
+	    String packageName[] = getPackageName();
+	    if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+		access = false;
+		dataAccess(false);
+		if(packageName != null)
+			pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+	    }
+	    else{
+		dataAccess(true);
+		if(packageName != null)
+			pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+	    }
+
+
             switch(msg.what) {
             case CAMERA_MSG_SHUTTER:
                 if (mShutterCallback != null) {
@@ -787,13 +987,19 @@ public class Camera {
 
             case CAMERA_MSG_RAW_IMAGE:
                 if (mRawImageCallback != null) {
-                    mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    if(access)
+                    	mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    else
+			mRawImageCallback.onPictureTaken(null, mCamera);//this normally doesn't get a call, because we disabled this receiver in takepicture method!
                 }
                 return;
 
             case CAMERA_MSG_COMPRESSED_IMAGE:
                 if (mJpegCallback != null) {
-                    mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    if(access)
+                    	mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera);
+		    else
+			mJpegCallback.onPictureTaken(getFakeImage(), mCamera);
                 }
                 return;
 
@@ -811,13 +1017,21 @@ public class Camera {
                         // Set to oneshot mode again.
                         setHasPreviewCallback(true, false);
                     }
-                    pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    //pCb.onPreviewFrame((byte[])msg.obj, mCamera);
+                    if(access)
+                        pCb.onPreviewFrame((byte[])msg.obj, mCamera);//leave the camera the preview frame!
+                    else
+                        pCb.onPreviewFrame(getFakeImage(), mCamera);//here we go testing if it is able to give preview of fake image, if it doesn't work -> pass null
                 }
                 return;
 
             case CAMERA_MSG_POSTVIEW_FRAME:
                 if (mPostviewCallback != null) {
-                    mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    //mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    if(access)
+                        mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera);
+                    else
+                        mPostviewCallback.onPictureTaken(getFakeImage(), mCamera);//same as in onpreviewframe -> give test fake image
                 }
                 return;
 
@@ -878,6 +1092,8 @@ public class Camera {
                 return;
             }
         }
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
     }
 
     private static void postEventFromNative(Object camera_ref,
@@ -1127,6 +1343,28 @@ public class Camera {
         mPostviewCallback = postview;
         mJpegCallback = jpeg;
 
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+	//check if we are in privacy mode!, this is a to hard method to prevent from making pictures, because camera will freeze!	
+	if(!privacyMode){
+		initiate();
+	}
+	if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+//		mShutterCallback = null;
+        	mRawImageCallback = null;
+		Log.i(PRIVACY_TAG,"blocked rawImageCallback -> it will never be called!");
+//        	mPostviewCallback = null;
+//        	mJpegCallback = null;
+//		dataAccess(false);
+	}
+//	else{
+//		dataAccess(true);
+//	}
+	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         // If callback is not set, do not send me callbacks.
         int msgType = 0;
         if (mShutterCallback != null) {
diff --git a/core/java/android/net/NetworkInfo.java b/core/java/android/net/NetworkInfo.java
index 689dae5..1f2e627 100644
--- a/core/java/android/net/NetworkInfo.java
+++ b/core/java/android/net/NetworkInfo.java
@@ -167,6 +167,14 @@ public class NetworkInfo implements Parcelable {
         }
     }
 
+    // BEGIN privacy-added
+    // SM: I've no idea where this is used
+    /**{@hide}* Used for set state to get better working Privacy*/
+    public void setState(State state){
+	   this.mState = state;
+    }
+    // END privacy-added
+
     /**
      * Reports the type of network to which the
      * info in this {@code NetworkInfo} pertains.
diff --git a/core/java/android/os/SystemProperties.java b/core/java/android/os/SystemProperties.java
index a9584d0..60e3757 100644
--- a/core/java/android/os/SystemProperties.java
+++ b/core/java/android/os/SystemProperties.java
@@ -21,6 +21,22 @@ import java.util.ArrayList;
 
 import android.util.Log;
 
+//-----------------------------------------------------------
+import com.android.internal.telephony.TelephonyProperties;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+//----------------------------------------------------------
+
 
 /**
  * Gives access to the system properties store.  The system properties
@@ -45,6 +61,128 @@ public class SystemProperties
     private static native void native_set(String key, String def);
     private static native void native_add_change_callback();
 
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "SystemProperties";
+    private static Context context;
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static boolean privacyMode = false;
+    
+    private static IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private static String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private static void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private static int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getNetworkInfoSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private static void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing networkinfo.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing networkinfo.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
+
+
     /**
      * Get the value for the given key.
      * @return an empty string if the key isn't found
@@ -54,6 +192,15 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+        if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA)   || 
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+		initiate();
+		if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			dataAccess(false);
+			return "";
+		}
+		dataAccess(true);
+	}
         return native_get(key);
     }
 
@@ -66,6 +213,15 @@ public class SystemProperties
         if (key.length() > PROP_NAME_MAX) {
             throw new IllegalArgumentException("key.length > " + PROP_NAME_MAX);
         }
+	if (key.equals(TelephonyProperties.PROPERTY_OPERATOR_ALPHA)   || 
+            key.equals(TelephonyProperties.PROPERTY_OPERATOR_NUMERIC)     ){
+		initiate();
+		if (checkIfPackagesAllowed() == IS_NOT_ALLOWED) {
+			dataAccess(false);
+			return "";
+		}
+		dataAccess(true);
+	}
         return native_get(key, def);
     }
 
diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 86fcbde..3fc9dab 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -59,6 +59,17 @@ import java.net.URISyntaxException;
 import java.util.HashMap;
 import java.util.HashSet;
 
+//////////////////////////////////////////////////
+import android.content.pm.IPackageManager;
+import android.os.ServiceManager;
+import android.os.Process;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+//////////////////////////////////////////////////
+
 /**
  * The Settings provider contains global system-level device preferences.
  */
@@ -2814,6 +2825,32 @@ public final class Settings {
         public static final String COMBINED_BAR_AUTO_HIDE = "combined_bar_auto_hide";
 
         /**
+         * Pie menu, should default to 1 (yes, show)
+         * HALO, should default to 0 (no, do not show)
+         * @hide
+         */
+        public static final String HALO_ACTIVE = "halo_active";
+
+        /**
+         * HALO reversed?, should default to 1 (yes, reverse)
+         * @hide
+         */
+        public static final String HALO_REVERSED = "halo_reversed";
+
+        /**
+         * HALO hide?, should default to 0 (no, do not hide)
+         * @hide
+         */
+        public static final String HALO_HIDE = "halo_hide";
+
+        /**
+         * HALO pause activities?, defaults to 0 (no, do not pause) on devices which isLargeRAM() == true
+         * otherwise it defaults to 1 (yes, do pause)
+         * @hide
+         */
+        public static final String HALO_PAUSE = "halo_pause";
+
+        /**
          * Display style of AM/PM next to clock in status bar
          * 0: Normal display (Eclair stock)
          * 1: Small display (Froyo stock)
@@ -2940,6 +2977,12 @@ public final class Settings {
         public static final String HOME_WAKE_SCREEN = "home_wake_screen";
 
         /**
+         * Preference for the button backlight. The value is enum (0 for on touch, 1 for
+         * off, 2 for on, 3 for force off, 4 for force on).
+         */
+        public static final String BUTTON_BACKLIGHT_MODE = "button_backlight_mode";
+
+        /**
          * Whether to wake the screen with the volume keys, the value is boolean.
          * @hide
          */
@@ -3799,6 +3842,46 @@ public final class Settings {
                 }
             }
 
+            
+         //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+         //BEGIN PRIVACY
+         if(name.equals(ANDROID_ID)){ //normally it should work with sNameValueCache.getString instead of sLockSettings
+  	       initiate();
+  	       try{
+  		       if(pSetMan == null) pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+  		       if(mPm == null) mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+  		       PrivacySettings settings = null;
+  		       final String[] packages = getPackageName();
+  		       if(packages != null && packages.length > 0){
+  			       for(int i = 0; i < packages.length; i++){
+  				       settings = pSetMan.getSettings(packages[i]);
+  				       if(settings != null && settings.getAndroidIdSetting() != PrivacySettings.REAL){
+  					       String output = settings.getAndroidID();
+  					       if(output != null){
+  						       pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, output, null);
+  						       return output;
+  					       } else{
+  						       pSetMan.notification(packages[i], 0, settings.getAndroidIdSetting(), PrivacySettings.DATA_ANDROID_ID, "q4a5w896ay21dr46", null);
+  						       return "q4a5w896ay21dr46"; //we can not pull out empty android id, because we get bootlops then
+  					       }
+  				       }
+  				       if(i == packages.length - 1) //package is allowed to get android id
+  					       pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+  				       settings = null;
+  			       }
+  		       } else{
+  			       pSetMan.notification(packages[packages.length - 1], 0, PrivacySettings.REAL, PrivacySettings.DATA_ANDROID_ID, null, null);
+  		       }
+  	       }
+  	       catch (Exception e){
+  		       e.printStackTrace();
+  		       Log.e(PRIVACY_TAG,"Got exception in  getString()");
+               }
+         }
+         //END PRIVACY
+         //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
             return sNameValueCache.getStringForUser(resolver, name, userHandle);
         }
 
@@ -4099,7 +4182,71 @@ public final class Settings {
                 int userHandle) {
             return putStringForUser(cr, name, Float.toString(value), userHandle);
         }
-
+        
+		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//BEGIN PRIVACY 
+		
+		private static final String PRIVACY_TAG = "PM,SecureSettings";
+		private static Context context;
+		
+		private static PrivacySettingsManager pSetMan;
+		
+		private static boolean privacyMode = false;
+		
+		private static IPackageManager mPm;
+		
+		//END PRIVACY 		
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		
+		
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		//BEGIN PRIVACY
+		
+		/**
+		* {@hide}
+		* @return package names of current process which is using this object or null if something went wrong
+		*/
+		private static String[] getPackageName(){
+			try{
+				if(mPm != null){
+					int uid = Process.myUid();
+					final String[] package_names = mPm.getPackagesForUid(uid);
+					return package_names;
+				}
+				else{
+					mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+					int uid = Process.myUid();
+					final String[] package_names = mPm.getPackagesForUid(uid);
+					return package_names;
+				}
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+				return null;
+			}
+		}
+		/**
+		* {@hide}
+		* This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+		* -> privacyMode = true ok! otherwise false!
+		*/
+		private static void initiate(){
+			try{
+				context = null;
+				pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+				mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+				privacyMode = true;
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+				privacyMode = false;
+			}
+		}
+		//END PRIVACY
+		//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DEVELOPMENT_SETTINGS_ENABLED}
          * instead
@@ -4344,6 +4491,13 @@ public final class Settings {
             "lock_pattern_size";
 
         /**
+        * External GPS source/device
+        * @hide
+        */
+        public static final String EXTERNAL_GPS_BT_DEVICE =
+            "external_gps_bt_device";
+
+        /**
          * The Logging ID (a unique 64-bit value) as a hex string.
          * Used as a pseudonymous identifier for logging.
          * @deprecated This identifier is poorly initialized and has
diff --git a/core/java/android/speech/srec/MicrophoneInputStream.java b/core/java/android/speech/srec/MicrophoneInputStream.java
index fab77a9..b0f5f9c 100644
--- a/core/java/android/speech/srec/MicrophoneInputStream.java
+++ b/core/java/android/speech/srec/MicrophoneInputStream.java
@@ -24,6 +24,20 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.lang.IllegalStateException;
 
+//BEGIN PRIVACY
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+
+import android.os.Process;
+import android.os.ServiceManager;
+import android.util.Log;
+//END PRIVACY
+
 
 /**
  * PCM input stream from the microphone, 16 bits per sample.
@@ -32,11 +46,137 @@ public final class MicrophoneInputStream extends InputStream {
     static {
         System.loadLibrary("srec_jni");
     }
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
     
+    private static final String PRIVACY_TAG = "PM,MicrophoneInputStream";
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    
+
     private final static String TAG = "MicrophoneInputStream";
     private int mAudioRecord = 0;
     private byte[] mOneByte = new byte[1];
     
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * MicrophoneInputStream constructor.
      * @param sampleRate sample rate of the microphone, typically 11025 or 8000.
@@ -44,6 +184,28 @@ public final class MicrophoneInputStream extends InputStream {
      * This determines how long an application may delay before losing data.
      */
     public MicrophoneInputStream(int sampleRate, int fifoDepth) throws IOException {
+
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+  	//BEGIN PRIVACY
+	if(!privacyMode){
+    		initiate();
+    	}
+	if(checkIfPackagesAllowed() == IS_NOT_ALLOWED){
+		dataAccess(false);
+		String packageName[] = getPackageName();
+		if(packageName != null)
+			pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid()));
+		throw new IOException("AudioRecord constructor failed - busy?");
+	}
+	dataAccess(true);
+	String packageName[] = getPackageName();
+	if(packageName != null)
+		pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid())); 
+ 	//END PRIVACY
+   	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         mAudioRecord = AudioRecordNew(sampleRate, fifoDepth);
         if (mAudioRecord == 0) throw new IOException("AudioRecord constructor failed - busy?");
         int status = AudioRecordStart(mAudioRecord);
diff --git a/core/java/android/view/Window.java b/core/java/android/view/Window.java
index fcf0924..aa8aebf 100644
--- a/core/java/android/view/Window.java
+++ b/core/java/android/view/Window.java
@@ -152,6 +152,8 @@ public abstract class Window {
     
     private boolean mDestroyed;
 
+    public boolean mIsFloatingWindow = false;
+
     // The current window attributes.
     private final WindowManager.LayoutParams mWindowAttributes =
         new WindowManager.LayoutParams();
diff --git a/core/java/com/android/internal/util/cm/QSConstants.java b/core/java/com/android/internal/util/cm/QSConstants.java
index 044d5f9..bc440b4 100644
--- a/core/java/com/android/internal/util/cm/QSConstants.java
+++ b/core/java/com/android/internal/util/cm/QSConstants.java
@@ -6,6 +6,7 @@ public class QSConstants {
         public static final String TILE_USER = "toggleUser";
         public static final String TILE_BATTERY = "toggleBattery";
         public static final String TILE_SETTINGS = "toggleSettings";
+        public static final String TILE_QUICKMEMO = "toggleQuickMemo";
         public static final String TILE_WIFI = "toggleWifi";
         public static final String TILE_GPS = "toggleGPS";
         public static final String TILE_BLUETOOTH = "toggleBluetooth";
diff --git a/core/java/com/android/internal/widget/ActionBarView.java b/core/java/com/android/internal/widget/ActionBarView.java
index dda1a10..aa2902e 100644
--- a/core/java/com/android/internal/widget/ActionBarView.java
+++ b/core/java/com/android/internal/widget/ActionBarView.java
@@ -956,13 +956,7 @@ public class ActionBarView extends AbsActionBarView {
         }
 
         int heightMode = MeasureSpec.getMode(heightMeasureSpec);
-        if (heightMode != MeasureSpec.AT_MOST) {
-            throw new IllegalStateException(getClass().getSimpleName() + " can only be used " +
-                    "with android:layout_height=\"wrap_content\"");
-        }
-
         int contentWidth = MeasureSpec.getSize(widthMeasureSpec);
-
         int maxHeight = mContentHeight >= 0 ?
                 mContentHeight : MeasureSpec.getSize(heightMeasureSpec);
 
diff --git a/core/jni/android_util_Process.cpp b/core/jni/android_util_Process.cpp
index 5d32328..cd9aeda 100644
--- a/core/jni/android_util_Process.cpp
+++ b/core/jni/android_util_Process.cpp
@@ -411,7 +411,8 @@ static int pid_compare(const void* v1, const void* v2)
     return *((const jint*)v1) - *((const jint*)v2);
 }
 
-static jlong getFreeMemoryImpl(const char* const sums[], const int sumsLen[], int num)
+static jlong getFreeMemoryImpl(const char* const sums[], const int sumsLen[],
+        const float sumsMult[], int num)
 {
     int fd = open("/proc/meminfo", O_RDONLY);
 
@@ -447,7 +448,7 @@ static jlong getFreeMemoryImpl(const char* const sums[], const int sumsLen[], in
                     p++;
                     if (*p == 0) p--;
                 }
-                mem += atoll(num) * 1024;
+                mem += atoll(num) * 1024 * sumsMult[i];
                 numFound++;
                 break;
             }
@@ -461,16 +462,18 @@ static jlong getFreeMemoryImpl(const char* const sums[], const int sumsLen[], in
 
 static jlong android_os_Process_getFreeMemory(JNIEnv* env, jobject clazz)
 {
-    static const char* const sums[] = { "MemFree:", "Cached:", NULL };
-    static const int sumsLen[] = { strlen("MemFree:"), strlen("Cached:"), 0 };
-    return getFreeMemoryImpl(sums, sumsLen, 2);
+    static const char* const sums[] = { "MemFree:", "Cached:", "SwapFree:", NULL };
+    static const int sumsLen[] = { strlen("MemFree:"), strlen("Cached:"), strlen("SwapFree:"), 0 };
+    static const float sumsMult[] = { 1, 1, 0.5, 0 };
+    return getFreeMemoryImpl(sums, sumsLen, sumsMult, 3);
 }
 
 static jlong android_os_Process_getTotalMemory(JNIEnv* env, jobject clazz)
 {
-    static const char* const sums[] = { "MemTotal:", NULL };
-    static const int sumsLen[] = { strlen("MemTotal:"), 0 };
-    return getFreeMemoryImpl(sums, sumsLen, 1);
+    static const char* const sums[] = { "MemTotal:", "SwapTotal:", NULL };
+    static const int sumsLen[] = { strlen("MemTotal:"), strlen("SwapTotal:"), 0 };
+    static const float sumsMult[] = { 1, 0.5, 0 };
+    return getFreeMemoryImpl(sums, sumsLen, sumsMult, 2);
 }
 
 void android_os_Process_readProcLines(JNIEnv* env, jobject clazz, jstring fileStr,
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 3f8c8ed..9adc52c 100644
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -1195,6 +1195,8 @@
   <java-symbol type="style" name="Theme.DeviceDefault.Dialog.NoFrame" />
   <java-symbol type="style" name="Theme.IconMenu" />
   <java-symbol type="style" name="Theme.Panel.Volume" />
+  <java-symbol type="style" name="Theme.DeviceDefault.FloatingWindow" />
+  <java-symbol type="style" name="Theme.DeviceDefault.FloatingWindowLight" />
 
   <java-symbol type="attr" name="mediaRouteButtonStyle" />
   <java-symbol type="attr" name="externalRouteEnabledDrawable" />
diff --git a/core/res/res/values/themes_device_defaults.xml b/core/res/res/values/themes_device_defaults.xml
index 87b1c9d..99808cc 100644
--- a/core/res/res/values/themes_device_defaults.xml
+++ b/core/res/res/values/themes_device_defaults.xml
@@ -499,8 +499,32 @@ easier.
     decorations, so you basically have an empty rectangle in which to place your content. It makes
     the window floating, with a transparent background, and turns off dimming behind the window. -->
     <style name="Theme.DeviceDefault.Panel" parent="Theme.Holo.Panel" >
+    </style>
+
+    <style name="Theme.DeviceDefault.FloatingWindow">
+        <item name="android:windowIsFloating">false</item>
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowFrame">@null</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:windowAnimationStyle">@android:style/Animation.Dialog</item>
+        <item name="android:windowActionModeOverlay">true</item>
+        <item name="android:windowCloseOnTouchOutside">true</item>
+        <item name="android:windowFullscreen">false</item>
+        <item name="android:windowSoftInputMode">stateAlwaysHidden|adjustPan</item>
+    </style>
 
+    <style name="Theme.DeviceDefault.FloatingWindowLight" parent="Theme.Holo.Light.Dialog">
+        <item name="android:windowIsFloating">false</item>
+        <item name="android:windowIsTranslucent">true</item>
+        <item name="android:windowFrame">@null</item>
+        <item name="android:windowContentOverlay">@null</item>
+        <item name="android:windowAnimationStyle">@android:style/Animation.Dialog</item>
+        <item name="android:windowActionModeOverlay">true</item>
+        <item name="android:windowCloseOnTouchOutside">true</item>
+        <item name="android:windowFullscreen">false</item>
+        <item name="android:windowSoftInputMode">stateAlwaysHidden|adjustPan</item>
     </style>
+
     <!-- DeviceDefault light theme for panel windows. This removes all extraneous window
     decorations, so you basically have an empty rectangle in which to place your content. It makes
     the window floating, with a transparent background, and turns off dimming behind the window. -->
diff --git a/location/java/android/location/ILocationManager.aidl b/location/java/android/location/ILocationManager.aidl
index c353ec6..e5bac32 100644
--- a/location/java/android/location/ILocationManager.aidl
+++ b/location/java/android/location/ILocationManager.aidl
@@ -89,5 +89,6 @@ interface ILocationManager
     // for reporting callback completion
     void locationCallbackFinished(ILocationListener listener);
 
-
+    // add set gps source
+    void setGPSSource(String device);
 }
diff --git a/location/java/android/location/LocationManager.java b/location/java/android/location/LocationManager.java
index 989178a..c8a1f0e 100644
--- a/location/java/android/location/LocationManager.java
+++ b/location/java/android/location/LocationManager.java
@@ -291,6 +291,14 @@ public class LocationManager {
         return new LocationProvider(name, properties);
     }
 
+    public void setGPSSource(String device) {
+        try {
+            mService.setGPSSource(device);
+        } catch (RemoteException e) {
+            Log.e(TAG, e.getMessage());
+        }
+    }
+
     /**
      * Returns a list of the names of all known location providers.
      * <p>All providers are returned, including ones that are not permitted to
diff --git a/media/java/android/media/AudioRecord.java b/media/java/android/media/AudioRecord.java
index c50e8eb..a1d3cf8 100644
--- a/media/java/android/media/AudioRecord.java
+++ b/media/java/android/media/AudioRecord.java
@@ -26,6 +26,22 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 
+////////////////////////////////////////////
+import android.app.ActivityThread;
+import android.app.Application;
+import android.content.Context;
+import android.content.pm.IPackageManager;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+
+import android.os.Process;
+import android.os.ServiceManager;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+///////////////////////////////////////////
+
 /**
  * The AudioRecord class manages the audio resources for Java applications
  * to record audio from the audio input hardware of the platform. This is
@@ -187,6 +203,28 @@ public class AudioRecord
      */
     private int mSessionId = 0;
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+    
+    private static final String PRIVACY_TAG = "PM,AudioRecord";
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private boolean privacyMode = false;
+    
+    private IPackageManager mPm;
+    
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     //---------------------------------------------------------
     // Constructor, Finalize
     //--------------------
@@ -239,12 +277,125 @@ public class AudioRecord
             return; // with mState == STATE_UNINITIALIZED
         }
 
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+       
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSessionId = session[0];
 
         mState = STATE_INITIALIZED;
     }
 
 
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    		
+		        	for(int i=0;i < package_names.length; i++){
+		        		pSet = pSetMan.getSettings(package_names[i], uid);
+		        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+		        			return IS_NOT_ALLOWED;
+		        		}
+		        		pSet = null;
+		        	}
+			    	return IS_ALLOWED;
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * Loghelper method, true = access successful, false = blocked access
+     * {@hide}
+     */
+    private void dataAccess(boolean success){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+	}
+	else if(package_names != null){
+		for(int i=0;i<package_names.length;i++)
+			Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    
+
+
+
+
     // Convenience method for the constructor's parameter checks.
     // This is where constructor IllegalArgumentException-s are thrown
     // postconditions:
@@ -530,10 +681,27 @@ public class AudioRecord
      */
     public void startRecording()
     throws IllegalStateException {
-        if (mState != STATE_INITIALIZED) {
-            throw(new IllegalStateException("startRecording() called on an "
-                    +"uninitialized AudioRecord."));
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY
+    	//now check if everything was ok in constructor!
+    	if(!privacyMode){
+    		initiate();
+    	}
+        if ((mState != STATE_INITIALIZED) || (checkIfPackagesAllowed() == IS_NOT_ALLOWED)) { //If applicaton is not allowed -> throw exception!
+            dataAccess(false);
+	    String packageName[] = getPackageName();
+	    if(packageName != null)
+	    	pSetMan.notification(packageName[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid()));  
+            throw(new IllegalStateException("startRecording() called on an "+"uninitialized AudioRecord."));
         }
+        dataAccess(true);
+	String packageName[] = getPackageName();
+	if(packageName != null)
+		pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(packageName[0], Process.myUid())); 
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
 
         // start recording
         synchronized(mRecordingStateLock) {
diff --git a/media/java/android/media/MediaRecorder.java b/media/java/android/media/MediaRecorder.java
index 0d78fe8..c4495b1 100644
--- a/media/java/android/media/MediaRecorder.java
+++ b/media/java/android/media/MediaRecorder.java
@@ -23,12 +23,27 @@ import android.os.Looper;
 import android.os.Message;
 import android.util.Log;
 import android.view.Surface;
-
 import java.io.FileDescriptor;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.lang.ref.WeakReference;
 
+///////////////////////////////////////////
+import android.os.Environment;
+import java.io.FileWriter;
+import java.io.File;
+import android.os.Binder;
+import android.os.Process;
+import android.os.ServiceManager;
+import android.content.pm.IPackageManager;
+import android.content.Context;
+import java.util.Random;
+
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+///////////////////////////////////////////
+
 /**
  * Used to record audio and video. The recording control is based on a
  * simple state machine (see below).
@@ -92,6 +107,68 @@ public class MediaRecorder
     private OnErrorListener mOnErrorListener;
     private OnInfoListener mOnInfoListener;
 
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /** default value of privacy path. You have to add the package name at the end to write file in directory of the app itself*/
+    private static final String PRIVACY_PATH_DEF = "/data/data/";
+    
+    /**
+     * This variable will be set if user use path to save file. Only if user is not allowed!
+     */
+    private String pPath = null;
+    
+    /**
+     * Path where Filedescriptor linked to.
+     */
+    private String pFileDescriptorPath = null;
+    
+    /**
+     * This variable will be set if user use FileDescriptor so save file. Only if user is not allowed!
+     */
+    private FileDescriptor pFileDescriptor = null;
+    
+    
+    private PrivacyRunner pRunner = null;
+    
+    
+    private boolean deletedFile = false;
+    
+    
+    private static final int STATE_RECORD_AUDIO = 0;
+    private static final int STATE_RECORD_BOTH = 1;
+    private static final int MODE_RECORD_AUDIO = 2;
+    private static final int MODE_RECORD_BOTH = 3;
+    private static final int IS_ALLOWED = -1;
+    private static final int IS_NOT_ALLOWED = -2;
+    private static final int GOT_ERROR = -3;
+
+    private static final int MIC_DATA_ACCESS = 10;
+    private static final int BOTH_DATA_ACCESS = 11;
+
+    private static final String PRIVACY_TAG = "PM,MediaRecorder";
+
+    /**
+     * {@hide} This context will ever be null, because we dont need it but pass it to the pSetMan!
+     */
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private IPackageManager mPm;
+    
+    private boolean privacyMode = false;
+    
+    private boolean stoppedStream = false;
+    
+    private int ACTUAL_STATE = STATE_RECORD_AUDIO;
+    
+
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
     /**
      * Default constructor.
      */
@@ -107,6 +184,16 @@ public class MediaRecorder
         }
 
         String packageName = ActivityThread.currentPackageName();
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+        //BEGIN PRIVACY
+        
+        initiate();
+        
+        //END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
         /* Native setup requires a weak reference to our object.
          * It's easier to create it here than in C++.
          */
@@ -137,9 +224,300 @@ public class MediaRecorder
      * @see android.hardware.Camera#setPreviewDisplay(android.view.SurfaceHolder)
      */
     public void setPreviewDisplay(Surface sv) {
+
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         mSurface = sv;
     }
 
+
+
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //BEGIN PRIVACY 
+    
+    /**
+     * PrivacyStop. Should be called within privacyRunner
+     */
+    private void privacyStop(){
+    	try{
+    		stop();
+    	} catch(Exception e){
+    		Log.e(PRIVACY_TAG,"Got exception while trying to call privacyStop()");
+    	}
+    }
+    
+    /**
+     * This method search automatically the current package path and return it. If we haven't found any path, we return the path to SDcard if we are able to write to it.
+     * If we're not able to write to sdCard -> return null
+     * @return internal path to package directory or path to SDCard if package not found and we have rights to save files on SDCard. If something went wrong or we couldn't find
+     * anything of it -> return null
+     */
+    private String getPrivacyPath(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            Log.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		Log.i(PRIVACY_TAG,"returned file: " + data_name + " for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    		return PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                Log.i(PRIVACY_TAG,"Return filePath:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return sdPath + "/" + data_name;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    /**
+     * This method does exactly what the method getPrivacyPath() does, but it returns an FileDescriptor to path
+     * @return FileDescriptor to privacyFile or null if something went wrong
+     */
+    private FileDescriptor getPrivacyFileDescriptor(){
+    	final String[] packages = getPackageName();
+    	Random value = new Random();
+		String current_package = null, data_name = value.nextLong() + ".tmp";
+		FileWriter fWriter = null;
+		File deleteMe = null;
+		
+		for(int i=0;i<packages.length;i++){
+			try{
+				//first check if cache folder exist
+				File folder = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/");
+				folder.mkdirs();
+				fWriter = new FileWriter(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            fWriter.write("test");
+	            fWriter.flush();
+	            fWriter.close();
+	            deleteMe = new File(PRIVACY_PATH_DEF + packages[i] + "/cache/" + data_name);
+	            deleteMe.delete();
+	            Log.i(PRIVACY_TAG,"found our package: " + packages[i] + " with internal path. File: " + data_name);
+	            //all is fine, break now and save our current package name!
+	            current_package = packages[i];
+	            break;
+	    	} catch(Exception e){
+	    		//we're not allowed to write in this directory -> this is not our package!
+	    	} finally{
+	    		fWriter = null;
+	            deleteMe = null;
+	            System.gc();
+	    	}
+		}
+    	if(current_package != null){
+    		try{
+    			FileOutputStream fos = new  FileOutputStream(PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			FileDescriptor fD = fos.getFD();
+    			pFileDescriptorPath = PRIVACY_PATH_DEF + current_package + "/cache/" + data_name;
+    			Log.i(PRIVACY_TAG,"returned fileDescriptor for package: " + current_package + " with internal path. Path: " + PRIVACY_PATH_DEF + current_package + "/cache/" + data_name);
+    			return fD;
+    		} catch(Exception e){
+    			Log.e(PRIVACY_TAG,"Got exception while creating fileDescriptor -> return null");
+    			return null;
+    		}
+    	}
+    	else{ //last chance, try to write to SD-Card
+    		try{
+    			String sdPath = Environment.getExternalStorageDirectory().getAbsolutePath();
+        		fWriter = new FileWriter(sdPath + "/" + data_name);
+                fWriter.write("test");
+                fWriter.flush();
+                fWriter.close();
+                deleteMe = new File(sdPath + "/" + data_name);
+                deleteMe.delete();
+                FileOutputStream fos = new  FileOutputStream(sdPath + "/" + data_name);
+                FileDescriptor fD = fos.getFD();
+                pFileDescriptorPath = sdPath + "/" + data_name;
+                Log.i(PRIVACY_TAG,"Returned FileDescriptor. Path:  " + sdPath + "/" + data_name + " . It is on SDCard!");
+                return fD;
+    		} catch (Exception e){
+    			//we're not allowed to write to sdCard! 
+    			//return null
+    			return null;
+    		}
+    	}
+    }
+    
+    
+    
+    /**
+     * {@hide}
+     * @return package names of current process which is using this object or null if something went wrong
+     */
+    private String[] getPackageName(){
+    	try{
+    		if(mPm != null){
+        		int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+        	}
+    		else{
+    			mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+    			int uid = Process.myUid();
+        		String[] package_names = mPm.getPackagesForUid(uid);
+        		return package_names;
+    		}
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"something went wrong with getting package name");
+    		return null;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method should be used, because in some devices the uid has more than one package within!
+     * @param privacySetting the Mode which has to be tested -> MODE_RECORD_AUDIO, MODE_RECORD_BOTH
+     * @return IS_ALLOWED (-1) if all packages allowed, IS_NOT_ALLOWED(-2) if one of these packages not allowed, GOT_ERROR (-3) if something went wrong
+     */
+    private int checkIfPackagesAllowed(int privacySetting){
+    	try{
+    		//boolean isAllowed = false;
+    		if(pSetMan != null){
+    			PrivacySettings pSet = null;
+	    		String[] package_names = getPackageName();
+	    		int uid = Process.myUid();
+	    		if(package_names != null){
+	    			switch(privacySetting){
+	    				case MODE_RECORD_AUDIO:
+	    					
+				        	for(int i=0;i < package_names.length; i++){
+				        		pSet = pSetMan.getSettings(package_names[i], uid);
+				        		if(pSet != null && (pSet.getRecordAudioSetting() != PrivacySettings.REAL)){ //if pSet is null, we allow application to access to mic
+				        			return IS_NOT_ALLOWED;
+				        		}
+				        		pSet = null;
+				        	}
+	    			    	return IS_ALLOWED;
+	    					
+	    				case MODE_RECORD_BOTH:
+	    					
+				        	for(int i=0;i < package_names.length; i++){
+				        		pSet = pSetMan.getSettings(package_names[i], uid);
+				        		if(pSet != null && ((pSet.getRecordAudioSetting() != PrivacySettings.REAL) || (pSet.getCameraSetting() != PrivacySettings.REAL))){ //if pSet is null, we allow application to access to mic
+				        			return IS_NOT_ALLOWED;
+				        		}
+				        		pSet = null;
+				        	}
+	    			    	return IS_ALLOWED;
+					default: return GOT_ERROR;
+	    					
+	    			}
+	    		}
+	    		else{
+	    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because package_names are NULL");
+	    			return GOT_ERROR;
+	    		}
+    		}
+    		else{
+    			Log.e(PRIVACY_TAG,"return GOT_ERROR, because pSetMan is NULL");
+    			return GOT_ERROR;
+    		}
+    	}
+    	catch (Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG,"Got exception in checkIfPackagesAllowed");
+    		return GOT_ERROR;
+    	}
+    }
+    /**
+     * {@hide}
+     * This method sets up all variables which are needed for privacy mode! It also writes to privacyMode, if everything was successfull or not! 
+     * -> privacyMode = true ok! otherwise false!
+     * CALL THIS METHOD IN CONSTRUCTOR!
+     */
+    private void initiate(){
+    	try{
+    		context = null;
+    		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    		mPm = IPackageManager.Stub.asInterface(ServiceManager.getService("package"));
+       	 	//runner = new PrivacyRunner();
+       	 	privacyMode = true;
+    	}
+    	catch(Exception e){
+    		e.printStackTrace();
+    		Log.e(PRIVACY_TAG, "Something went wrong with initalize variables");
+    		privacyMode = false;
+    	}
+    }
+ 
+     /**
+     * Loghelper method, true = access successful, false = blocked access. 
+     * {@hide}
+     */
+    private void dataAccess(boolean success, int micOrBoth){
+	String package_names[] = getPackageName();
+	if(success && package_names != null){
+		switch(micOrBoth){
+			case MIC_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone.");
+				break;
+			case BOTH_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Allowed Package: -" + package_names[i] + "- accessing microphone and camera.");
+				break;
+		}
+		
+	}
+	else if(package_names != null){
+		switch(micOrBoth){
+		case MIC_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone.");
+				break;
+			case BOTH_DATA_ACCESS:
+				for(int i=0;i<package_names.length;i++)
+					Log.i(PRIVACY_TAG,"Blocked Package: -" + package_names[i] + "- accessing microphone and camera.");
+				break;
+		}
+	}
+    }
+    //END PRIVACY
+    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+
     /**
      * Defines the audio source. These constants are used with
      * {@link MediaRecorder#setAudioSource(int)}.
@@ -333,6 +711,13 @@ public class MediaRecorder
      * @see android.media.CamcorderProfile
      */
     public void setProfile(CamcorderProfile profile) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         setOutputFormat(profile.fileFormat);
         setVideoFrameRate(profile.videoFrameRate);
         setVideoSize(profile.videoFrameWidth, profile.videoFrameHeight);
@@ -367,6 +752,13 @@ public class MediaRecorder
      * possible.
      */
     public void setCaptureRate(double fps) {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         // Make sure that time lapse is enabled when this method is called.
         setParameter("time-lapse-enable=1");
 
@@ -594,6 +986,13 @@ public class MediaRecorder
      * @param bitRate the video encoding bit rate in bits per second.
      */
     public void setVideoEncodingBitRate(int bitRate) {
+
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY 
+    	ACTUAL_STATE = STATE_RECORD_BOTH;
+    	//END PRIVACY
+        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
         if (bitRate <= 0) {
             throw new IllegalArgumentException("Video encoding bit rate is not positive");
         }
@@ -634,6 +1033,7 @@ public class MediaRecorder
     {
         mPath = null;
         mFd = fd;
+        deletedFile = false;
     }
 
     /**
@@ -648,6 +1048,7 @@ public class MediaRecorder
     {
         mFd = null;
         mPath = path;
+        deletedFile = false;
     }
 
     // native implementation
@@ -666,6 +1067,78 @@ public class MediaRecorder
      */
     public void prepare() throws IllegalStateException, IOException
     {
+
+    	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    	//BEGIN PRIVACY
+    	if(!privacyMode){
+    		initiate();
+    	}
+    	deletedFile = false;
+		boolean skip = false;
+		switch(ACTUAL_STATE){
+    		case STATE_RECORD_AUDIO:
+				if(checkIfPackagesAllowed(MODE_RECORD_AUDIO) == IS_NOT_ALLOWED /* || checkIfPackagesAllowed(MODE_RECORD_BOTH) == IS_NOT_ALLOWED*/){
+					String x[] = getPackageName();
+					if(x != null && x.length > 0)
+						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+					pRunner = new PrivacyRunner();
+					//here wo do not need to exchange the path or filedescriptor, because we can interrupt very quick!
+					pRunner.setDelay(50); // try very low value
+					pRunner.start();
+					skip = true;
+	//				if(x != null) Log.i(PRIVACY_TAG,"now throw exception in prepare method for package: " + x[0]);
+	//				else Log.i(PRIVACY_TAG,"now throw exception in prepare method");
+	//				if(ACTUAL_STATE == STATE_RECORD_BOTH){
+	//					dataAccess(false, BOTH_DATA_ACCESS);
+	//					if(x != null)
+	//						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, pSetMan.getSettings(x[0], Process.myUid()));
+	//				}
+	//				else{
+	//					dataAccess(false, MIC_DATA_ACCESS);
+	//					if(x != null)
+	//						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_RECORD_AUDIO, null, pSetMan.getSettings(x[0], Process.myUid()));
+	//					//now test something, because a lot of applications crashes if we throw illegalstateException. We intercept now when applications wants to record audio!
+	//					//skip = true;
+	//					//break;
+	//				}
+	//				throw new IllegalStateException(); //now throw exception to prevent recording 
+				}
+				break;
+    		case STATE_RECORD_BOTH:
+				if(checkIfPackagesAllowed(MODE_RECORD_BOTH) == IS_NOT_ALLOWED){
+					String x[] = getPackageName();
+					if(x != null && x.length > 0)
+						pSetMan.notification(x[0], 0, PrivacySettings.EMPTY, PrivacySettings.DATA_CAMERA, null, null);
+					if(mPath != null){
+						//now overwrite path
+						mPath = getPrivacyPath();
+					} else if(mFd != null){
+						//now overwrite fileDescriptor
+						mFd = getPrivacyFileDescriptor();
+					} else{
+						//no chance to get it, throw exception
+						throw new IOException("No valid output file");
+					}
+					pRunner = new PrivacyRunner();
+					//we use default time for video record
+					pRunner.start();
+					skip = true;
+					
+				}
+				break;
+		}
+		//END PRIVACY
+	    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+		String packageName[] = getPackageName();
+		if(!skip){
+			if (ACTUAL_STATE == STATE_RECORD_BOTH && packageName != null && packageName.length > 0) {
+				pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_CAMERA, null, null);
+			} else if (packageName != null && packageName.length > 0) {
+				pSetMan.notification(packageName[0], 0, PrivacySettings.REAL, PrivacySettings.DATA_RECORD_AUDIO, null, null);
+			}
+			deletedFile = true;
+		}
+
         if (mPath != null) {
             FileOutputStream fos = new FileOutputStream(mPath);
             try {
@@ -718,7 +1191,24 @@ public class MediaRecorder
      */
     public void reset() {
         native_reset();
-
+        if(!deletedFile){
+        	if(mPath != null){
+				File tmp = new File(mPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else if(mFd != null && pFileDescriptorPath != null){
+				File tmp = new File(pFileDescriptorPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else{
+				Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+				deletedFile = false;
+			}
+        }
+        //
+        pRunner = null;
+        System.gc();
+        //
         // make sure none of the listeners get called anymore
         mEventHandler.removeCallbacksAndMessages(null);
     }
@@ -1000,5 +1490,81 @@ public class MediaRecorder
     private native void setParameter(String nameValuePair);
 
     @Override
-    protected void finalize() { native_finalize(); }
+    protected void finalize() { 
+    	
+    	if(!deletedFile){
+        	if(mPath != null){
+				File tmp = new File(mPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else if(mFd != null && pFileDescriptorPath != null){
+				File tmp = new File(pFileDescriptorPath);
+				if(tmp.delete())
+					deletedFile = true;
+			} else{
+				Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+				deletedFile = false;
+			}
+        }
+    	native_finalize(); }
+    
+    
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//BEGIN PRIVACY
+	/**
+	* Helper class to interrupt stream.
+	* @author CollegeDev
+	* {@hide}
+	*/
+	private class PrivacyRunner extends Thread{
+	
+		private static final long OFFSET_DELAY = 2500;	
+		
+		private long delay = OFFSET_DELAY;
+		
+		public PrivacyRunner(){
+		
+		}
+		
+		public void setDelay(long delay){
+			this.delay = delay;
+		}
+		
+		public long getDelay(){
+			return delay;
+		}
+		
+		@Override
+		public void run() {
+			try{
+				Thread.sleep(delay);
+				//now we're going to stop stream
+				privacyStop();
+				if(mPath != null){
+					File tmp = new File(mPath);
+					if(tmp.delete())
+						deletedFile = true;
+				} else if(mFd != null && pFileDescriptorPath != null){
+					File tmp = new File(pFileDescriptorPath);
+					if(tmp.delete())
+						deletedFile = true;
+				} else{
+					Log.e(PRIVACY_TAG,"Can't delete temporary File, because all is null?! It could be that we only want to record audio?!");
+					deletedFile = false;
+				}
+			}
+			catch(Exception e){
+				Log.e(PRIVACY_TAG,"Something went wrong while waiting for cancel the stream!");
+				e.printStackTrace();
+			}
+			finally{
+				privacyStop();
+			}
+		}
+	
+	}
+	//END PRIVACY
+	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    
+    
 }
diff --git a/packages/SystemUI/AndroidManifest.xml b/packages/SystemUI/AndroidManifest.xml
index 2cfdac2..e885c17 100644
--- a/packages/SystemUI/AndroidManifest.xml
+++ b/packages/SystemUI/AndroidManifest.xml
@@ -78,6 +78,9 @@
     <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
     <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
 
+    <!--Halo-->
+    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
+
     <application
         android:persistent="true"
         android:allowClearUserData="false"
@@ -260,5 +263,8 @@
                 <category android:name="android.intent.category.DESK_DOCK" />
             </intent-filter>
         </activity>
+
+        <activity android:name="com.android.systemui.Transparent"
+            android:theme="@android:style/Theme.Translucent.NoTitleBar" />
     </application>
 </manifest>
diff --git a/packages/SystemUI/proguard.flags b/packages/SystemUI/proguard.flags
index ab45d99..f0223cc 100644
--- a/packages/SystemUI/proguard.flags
+++ b/packages/SystemUI/proguard.flags
@@ -7,4 +7,13 @@
   public void setGlowScale(float);
 }
 
+-keep class com.android.systemui.statusbar.halo.HaloProperties {
+  public int getHaloX();
+  public int getHaloY();
+  public float getHaloContentAlpha();
+  public void setHaloX(int);
+  public void setHaloY(int);
+  public void setHaloContentAlpha(float);
+}
+
 -keep class com.android.systemui.statusbar.tv.TvStatusBar
diff --git a/packages/SystemUI/res/drawable-hdpi/halo_back_left.png b/packages/SystemUI/res/drawable-hdpi/halo_back_left.png
new file mode 100644
index 0000000000000000000000000000000000000000..b7a0a7174d53a1a79b0f44bae5b72743b49a1d68
GIT binary patch
literal 3014
zcmbVOXH-+$5<bCDq_-qM=)IF5B81)oK>-OUk!B)<dQp^sA{U9M0hHoJq$mQ?rQ@Yb
z@d6egfFRXEZ*rAhL`B|q-M7|z@9#TnpV_nb%r|@XH?!6`aVPDqc{s&5Aqe6j*jN(5
z9Q^C$I0WRnF+3bha9=Y!GYG0q;`%{h1#4+98=@TqT~&l2`b`M>2Da!+5EP1mpk*=y
z;nE=p6`a}RXb3?pD<@AlTLFjv<6-A!MJVw};gE`Ww5pw?hO@NRDH#k&7KDPqAaNaG
zeLrQZYZ$wDU1B=!be0h*&&0LR)UC+O{mH)voc)kGQJN5=<CI}QdTb1=z~oVC{?7n$
z_|TjLh7Q2~w@HI2EvhMK8HsUzVBl6{>QVB`AB`1q$u<VkI$E2QYXY#mVw@HcTBoy(
z+)K>V93-96ac;$cC5WAe6@Oj(Ouh*~0jWd~C#K@SxyrT@$9$B4ze~1}`Bg2~0#o3?
zjXcaL$ZnT#3}Aue6k@keJO-TYfGqxX3$Skyfzk6*2L4KTv`dZ=moNu04X5rX#mWf>
zhq7_Ofe#2Msv&57<A{5SIY^IiOGiXQz$M36L|wqO$ke^m%&o)}@ZeKr7uIl=Qf_S<
zs{=Ag?2Kr7UqP$)09KF{oCDA$<ymGC^H<2*CFa7$bn}Pm;My~QgxL1b!KLnnjhVUi
zsrilR#`om`PaOvryXV#?=hvsINAi5D?9tjnq+H{-OFgq|6V;>ne$@^@sT#@iuRaMV
z()U-HU7vI>`Beg|D6CzA?)>`n%-RG{*tl7p(hU@?(BO`-?X-Yu$C<T{l_R+z=9wqP
zs`iqtA8Y6>ftMS|mm4Xe^`6wq;~u4ETBl_^%Pa?$y2t+>1lbOK>K$3`XU@O4(RRVL
z#Kg1I;!elqp(W<x#tgW~;^yqq=KRFU`0e&E*C)mx2hb1VM}%!-bO05AA`K^L&<WrQ
zAXUH&XaMsFEqt^#s2vxA1JJHyjRpk*6$G202S9arML9v+Na!N0u3`UCU@+Lh!9hZj
z(GSoEdo-fG69hZN%FfBdCm<w@;D;aPWfMe-Ny^A6C@QfCifbA>_(mjUmDDt}AQh|w
zVsab1dzoA)>)#8T-t;M;4Fd~0d&HyBX16(z2G?5TeJi<<ruSc_NS~{fQK!>!54%vP
zlhuwWr+Q*tT@_9vQ-+Q_Cy(?&Rv4hoTkhb|(dc|8)245*mk>F=FxYbqDbE~T*<Ktd
z99`Mj-d^Zm+1{S(7mry1a%--iskzO3X5z5D<%sl^$r|n7n(gb6TN-}*cCe4B$Xr=p
zU0wS!(!(5E-PzgM-5l#_jg=tS7AW8)TBF1bOudlTWgIlj&1+D3;>Ot$f*i7jVt@qL
zx#QNBdndeI)*y(jm0)S+>^IT!(4QpaBFwmlk<YjeQ3T?+SmGYQleu$c=!!YH${gpc
zN@Y*ggr0pDfcTqHS66%6qiT?~G$<&r_8Cp<<EPfucO$9i>xNI42StS~Ok`jPY?qWW
z8W-95l6)3=^>;sf$>h6l8~x-c*0St$k&=q4W@4^Qi#_^yr{559;`(_p2EyUxEfLZF
zlSj2Xh8Q<3TR50}!%B)G-XSTEKiQ~i#yjTQOBUh?f!tSXpR*jiDz>|ge4<Fpf5VlB
z)mJ!Le)j4?eEiQ(`-4QM<OKZV-TcH@Hh)=K3SE~xmGf7I#nY!D%+$vn44&Hbkf(n#
zym=*cg6VX^Cl06lW|8tq1J&~l!#@4JA$lJ11DVxr1`^?oVGl#EWM&fryky(`H^RlK
z;uH-L{q8U7TVKx@Eo=zmKIY-y-NuWAD`sd#J}5ria)3sq#Y@g^ha1u=7uLTvd*RcB
zzsm_~g(}+_t=vbZobf|RjJVenl;zaCA`s;KZRWDk2IrffX-%^1(~_i)r5+T<v26vX
zhD_%xo+wMVl$(K)vz)OPSr!Xg#j$0}q?N+~m#7F_e0@oG*N@F=8_T!CU&Bk9d;-eh
zt3NzP>`R|4cw$*8(soV_m6r#$a47SNSns6L^WV7py4EZwOfD_Fn1~IAK0P{m&vJ7>
zs((CWS#AN_`Az@NKXOYJX7opW5?R>q`n-47EQ$2y&CcdYW8O)A#lP5lf#YH6{N2$8
zGG)k+(Xd8LBu$|Ep~VQV1*!m(adK0=`?s5FrdolChbw$jf~vWH!lY2|$*%>igsdO&
zg&)uDMZpG|;ewkl7=J)VVqBX}=t^3+*9r3zWK)Xb*qi6omgi>&X#2P4=^|21avk&v
zcf{T|+2!2J!?q$rWKV8xKf6a|h76L+p&MefKCD0N!nRIEIQPYO0j5K2KB~<0p336;
zQY5!<s^3I$=+vZ7<sa0S><@f<U8fT4^^S5(ZJ$DH%#uo#*=DWa1~%nxmE6JmIMvrL
z<flSDU7=pl`RL4vS62x}$scP#h?tESuJCw2@AD(CdJPSu5i{7%gok4}VtXEPun%8s
z)w^LD3R8(0(kC+5o)Ps%KJ!G^V5?w-w{?%FZ@Sgl&Nk|zs<8@`6GEngx)BO%bwO=-
zv4IGU^edP`a-LLchtl-k-xY0?BKe%vmmcK5+0il)$&bU5%p5XOjgEc%y{9~xo^@Ic
zZQa5+Ti?a9MHqX!TNfErKY4KxsbX56Fz2#H!l-<<pNrZ3P+J)p_5LG!KIC5{aU!1N
zL##5830=!FpSv>Av$kSDYs<eoc&m|pJUw7|P2GaG+ag{W-M_QXXL#kSjK8VFgn(dH
z(DU(jy|L?hTxNzzlDHpLI+9<m&N<2%`ty@Hq%6?p{Qa-8^=PKKQSp0O@EbPIGxbNV
z&yn-j;hJIc9c8ehq7-%cU(4rZ!ojJ;YPDncA0$BWvRUdFgZp+)k2uSYI2cJtj%{$q
zFa9a8?&o4JMhbK$moE9@W0g7rBUbiMo*z_v+&VN5E!bC4ipR2@n^;w{z65EtH18v@
z5!<z+lN_6jCK^5Zxu$ixLtEpn24nQv)|bl@h}zwWgQ*ToWiZW5daOvBvAsW?Wc+jP
zZP<wMclQsiUpGoCJD?<AdL+t(Kf<P3i6<TTNTi50{j0zJS4HEU0-o<P36T-)tuQZ>
zb7T|Ci?2G}3zFiLTBj4^#`xMlI8GLBIkt^Q4aKC129~y`Wyl^-**r(XPLZEgTtp3C
zxZiU3no`5vcD4Fb18TcntE?{PKU=YWrV3SHY7U>J*z66C^5tw5Y`g3>%y`}-O6rEP
zBX?6Y&;Ar4w$5?Zyx>ImMSat6Fzrdp8C4}lSA0{bf%hWDlTN7;y&aJLead6_^d`5m
zgdB3-oXY?{?oxS<Q(Ihp^wkF*OKv97`cVgY^**SbFv*_`g`L#j9NzA2$!0w0EBbyO
z$Mt?$o8N;ArNi(q-Q{3k@Dk)Dr{UqTCYb}^jh*4U-aOANE1uKv<)7DJf%V5L!wrkx
zuo_;nNh!2VR-Q&trqeQ>u-v3Y=@JA6kM1Ml?%E@y5uY`c4elr+4Bbw@k$CKkA#wYg
zh<b8|4{GvTEX%#A<($u2EbBFJ{hl0Ax8hfqb;ow4%QZG<yED9Ai}YqWB-=zLDd!YI
zb$tK(>sw4->G4o;la;FUgRZ{i*UiCmlLy|(pG!I|yN2VH8;`W8$>piF+!Ii6=~1<1
zvuS=BNbgirU(66G*vzEt&q5Q9qCbC3M-fI|Ak6|tioj=0fo4Ubc~fXqoYy5Pm>_Ko
z_J{^XR|AW6#%SX(M{wG@YQGfB?oF5O{{aMD@b>o!{|^A;jMc~K=;3tq{{g7_52yfu
v=&uu;F8I(cQ!Y^<Gw%!MsM3TWiZ7K&rFe&5?4p97YX~A(*;`halcWCyZV5D9

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_back_right.png b/packages/SystemUI/res/drawable-hdpi/halo_back_right.png
new file mode 100644
index 0000000000000000000000000000000000000000..1382ca15d305c013bf55a35c637e3b84a0bf9d30
GIT binary patch
literal 2994
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
b?nAYvx_d<gf1rXNX$T@3TjCpy+~WQPuxBpB

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_bg.png b/packages/SystemUI/res/drawable-hdpi/halo_bg.png
new file mode 100644
index 0000000000000000000000000000000000000000..2bccedb1743d9eedabefc4ef2cfdc7d55f1bf128
GIT binary patch
literal 2608
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
L2jhlqQ0jjGa8x_#

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_bigred.png b/packages/SystemUI/res/drawable-hdpi/halo_bigred.png
new file mode 100644
index 0000000000000000000000000000000000000000..a864254f9b59d5c6bd88c640e85df4c20a79844a
GIT binary patch
literal 3102
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_black_x.png b/packages/SystemUI/res/drawable-hdpi/halo_black_x.png
new file mode 100644
index 0000000000000000000000000000000000000000..6f217fb0a299dbc45dad8a39c06ed67ce94c3d44
GIT binary patch
literal 2522
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_dismiss.png b/packages/SystemUI/res/drawable-hdpi/halo_dismiss.png
new file mode 100644
index 0000000000000000000000000000000000000000..97c30ede1f8c0632ad8ca1483b57567d28f4a75e
GIT binary patch
literal 2761
zcmbVOc|2788b30&G1g%w4P)%2VK7m{Y}T<eM!BPuT`D9?c9o?F*+OLOY6!_vmhwgv
zvR1FHBzdW%@QSyT`+IMn`?>f2d(Y>0p65Bw`hC9Vk8>_N*jb3c_rM_t60u~MGJy{I
z`xfK{a+Ly$01D<yx1~eSoebe^cRuip^JFk>At+K6g5nb(=o@gwFF{Z!0fIgphagfu
z1fhe9+8m7_XqTmf4a*E9{2v#Bk55fZjD$j&V=%T@EDMKoR#0$JR0OSfAc!a><)^M5
zOCVg)*Uu-Bipk`1Dz%D6tESU${rd>;@-lI_WFoP^(6E$30Z|aDF*g2nKpzYoo<t;q
z+W!t|NlL~L2-gh_t7$auzmj#3NDhSp<ON;bGAb1m?t#Ojw6!^8GM7%b$6{~N0Y8uk
zAK!Uh-3lrd^as*XR`wc+1SVR^$@!?Mf#gVS?MfOAL{UOQk^%y01_q!INTh&3x`6@6
z1QK|F0b~?`02T!KC1kRcpkN+}<R~u>hrz(I!Y~*}0NwDCk{9*#07!r;kx0Z#NR&`0
z`y?a)a<KI!A`uJ~1SH7IbE#AS75M8IjE8}NO@|NnU%K>he0-{=<}QoHrO|Ye$TAA$
zVNlTeyLYRzv%tSLH#f=UHXS;2LPG=Cz&UyA7Qhy#qm!nuzxMVmkoks&W*7_rdDqFw
z4vU?xt2?Biu=?iB^zGXq6L794CG`u56AlNc22%hGfC`Wd$OQaI3kre-Eif3s17Ha_
z!D=#aICvxa($cXyI=>7a9-f_@oqKP)Hv!R)LYQ_=5Dzb(09-^&0x2ae4iggPmqhKs
zDk!O_s_l}L)uPz@Mr9Opo9=a@R4n|H%kK9-8x%%cL|3(q3}K8;R`v|YUck^(1W|^u
zoyzqH6fL(m2j|hOurHoe_!NzHxZ{X+YGt;xG?4H`@hA^vln<)T5M$h#YL2;psbE;f
zpp*v&tDe0aomu^3WKcHw<>to1#=?l!*FP89srFwTeHDsFlonMt{&;Xn&eBT7T<$@f
zEX@;jUcnx3+=MQdrEugVZK9N~fo*s^tSw9*{Rn*U9D?|7SenvVey=+V|2l@W*xj4m
zpgfrf&E=dE$4O+<vdoAuWgb5I!Q1B)oGUh7wy+;_pDU>=x+Ly0cC{8}Hs_H~ef-Dt
zPv2KJCT;bfJ{nSOU;p_g+1_ijaI@g!jRJu*b928?4O8yx<H{O)@o8m@ayrMVVyP+k
z^?58QDc7#*F<-%uLnyqvsp^VNx!^v;ejlHFDeIh48OB~)MfI@~gi~RqL0<=3e00b2
zrLRirb4h+?e&S@&jqJj_V+~~uL1y$=w*b4A$$f*xMDeFMe8PFjkwbOt&Z;NuBTWCh
z^>|I!ldZYeq+C;9*19z_yDAU~DvoX`lp?v@mZ7<j+{5?CZmND-6CCnNN^suz9WDHz
z@`i>Gh!~~o)`zoBPb{sozIWF$&i#0So$VE|>x<MIR@Ph)L*m^Lar4)wY(vkN%-U<q
z#KsXET5q+e)-u{=s+vs4YU=$P#@*Pu9Zj93TuN3&?KPtJ+VJVuV@s}DtxHBRX|DR~
zv&8WPEnlRXT66P#Z%o=HUPh#=_4*+#YfofZ?G$T8$iKZ=TCUfkCe&~zdavZ@7=Ikc
z|MSvvR_4(I19ft8pJp_t#P^Ji^~Q9DhlNE+d`n?`UJd&^^H@d0_T9Qt_-7&I1l}iI
z#jljv>F(ssm5-MBed1AHKbbL|2j1VGJz>2|;Hv&&tlbOmNYPnp)GYa`a)tu-z=Y=H
z;X+*fXNR~kqoj!)ti>sIitmN_&ibVvFmsdWEiv@QZ!*U(AMD$;sMjB1dVZUhZc*gW
zXfv8#emkL~{OMOT&uEyGq~_!6nUGR4DeQ<2*2E|lA#SNyTx~7T(SaoQulltunqqNP
zef3WqMzX6VImb+$5Je;*v$Tau8r`r>dO@dWMO5A2=7#4e@9Xz+@b%qq)5qg)W~|(5
z=!^d1p10Pe_0eMWhxti}^NC#k<Wh#{PQhIq=3<baIPPPHYfj&tQ6}$H>LuH&q;NO6
zH-DXF*`)jfxA@IG^c<1wAjaOO87Zx-y~XmQ>u*00_Ilp$=dtPeTn+8~R;MR5&&BcC
zHaC;!YglvGM*LTHL*JlySb<v}`+)wD&I<va9(+}@dD8OhnP1$(8m?zKj3Y))2=My*
z?B0?>7~RxxS^E8`5LXD%a)i&C>LNI4mDF}9dBnRexrZWhG%t3H3M20SuoY2QYrH$b
zAV4%#+@#wekii>cm&N(b>9>-gh>D0-^MH)>$FU^+$f$SMh@<nnc$IQxq?WB1ul}lK
zGl$!iHha}PE_;?E=Qqt)thnr>vB@u3^@+`h`)$U|(UC7bTZ{AAPLAB9D%AopwIma!
z{ddhOOPA^RsYe~Xcrx6?Mt9TKC-Go<+R)I9@7T3>qp!6e5WB4|LbhAEA;`vhPEiCd
zn*3cFJ808uP|JWl<WFOCQL@R&#AjD*pTV6IBZurtzxaJVqQAVqB(h(_yzuujmf7z}
zDD^B2U+L}}u(uU<Mp63aUJHAaOV&V`(?$M4z1iqg(%Iy5&JpC%HP86U5`F{!E@oz+
zN%X$j58EBG<jDqnJfBJTPiyIkOwK$jX3HVH_*4iQl7eZqjmpEgv3&^$@??;<G0vqL
zKHz0!nf!<Roi2;@;B$Y@8#k=H74XQDimK-6_TZUsfOx6(QnOuslxBBM#~p3^3H0%0
z75=Y^DVoTE7g|V8^l<Lw31RoT=i%I=AH<TZW9}84LAXy3c72+9fjTw4KfvVM#Wu{C
zJRgQB>$=j$fw=}OC&MQ)Z0}txwcZj<dQScJO-456eRp-#%-rjEwv4Dz8fC`m`_@|C
zy?N`E_!jd@-l=18spOJ{jFMq)FznToY#i*FT%)h6^Fgm+)cqpI)jg%_*C+O0NI|PS
zOm)k-87}?jve;@($rEq1)sH0EV(Je2L!<EbQ0z}(>*d3ZnbwPo$<l2hu@AN@?|xw)
z<tc03ap3ecNA?^D63;#ZweMH#-=4GV-JYWp;{=!S+F5s7J7`U<f(WDbEW#Hf6N4}6
z?v5XFyd56}K6(_WH*PBP-c9t0&X`DtO%J2`awD8_+y7jmk9714hYcdV=6J2lSfWQ#
zh|u8GURd;P<MzdqeQ$D07nX}n4)e>^XE#PQO8EN4to5R=>~G?a2`pCk^n20c8n#m$
z>q->Z*S^x1@hWVZs`B`(Szz_f4||1yI`hGtnW6kFG#n)?j21@ib_#AUtMZEPIoZz7
z=;#eDzC21A=6gvMeS>s<Gc5m8pyu(>@`<Z!=HRQP5@O~O;^iLVP4W!(1`5(8=;+}I
z`gk237D1Op&?D*UYyNEzHWLo_|4+f`K(7-%5&tP5uyhWRhzCf-gTD&)o*2~t1u}n6
ta0>JZ33m_nhUi{_9^N?1)9$|BOmBCuh%-;U!T%)$S(@3I))^na@K2*ih1>uD

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_marker_b.png b/packages/SystemUI/res/drawable-hdpi/halo_marker_b.png
new file mode 100644
index 0000000000000000000000000000000000000000..db3fbace9f64b0caf02f26925ca9082706cb22db
GIT binary patch
literal 1809
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_marker_l.png b/packages/SystemUI/res/drawable-hdpi/halo_marker_l.png
new file mode 100644
index 0000000000000000000000000000000000000000..88f504dcf7cfdefafb246601a3e613566d3c785d
GIT binary patch
literal 2045
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
Q?@AVM+v`CQkb}<s2Mg_+P5=M^

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_marker_r.png b/packages/SystemUI/res/drawable-hdpi/halo_marker_r.png
new file mode 100644
index 0000000000000000000000000000000000000000..54cc80504d222154a3dd96bf0f039eae44916b1c
GIT binary patch
literal 2025
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_marker_t.png b/packages/SystemUI/res/drawable-hdpi/halo_marker_t.png
new file mode 100644
index 0000000000000000000000000000000000000000..774238351fe24bf6adc56a606e89fb471eb972fe
GIT binary patch
literal 1813
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
AC;$Ke

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_number.9.png b/packages/SystemUI/res/drawable-hdpi/halo_number.9.png
new file mode 100644
index 0000000000000000000000000000000000000000..a1266b11bdf8b56d301404667ce7adda8ccdb7f6
GIT binary patch
literal 211
zcmeAS@N?(olHy`uVBq!ia0vp^av;pX1|+Qw)-3{3vpiiKLn>}1CoJIkvpm3_Sy^B+
z<3<L7Zsv_5Q#V>%$uV0ITfiVBu(YxDMTAI}xD1Dar<a3hfUvj1O#Ox&L!AoMQ(wRI
zY~Qted2VU3_fjslS*%9FCyNSGx*s|+2GwYre6cq*JmIrth0NB9AJKp6uRIFu&dmDw
z|Kb9<trb@uEzJ4Iv96ze%|`Qtv$q+uFYrf*x6L>wxl%%(fuS&bjjkKNizv{Q44$rj
JF6*2Ung9qNOf~=j

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_pulse1.png b/packages/SystemUI/res/drawable-hdpi/halo_pulse1.png
new file mode 100644
index 0000000000000000000000000000000000000000..8c252f3aaa802efdc0f327e71e23733566e2a6da
GIT binary patch
literal 6999
zcmd6Mhc_Hf)aYs<HV768(Gw(5LzFEx%BsJ`Cc2R5eU;T)tVCU9B}5{+h+ZOkT||%s
z(M4UI)g!F#lk?s=@4WxuJ9B34v^z7m&Y8K<dOGS1^qlkn0DwVLL-p|`JouOCu3VN&
zECJn@fZAROsRRIgP5_=-(p<LrtTi4Z0e}D@03h@g0C0TS6}k!lcuN8Rq~`zt_#FVi
z;hxrjf?f_>vC>vo1zh|~S<U%x002%+O;sg*zlqKCqc?U2{#|f4vKRTMr1Z6GFBc?5
za`?jJL-Vq-m|rgO_-YH9+$+2dUwNTvP*n0&|NY0Dc}^n`g5d@SD9WXBHH+%nwLV43
zX5>obHVo4bBd49Tz^2{GXLUzPPYx!h-CBcZPMZ5M8B4b$zumBomHOXTyqo)Fwk7vG
zqHAjE>1^iOe$dqt#A#ufC;hxwaM|3^>v^+&v%_N67f!{Yv3`N!<=QKUEAt#bU>QGx
zB*@i>*05dSFUo6z%QFDlBpOCn6d95w8h{H5pVPGtPox90+Xcje`phZaP77CW;mBV5
zbzT`iPSIx(VmoYDc)0DSjt48Rps%4kJ<!=7O=_nTcgPS$ogt7{z(-|TTo7U|@tGR9
z1d|e~z9vCBe3yGuhAW%hQuObzz=|r&%<rk^^gfdbQ9E8e=w>$^*#5mWbAnKUb~}%{
z@+6&0Q3h{uO9rJ-QLBQ%*=Y~SUWZRghrjKUxS!7OmjTS3MAklb^5Fb{g|dLs%G9R*
zPp$$Qn3lzcphk%VjRmC(RSjih(Vh^oY1Ow@Kq`TcnU_WgyAsNQwGZteDBV6-Ajn9n
zn0@^+uvhpCV|aRv{b*;GPJ)6a1>%#g{>ECxGak`IbJY*x&g@RLLw|c>=ai0ROr&~T
zEm5P;g6!qRgHVPuK!LX?GfH^ijJE(8%F3C_VT#Bn<I+82>6Eo~kvMhVs~V!-eaf`V
z`Ra!=^#mT`1L6|l&d8XAiZUE4x^>qkJX1{o5}~SK5xk9fF3qx1L)sO3uD-wT-?Jx8
z*z0}`r+@;WYOcSnofY5QDlFF7zp;_Q#GSB#UuC^<|7t+2=`U6S4PlAkO?asBa}vKQ
zgq@{i5^xSE0rQr$$i1Y7n>26P{H?Vw8sjZ&k;96f+YzmZK|}+>7Re1=J~MWe=-VAL
z`{ZnM1s@21BCo}MOLQlDj+vW<+pt0Vmo-7bp)W{`<?nh?xvn6`kqJ?bP>wyp3XYJ4
z3a1?%8VMdYP$L4%rz_Uo?FqU5CkR3w!5Kd;Q53Q)?=Hb|*pG$tx$zrsKkv21_W!!}
zGn{PgA@P8x7a?R_xKQ9Nx@!D$q1)6VYWb%eg^}R;DJ9Dv6@p;5Rm2h62wh)nRiZua
z*auY|@y)tRNG3QZ{_-{4Uf?I%6A}_Xgd~}c56K{SME(3)?PpRtoBjN5b0q#Z3_+UH
z@J9*;1@rF&5Y=vP0P*rX%Iv#Fgzd!pK`}uC8m;u7lggCeJ)UsAhNSYLGy=FO3AEnu
zzs3ZB145#fmnHOo5O%+f3`m76H8c#T8d>mi9rjkCCMW8EHnBiL8ME|^@&fmC^UQ$}
zf|QP&(jC{+kh`;u(X-4~*q8F6YGCn`c8Ad~bC=DK#}bRrq16TXIbG%$H(Vgr?=L%6
zF-OOI%VTk3>&iK`A8%!Va3Wtw=yFMamWWU4W0LR&HdXdD`2(wu_%Dt?p1FFYh`2k0
zyL5xn=A(hVOu($tlPEsYT~d;Xyy<*R1xJLs8x|C1;}I&#?)9$Rf+C2{527Uni={pb
zPAUpW^g+uT-5yN7zcuFb`v-KZC`>ya<k9pzDS#(L&>cvB9!CkMX^CyZtH_A?in^O^
zA-?9;0FI-;b(2cNtRit<R68h{e8upurwlTgidqV`pl7FdY9WfXtNQ_Gh6Za+49HU7
zyW|#TzdJkV+dD7^@GdWbtfvpJnNnJ;_b0z6yDmqnZ-}lI+}1|Gl*Beta&Tu<tL+!u
zJFY|@&=Mos_ioHB9A^Z`i!;mB3lBY&PkqtKb9f_WhnIE>fL1{t%Xr6#*G!3dn2qms
z3Hq>umWS`4bhD2Bc45i6RtbTj64~{CnI}*SX$82l14;2yWr$<I$599aBU&vd#Mj$J
z)$nA9pa^=HnZxdPcmZ3n;NyCG!cbzRg{|ZxMU!@aU|X-8UyJ_BNZb?20_9A99=TVa
zr!BDhw^|UJA1<D~B)xf{#ibk)KD90AK>sISWc)xu=A!S6wUlMJzFq+r$YVUd$7kIc
zR$y)9B>=XdIAyCel%RY@(-KiKayM1!V-?N`k@W1_i}K@(1*Pt#K8#1`S+|NmdmWoC
zRgHnQ=d;s`&W?1by+=P)!eA)q-uHPC5BJ6n52>A65p`I&=&-AUA}smV+UWxhkeL*R
zw>sRvtN{%L_fgDHoKpR<xzr;zll?c{cO>eU0GRu>*9^fm<9ou*cnrtR4}4w-yy5u;
z_o2X!x|5XdYl%_g-DG1;FPNdf2pclRC?)|?yaEr8F%=4Zp}ZSWh5#*zk2^8F3Wot`
zfXQ#8ub{T66)Br&uO7-ShS8$B5{bscj>k@jXM~<x(2N%;se0`f-k`ig9f}LOCW=Gg
z@SU3Soxr#TPh2CM{oqt1m*`OzaBZn@Hu4pWF^J+&SKm+p0V}tV4!=pWK7IV+LBh7$
z!#^)x#+YW%D!yd*Tdh0{pujb<0vnm$3nV>O>9QM6-uIA6ITflLRT?&b8(<Iv4sO+S
zFMY=P{VK6>#P}RWFPTAoPUA0kW~lm*J64p;W!wYutar3jb8nMSvCRq8qv~40JKv<2
z3ac0z?NlrCsg7=tlHU(Zpt&(<$)9okn-%BuU$pxBFcj!b-PP$E3ygIPGG>~AghzpI
zN{vJ}+BAyG=Kc3?kiH*l6XOb+|Hu+isUrrClUCZp&e+(xg=FM{csbwB3cg}ntrL>@
z2r0FzFU(G!xKY4wZPWxeFH9qb&4z(L#Al_hKKqrX>)SBvj2O1RQj+1@MNvK8^eNru
zL=S4kL}Ceqe-DNu8V#!FUI&(?cd<7T0RHRlPs0U>3*DusJo}Z+j&nV!9Q*GnxPFQ;
z$u;X0{P7;9I1pY{yV<yCJzSa_r}Ra8=3D!guDCt-R0lAWNzmis$|1X{!}AF5#SjkK
zvPrQ7E{jj7=|gUZ{p39?Ij0Umitn1Yn53!$h;Cd97MR;T1()dh+}ghdR}Q(G<)Y;b
z`(;`G#8Nl6^G*vE{n|)S*8#G5=lx5v4ZWW`%P}bT>-<c3$#=#o{OpBZ`EGLYnT7Pg
z_R;GoNFR#Uqid%3r3iy8RTBfv;A0$2t1`D>dRK_u=l$zyM%>k@SS<l20gh9JKdve3
zgOBq;U%AU!Sif!E_UzhLZ>#bZ7=xOB?qvSMD7u0691Q^F)uPK<&J{`J@sr{z)IlSL
zNeu7hNAZ)0Ma?S1iK|2;!9r$Vv$UquoX{@*=F2#LZ2-3?^QB`~ruZ^=Zm=$7Jesh0
z(O<vV=A@hR3I8lN*?uNQV6h%azZq{|Q6UHpv-@1(o87cu-~AY_I!XGPGYTxjpzJkP
zCfDM2?|KbE!#_d!l`~={sXnx|_YGA)KY!T$5c=P5Q~OB?<iVAc4{o%@!A##}Hq<__
zy5#x4i7TzK_-V*hQPCKM8Jin_#lAWj!QRoDf_8T0fU2k`LCp=<9QB>Rao@dthb-<^
zGjq$ex0kKDcP#87x~(#m<9OOk^Ep0>dGpfmZ4U1#M3)>WRaLID4L@8k!MVN)pBAd6
zx33F5$VnGw$_g&}<bZ4VT$Nbr{j8zn;MzpW2{UMD95=P=6=UNeY&`DoxwkInP@RBW
zRX(Azb!IRg-n(s1Clz%{=T!6_F*B(1C#MF&V`({L;>!L^J|!!4heI##H$MsLVmSWk
z!_TJ>@1BmjnaHVKZG0C9H?fp=6UvA5oScmSOx#BebxC(y`PLKJ$-kM+NQb)=Rjt2;
zNLI<?x%6^YPv+VjSo_OgR?kF@(#^&OL}v20M%2*2birW4`~r0mKkdUvmyf}F-q~9J
zh-%Sm_Xn~Z(9tia@xg_uX?xj~Nv|WhmT!{|!O>55fjuvDKDD=_Urz>=MGAc8$PFSX
zl8~#epE<DckB1KZI1O@LDa3_&X*~d?m($)%o(2o=uz<49V7=aip>&8#X@AC)tdgb6
zrFrP`6*ps-?QM&>EiK2A4qncLPVH<KJlq2uRiex`I<pt!dDYvuvX!$j4&~{Ft=-^E
zd$Vz*mRaXkSs$%KU%A-oT;hymeqx0%%E!uVA5-7&GHq>Ht10nX3RFU2vZ0yEZfjm@
zU8DNZFpzPnx<giT5@iEruS8t#C)YE5CYQ|y)yWlzeowOB43iKD|AzNVueu3Zc&9oV
z;CyJ{Qfg*Aj`ZZ{5z^0xBAY1-Yd@H94t`ih-QEzZGWTG$v|NdvZmgK~HWrYpZ7wc7
zn19T<z}n5mt0Fh$el}rsDRtX+1dGqfJ2ei&24u-io<buT9J)+!)$Rl9m(I9w7@cKx
zJbs=M7;v{6>D?|P5+t-%qx6rvZ!Gw%WiUk)xWKjdY70DX3oG9NjmOX4XQSyn%$EN=
zP<E|0cO1oDii-_B9(mu(zmtMX8tS<Ki7}N`v5tZjP+ppOU7UMN0Mg@2)mKWU%(iQ$
zzI_xwFZ(kNt**YcYyxMcTX+=N%Kv@6XZQE!tFsnLN2h=6lj~X1eWvPICPhl;y=3rU
z?o*mN=4ls|-WFi^1LJYmLEI9kh<Q7EaFEXh7g+cA!HTQMi(r<k5TZafHLy{$i~(~+
z?5TX1sLwn5#tBE}o|5$pNR6P;=?xY+<6#rg4cWqq`~tZvbpVrCucdhD!j%0P+9r*U
z!K2wf(88P-DjHMIeWAGU>Dy!R3NPO-zE@&6H*;4Xkn9ojV}2ahsAqHPPb%<3x8b}K
z!p+~z9Cgr012@z$4JiV}DAT|xfoHcKJ5Q@{`$(u{_JpJc@6PQNJ$s%`?lc>BwE|xM
zu8~QbffzkznE;N;sk-`}mh^}r*}nM-|9STbPs{dQyEzqk<&q3^X{kb$XP32z`<`j4
zb9_EW)_dWeILSEkR}DKxS;;Pp6s>}-$|VSMOUv4xQpJF4epLZM3KcI8&QTUsA#)!g
z=@GlrbWNN~pLqpaEj!k}90oeG0~?W!SEq#W+9AxQ=cAYnL>7Ko%lBxU;%NlsJ93VG
zik$N*q5TsEQ#bAe$1eLo29|?zd*%@996CC~xda~2r2MOc9W6N*2b%s-$fYQ~Fm($0
z!3TVtU&gZ2e3~MCMA3vTKlp=Duut29U@Y0KP|l^>_1^P)mu%0A8_!SV@&na}r{w+_
zoU)i;C!a=_dI#k~dFy!M_N_(mH(!XaIeogMUbRVg&*kqS1<^xa#Djq(J8_*m!>vEl
z%Oc%$-5Gly&lSS7-+-y##394O%~8f<VDBC#Kx+|CD|7GJJWevIQEIGa1pOvfb0Z@1
z!=lJNE&nIp=WwDT=#e&Ahz$7W4y`=8I0o(#g$w?yjS#%6B)+|cpi{5O*YYUcjA}0M
zJ`hhz)_}kHrjs8Z1q4EJD$>_QD_Q3Js7>NA*xDR(dCYvxNFV<5u!3_l#Zt*^Ed7%V
zRcl3LWC1cRJU!p$vkGuUS1;-G9`TCIn0WN$VvotX@pua5c2PzvFdEX*^9|$j=DB5x
zrr^Tv)D{IXzW{z{mo&+^?h%Kg``FvtTk8D7Ttw|^SbW#kEt#^E++!@{muy2`ef9Lt
zrIvpfcB1uwGXw#XQ(LmZgLM8CQ}M5*B{+hpcC?7D4kg=<=EY6c_XG1c{#}NK*`0eE
zjxsBaK<}Vtj-?vwAJP$2jtcF@A9EN-kAsN8BAxp;cC7W4ITKo6+67lsus-0>FfCva
zFUuv!q4Ec+2@rhuliCMpkV%TTzd8sSJL2b^@kk0+n;o*goz;L%D{w7^R8&ZVJSUWf
zhlYR5&H#gW;}#~dW4R7!muj5&QNVRFASXV-y!+%g%~TvZP577JN=fzI=ax)roT|Vs
zDH+;Rg?olabna4{I3IJvJZ~>_-e>?7iFizXPs5)+`k1e}pyRh=8AU|}(93vJPmbs7
znfwldNY@}T8<(@VFo3F>avl-WRpsvEFJ+_V{<eIJsFpMXj(fV3Dd-E0YA|+OKJw-Q
z2D%UOnY#Dr3e@hl7MH`L9zUGCi)$R2sek)5o!L9Bn9<_D8!2%GJVZf<@TA7j@|*zd
z+Uh(0FQzewbo&m^R;+<?Q-Tqbxs8X>m<RE`!{-iPicD2)_KT=Ll`v<|*3I~*-Y$j0
z1#UhP<=>noV!~!4w0ssm*r&DD02Kl3KD5mi64f6a`NXy~CTN3rdOwpXc@aoKCiT`2
zjePx4kaM%*UKX}L|K2(J&swPuuixv18OO~^ppfUF-n+W%LUj}09PWOuIJq7Tv9Dh6
z>EQY9dcmO;Xr3T?)JoAB9Rl}#`0ajZ3D|iU74$$kJzppP4g{OP&vA>$Mes#|piy9k
zcM6<}eC!7RuP6xhpcQam#cS@I+Z|YGcoAEaKN#gF5s-ekzp}i%Y#5HXN8RIzAw{p&
zUGEf7G!5RCB?5={NaLpV)7vAGvOl83VK3SdvRp6@vx1I-DKAzQa&Nci3-<c;-R-Yd
z?~oRIv2HDc;`9GyNu=~?A-K&*Oq8{hW+>{@JqHU|oWR`L)P#ZE-q&^>yiE(Y+19vI
z*X)I?*1}ZG<L74hI^Ivs4$oZnpQP;loC>6|_*Iy!^F#FsIgqJxkhkpHvKb*CwQq6H
zDJ5PU06f_csbACs{^i@T_4+(R-^6ON+YeyMuD59ru%A+TTXS2yF>r>N54SRuJFFZ}
zW!H#>tG896ycSMGox0L;pydZ?$D$P#D@xZ5>{_M|Kd<gm5Vc48gXq~TU8q|kQn?rh
zYJ7%97F?9RJuNEZ2L=ObAq=ncY;(-?GLAb6GD6sw3gN(0is?fk$Cydi_rS017B}km
zONNTKC3n1sW&UUm&({OlDyE{p3tOi^qabKjvC?#y%>9hdeRFB_;LTq#KOFjL(8`9#
zU{cV95k8M`%l95h{<$40lZL1C%SSzPHu1kz4NjCMB(6kA0E2hu1PAKt>5a{X)u-xD
z(B(ylp3MVh%-FGwQukaFb8r4EV-TR!yoL$U>Zb0T629syKOa=RG6MW6`0tqyL3`45
z2@$o1+x}un^(Uyvai(AK8M}xKR$r$!?PS-z^bgB}?s;Oq?H3#unQczns-s8d1vD5z
zQ`hBU2hG9`83eaFL5zfGFFT~v_%q3$lm1$K+#Sxc^F<`9hC^)JmxhHLygJ{16~a)G
z7ig5%_NgrVZ{Yhb^Dv$~$I_u>tD2m%VmBqs8f@g^kVb~>ccdW~gH@lwTmP}2i1ykJ
zL{^7qezMVS&ZWLw90ckmPtb^LVuUMQbhC)2*Z2A6GjcnS5_s8<i#4=5m#VdKRbTBy
zh$!X&$v{;x9&V0Y?A_{BJSa<gE4D8{95B00KOgU$w?KTnsx%Y3oH>@W6l!4vyO3ug
zPZvnd%l9(oi(7UXHYSQ|&v>RJi`UO)OS_f?Y&Q<Dv|avC<raP$Dp+0YBV9yks}99H
zzy)adQFA0JJ{&S1Sm-4b>$z`ocT>h^BUgEp3O~;Z{O}EHdv$rJ*CSg}brmnOBpyA9
zTpvJ-7#Wmb{I{?8g8DS|*e<EYVp)}YCLhtP;RlL*l$oreMai^vRGjEA6Z^G=E!j*l
zW@?hQxIBR`v1@NAWXo?N>NTcqfef)|p2g@1j~a}eG+Z-TH%Y2#;61!KalV=$BY09c
zneMz=QNVFCVG-XQ#g)1@;^p0UxQ-bJ`6b6kKIH_NXQ=IMspD}iOl<zQ3gd4sZe8((
zF|IB>-L=>cBH6hinwM5`(@vc6#lcdkPk7bQ2NHT8mK2lP!3eYAJOmwA#w$c~ou5qP
zS19M5$3UL`F1c)-g8PYta<#;jQVkLHLcxs_)Xnt}P;f}gaifI(%3UY^muL`Xcx#{C
z=Dh@>>_Ers<!_|e@>zFp2xz3~q9uT-9%SC6_!Rvzz-*0w9%W7mrgXl8?MhI`ANuh5
z9zMRkqpe5WggO;pP_pcM*uWC_iv5egYKe4mIUlZQ5G=pEbS)5I)PIDbpO)cKdwZnm
zwI^>84ELig#CI%|<#6HxqWo-9qLgPno4#w@O;0LADq^Yqcq(TC@dnf3Q!AU@$KTi$
zWQu<xUSMhhHiw4gLajyU4rD41Ezy}*Hs@D^8nm@IZ#b8VI4LplChV|0c+_JDrcJ0#
zLh{mT^BgpAs*m~tJxk>T5+fBbPq!|=XJcvc`{}BbjBVwt!<c2hKI5t{RpDu+JRLa}
zp3v_<R3m8;_GTR!{crm#BGtoZ*HQgLEBJ1E{Gsj>xeu?jDi}sE9yDfK@5ItD;&R5n
zenhAT-n{uMEWdsyF<!7&Grt_p0n7Y>$uGm`44>VbnIEgkO1YYFOrNDfoJ(W%cNrPV
zToc}segOvOKitfB#6g5l|9X?)b|?uho+CCjek6OJxq(%4J9Derf-Yhuty4$LV>U(>
z=)XkNwW1kPU%Xt!1CGi(VjWOe(eX7XU+WZGW{ZX=8$9YdfH${~HOFT<HV1j?@UFDf
zWEshydyN8u56(FC$9tbuy2t%544M4jK+Y)b1(V*|lStV2z1qt#(;Y8_v6qddmo3=Z
z)AkYo9!N?_i%H6gNlEETJ^)KfgCEG=|5uSDzcTv%{~@@#**Mzy|33steJKU7j67II
z;r}4qa~!yPiE#7Z4o}?dynHP^Z2?L)ZdSH@ny!}iwvTNsZTvlYZ2v{O0GbFL)iUMh
GVgCcNEMPqV

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/halo_x.png b/packages/SystemUI/res/drawable-hdpi/halo_x.png
new file mode 100644
index 0000000000000000000000000000000000000000..932ba92fc7474ffcd0948185b65e25af06191e06
GIT binary patch
literal 1378
zcmeAS@N?(olHy`uVBq!ia0vp^RUpj43?$v#w_gKNEa{HEjtmSN`?>!lvI6-E$sR$z
zKs9O%3=J&|48MRv4KElNN(~qoUL`OvSj}Ky5HFasE6|34fpLF;Plzi}!T(V(WJ7={
z@b6Jz6iz7#@(X5Q5b+4|6JxRp3{d8%e)evLfb-=KyR{bl`PRr|cg;a*&A+$VEV@S?
zX&-(Sw&!(>$(eh;jPlF>=CixqxWNDGd+Xzq>U?d#Co!kJT%}O*nXCTGG>Oy~dsRDr
ztUsnd@5*f6_gUMXbf1fsTU*QN;xn^3(y{Mn+(Id~@~s*lHz|ISP1vE?bJkpVitAmO
z^D65KSS1Z^AK)(UXnzZIA7hfYy9?ugCf$2L_B&4($B>MBZ?D}9z8oNN?BPC9-K`27
z9gYIJA+HZ9i6kuziAr9xC}FL36r=f-9go7w9YX|I#rN6Y*uod}s`v33OXG8U&WEar
z|2#W=&YUBU6_wy%QP78VTG4yiw9o%M^*5XOfPLJj^_NAbzFxKJx_J77)hpND4p?u;
z``&GFVz6@8Ig_iWo~3E{?_R1K-K@KIVZ36_ZN0?({*^l}+}api_BJk0@q*f0*{W0T
z?#!)Tvf8@oP@(_&o14s6Er0V(>Gv;{uzB@6UaaqXFQ0KG^xXQFn_5)(4=}$@Xs%rm
zAAd7<IiEZypPcKL8xss~EUwF4pTRHhFRgB*?tk*7an<R(+g8%{=94CT7B^}C{MP51
z*v=bEs-M+J-F>UHIQiFUxe_(s;A8qrOSU&2NZncVb(V^nQ`PMQU!~oCEh}E_zbh}h
zZu_3{o*#D&m%M9LEsIZ=zIT$n?AqT9<u3&>lfK@%)DS$=Ox{-S%|rj9(obJzuG=Yi
z)^@tMe*LuvPvTCV$hOUGxfgQs%9kSUYtgsQrIjq1IE&--ncer3AN^&ww#!_Z&%C)<
zNc)~$WB=Z?ssll_=Nq3@dj9aPYqPKA<I~ky<yS8`clJw-yEY%UzP<fj>T2fv%}@S(
z<nQn}`eD+mm7N`M@Xy<xAvioxYPR8YA7C<2Epd$~Nl7e8wMs5Z1yT$~28PDE24=d3
zh9L$<RtCmaMrPU|hQari@KY!na`RI%(<%`f3_=VotxPPeOe`T9v@$Ph0yRj2YzWRz
rD=AMbN@Z|N$xljE@XSq2PYp^<OsOn9nF=iU7#KWV{an^LB{Ts5j>t`g

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/ic_launcher_clear_active_holo.png b/packages/SystemUI/res/drawable-hdpi/ic_launcher_clear_active_holo.png
new file mode 100644
index 0000000000000000000000000000000000000000..cdd0052b31fea7837e58fe26d2251fc78f0f6e6f
GIT binary patch
literal 1181
zcmeAS@N?(olHy`uVBq!ia0vp^1|ZDA3?vioaBgK_V2ls&32_B-|8L#8!rc7-|Nm#B
zqyN{`9Ey%^*VSEOW>#%%{QvOb|6X45tgIr;%>OrS5@2Hbzhj32D{G^e*na~9B{sI>
z%E~8|mBm?D{->t?ud4cAUvDTNFyGYFKtN!dt81}<0MPs``uacwvS`VYX=Y|X>wxT9
zDXIH1GMfzy{?DF0)y#~Wkr61^D=d6RTKfN-IY1k^z#=^&B2^+H;>;jtX9@_2F*9cf
z2>hQrw@O?4|K!O)!R7k;cV%Q^d3mK-SlWezZb?ZkwzK<hWCWC&q@r?5T6!kX#`g9t
z1_pOzWNu4KHwp>$iiiMZC7GFl#-{W0&oDLpKYe<Fj7%X9570f_OiVq(!a#c!Sy_R~
zc$k<X`1pW=K=<Ve3dRWt@G&s~#r=7Bz8M+4w6J)psrgh__mQ03GhN-sa&iwfH15mF
z-d9$B0p!ZdAKpIoI8b#~NswPKkj4s_7#StvB^Vi{mn;=!WMpKm{Jor!ktg`nZ$>8R
zm@`b$u}soHC5+-L|1!y({KLqkzyB{I<MO|ME}qGdlL5&vF5@|Mnn@~tX}lB@qog(y
zQ}T(4T0pB9lf2zsm<4%!J^?wL1s;*bK-vS0-A-oP0TtZxba4#vIR17@c<><y5x4cn
zniyRV=w%s{hz4{8ZoDw%o`}wZBzF;kumAhIl}@Tn{P2SLzOzyB_c<ruyfbHf@w9#^
z|F8647dP)VWME|8++6JZ;;c0PS>AJeAC8~pIsI%aw{o{bQM-yxpH9Z})Wc43`&?dX
zo!)ZqfT@SUi<eKk`l2Rrvn)ROC#iDlCGFK~91p$X%B|hHXNIraL-lJp-&Qe8zRqR-
z_`0J!<n1=oiNUuDcHNnA@!4Iy=WP?h1?Ks-WpA+A{8CZGDOqIOw#ek1o~PTlUs&WZ
zWy9y}1#|zu`9Ax;qqjn0MS1z&Nj7P3-j*IL?*02Wuj1MYS(z)l9`5HY*;RV~_U!e2
z=Yl8YOZ{UI&S`P#RS^E*{dvXlcK3%Ts!e{$amvefU6nd-apY0SBjuYJD)vGpHf?OO
zmtQ%rn&)>tI6~O^Q(u<a?6V(s-JV!(eEfJ%^rZ(M)OX(LT;iDY_sA}9ua7VGS?m=u
z=QuGxsrIqN^2&|BEtuo%E!m<(T<ZK{Km59Brnlm=eVy^1x@|o`iZ%M<=S!{McV_O;
zv+v&4bV4&Wc6wgk`*$Dfv>yI@_ib58t?HA|SMA4_AK%n=J$>o2o@4x3Q!mU=P@BIz
zVV3>8ww2F4lbEW0#{XoR;M28wY4mSLV05dNxJHzuB$lLFB^RXvDF!10LqlB<G6*p=
zvobKZGP2Y)u&^>Pa29!f2Sr0}eoAIqCAtPPD^mlA2B&KkQ-B&IK{f>Er<If^7Ns&c
jrsOB3DtP85rl$s_CZ<#to=mj?Dq`?-^>bP0l+XkKBp$iD

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/ic_launcher_clear_normal_holo.png b/packages/SystemUI/res/drawable-hdpi/ic_launcher_clear_normal_holo.png
new file mode 100644
index 0000000000000000000000000000000000000000..84549ff946a7d4b467343faf19281f09d030a988
GIT binary patch
literal 1003
zcmeAS@N?(olHy`uVBq!ia0vp^1|ZDA0wn)(8}a}trX+877l!}s{b%+Ad7K3vk;OpT
z1B~5HX4^3^FmrgiIEF+Veml+DTRBjo?Y^;i@yr>?GWr6h36mQ%0v9i6)i8|EFiTRL
z;q+#D>tDkp<&H<OE=OE)S@c^u%$iRBW8~f*82&g*?{lu8xcNz+w6e*0pG6g0^5;E&
z!t>l#K47I+sMqo|$B499I}UJMUUv7gf{uZ2Oj=8%_78uCsw07tIX--y37=heKW7vZ
zI-as2aHsnjyWA*KA(>j<<CFLHZW5Z(upu#B!XaSN)O*JspWMf0k)^`@Lt}OEf|qH1
zFRJA3<=s<l<b7Gj$GFD()w2(A=Y{W{S-A3?VCu3aS<X-2dfcX{?TT^nKH)I&XuCy}
zo_MFm+Kb<Kp2&XwFCY>lBdad$5_KtJV)yk)F6z=R3O+7K*yn!cSwM|M$9rjQu8$vU
zc{J>1Ge3)d!sK!;)V?j*P)Rp*#fihqJCY1}R@a?V+@-T8^~TNJN<k}LIQGlgO*(q}
z?DhG&(#<c-0$x16E3@dV*1dp-+&lknis#$;P+Ks64aX|StvVI8M~@2Kx=^+;L~PH#
zM+tuu_U8PEIa)Wz<Fr7k{rAVI2mgnKeEwzDvtCv(GgH@hOIgduU)!?0D=sg7tD13Y
z_GeChCn*MI<`xsVIsT`lP4uVk_*d6Z>J=-q_PKU_-o>9>QM)Uavs{bksxx?gCGC<+
z_ww%LH}mD)^FPFYbY@++p}a$5QFZ$-$xtIZvBMqePdF2gXs~%7b-&WE`C8;^wl7An
z){C%J?4Rx2lp@kRO;nJ<tuylIs-DSWg4#dq80H3*PjtA(|2glTX6k%1-To_Ye(m7-
zYNYP}v2LT;Zkw=U(=@~0H@wd}D6xM1j;Mz9_Y6~Wb8c42M|Y{Ft!ug@l^ZD=Ez<XG
zbLgVOu`O2_%zI3tzrEvAsM+CNvaPGkH9bf0bN!BHg%pi{p?|)mety38%irUheXB3`
zZsE!CSn?#rsI)})Zp}TPJDmF4SN>Vow6)NtOK<s_JLxt_MiVPGX0LY@x_mB<^=RZ$
zkdW5LKZlI_pRK=nPGQBTmc4#$3G=?2u`TqQw_&vr%jsnArCML-U)A?~pqzO=_KG4f
zbEuZMMwFx^mZVxG7o`Fz1|tJQLtPLu2r)FXGBCF?veY%Oure@k7I}ULMMG|WN@iLm
zx&|{VQv-+wr)w2cfEpx0HU#IVm6RtIr7}3C<R_&nc;+Uirv{}arc@T5Otk?jV(@hJ
Kb6Mw<&;$U)dai*0

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/ic_notify_halo_normal.png b/packages/SystemUI/res/drawable-hdpi/ic_notify_halo_normal.png
new file mode 100755
index 0000000000000000000000000000000000000000..f9a81405ff7905296c58f654e15d5db975bbdf1c
GIT binary patch
literal 2498
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
M07*qoM6N<$f;3x(@&Et;

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-hdpi/ic_notify_halo_pressed.png b/packages/SystemUI/res/drawable-hdpi/ic_notify_halo_pressed.png
new file mode 100755
index 0000000000000000000000000000000000000000..206c3cf95cdf13d9992f6c77388a200367bdf51a
GIT binary patch
literal 2413
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_back_left.png b/packages/SystemUI/res/drawable-mdpi/halo_back_left.png
new file mode 100644
index 0000000000000000000000000000000000000000..7b23a20ff620bb22402445e0d239d6ab8e5d3058
GIT binary patch
literal 1994
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
I$U*7<27R<WlK=n!

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_back_right.png b/packages/SystemUI/res/drawable-mdpi/halo_back_right.png
new file mode 100644
index 0000000000000000000000000000000000000000..a3868b94c8788c962cc1c9aadfedce3c97057b67
GIT binary patch
literal 1972
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_bg.png b/packages/SystemUI/res/drawable-mdpi/halo_bg.png
new file mode 100644
index 0000000000000000000000000000000000000000..9e2a2f18736b02b9a3950ed8171faaa5f68fae8a
GIT binary patch
literal 1768
zcma)7dpOkD8~={c%rHh~%$UJQG1J2g=0Yx$!7x^{W)O0>7&GK<G%6;{$StkNR!SaQ
z)<!G}p|B;{qK#aVTUHlc)Gk}wFWYAQPLDtK+5h%D?>X;#&ij5o@8|q+o^!;<%LAin
zpb0?`MzD+T3%v02M8UzjA~>%PoO&!z#Dk#ArRYylo4|f+^e$f!1Z8fAAY~o|eFR6!
zmk^ZBgrKEJ2;!WEAYy9OwcU;o1S{|n`n!XI|2|-9a5RyOr|&S>;b!FMxy9KFU^Q@h
zWX>)|REFKYGRH%ePO9_Hd9^P27hDSJd4=^G<R~nG@@2T4tc08MtxJ9#ujr!dk;V<9
zc!q--9My^ytK{ZX^9t%*iyAgkyn=chm0^=u;GA0nAPB9^jA#Ym2L)T4y>}|k@Cq+(
zXn?`hoe$Rn6eB8ALziTib_`&#rgTn51+S<9Z_Wk~ycrv7YT>A;1hEE=2vT-wr3|sc
z*u@7J9DxKeAjF!`Z4wJvu_|Cd*e0|#P=(OarU)ab!U(|ZdIZR8Kwz-oj%1F2A<nel
zR|Z<!%a1!AI*TS60VN=1VCx1n*vre1+E{QYswfgD0Rq6P23O~1SEF?B6wj{+bldgy
z^`n7W0ic;m?(5|T!PF3%7#$p*ptotWt~$ZM*n~pWCQ-Pd=_TiyJA2?-M0!B}rP~v8
zvvd@huj(9|neHTeo*X1PmHkYW-J~E1)stLOU^h8o$Y|8aFnyd9AIPOpiB5fFPd7f6
zs3clg1dNT7E&<91VfzivHJNmUlDaGg$#)4VBHb8qSG*aBfr&jm_$u7B=D#5benY_L
z`3LnkoqiE9<3hTviz-9k;$q!@PzsDtw4%mj*+lr2kfzB!O%En#UVR+@YmU0rOkCcr
zaCa(Wj9lw}@uw_IH8A@oxBnIHIAz=Dq8zo~a3naSCv@db&51Vtv}u><-Kt678N{}%
z?^Rys?`V~F?zF+-7N3-lwZ1Jbe%m@$E)Je3s_9QAy=bPGQ3CfooXC8A=shMo$E~+z
zI5gBRoT^(L^vX6bUQ6f1)E^BFB+X8<;s%C$oJL{py_U1>%kUD0Vrt36IVoYeNKT8l
zF}NEtTHhewpWfbyt!jL~DIy8>CV%RYu6KRBwi(?20l%lt@Tt#@0A`5Sr?c~th@5QS
z%7?#Hyct+uve0qp{`#H)iA>8IOLaS(a!J;@<}k^ODVg~C*u~4l3XUzuDL1Zvr0xE#
zXD49zK9R`l+>5<a9w#cRS$EWCewJ%4ewZi;ZkxYazgv%=Jp7m5c(tStk->k5KDs@~
zB{b|bvhv;T{1q7L`B<xdx6SOSiiH7}<o6v<OcSI(QP6v>>8tl9tJYA8U12*aZ&z6e
zn_PRZwtg_TKQdnu5(!I^V-nF4DQ@BQ;pl*%%TrSeoUW6DW)T|RhRc@vhzpn`rRB+2
z<f+F|Z6hY=y;<hWFBswTux}L~MX~JOnzhi#5;yB6l%ZZ{BI&f=FY5b>Q9`A+G42!w
zK8~A>EOqIbJ6>DbjW1Bebt}r-`xDYtPVO%wk7w2HK^`<WCi@=L$lf9vy5&7@D!9$d
zFCZK>?~4|^U8xeC@_8RiWAu&O*C>}5HV4TZg^ScxeJ6tK(UY>Qxbt}f!#|dv<Nf*F
zzM(SS{o%(iQ&UsJDketzm#h|6pNHXSYhUQ++)=jR1y<T$cD&ii{o!xi&?z?@ZMmj!
z%?zo7{Jmvmy#EuS4A#NCkjxfARv6>PF=b6}WI(&HQ+NJlpk+HV>pN?1?#knXII-NG
z&FRP~j}GnjIW`q$_N-yHu4gHGZL)=PNMm{TS2vA%KT?G=hm#uqx8Qw&8#&rl%Pv93
zUF;xT@vois9JNv87*}$eFe2^XWVdgolg!2u!3mEZlCJ!gSg85>>G1Wsr`oeTp)s~M
z#)F^oBX)FYg>&}6LFvwbHlx*a^Cy{em+-Q1mtv-QxfWheFg0YCnE!p^;Op&a^^VU~
z&(cX(S+oq<X7Svwk6=Zz*lF>cevu4$ptE4W9(NUaX6271vgD@K_3LQK&3BD{ZR~9y
zf^PI&zoqtkv3CdTn`l~7ykksF%doY%$2zh*kfk{s;Wq&uHdXE(B$q_VrJU$ADR2;*
z$+EU&+FG(${!BK9Y0Y8V(mw~x4|#z@{{keXNaA8L{sA!kSq>Z<dyb9627nefY7PMU
tpF8-a#K;dsrAZ;4Bt<OUDoBcomHJAfBpI?nDfoUMNZ{_pZ+4B${XYSFy&(Vq

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_bigred.png b/packages/SystemUI/res/drawable-mdpi/halo_bigred.png
new file mode 100644
index 0000000000000000000000000000000000000000..923f79d85b65954ed5ab5218502ce92551e80023
GIT binary patch
literal 2068
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_black_x.png b/packages/SystemUI/res/drawable-mdpi/halo_black_x.png
new file mode 100644
index 0000000000000000000000000000000000000000..5b482c654a3697e445fba65a22b36ac756ecc631
GIT binary patch
literal 1602
zcmb7Edo<K(82-(eF`8j#MoeL5&A6pOW*9cJ*wna;J58C$WiVusMp9_$*iq6VLxnh7
zQ>Y}DMq!kLF7CJ7FIyd?luIg7%6>Ix&z}8rpL2fi_kPd!KF|ApfBe4F?ymMqXmvCM
zK}u`~mM2)9zkLdFATF{mtAPa(YU5%9L6w=9H69Y|$w3aDE)W#22SF!<5cCO9CtgC(
z5gG)|20#!q7lJk&DyZ|YgdmusyEDfY6#Os1U@&=kc|}D<EEbE$<CT?_kw_#Cha(b+
z6beOKTU+-#^!@?hW&WzFs$?=*M@I*oZ21luk4B?OBog2O2NJNwU@)4Rn!pAya&mIO
zL6(Dh&<?Z!4qyx!2_l#WI0F)BwY0Q=3XBILs00xJ9KqpmkN^i@2zn8|1A#z*E6B!1
zp-{jIR07Ca$b?iXmBC;L1cH*15=TczP%}C@T3J~+GBUzuvxkR=tE;PrhKAPH*OMYX
zkU#^!7*E&T5KIoGh}%fmtfmf^$0Ijw*3{8AFeFm#!_$iDJBB745Li=wLD%f+230Nh
z++{Zkg<JkcgMEEL!9X~vR`;ov7&1=&ZBFaM>6Q0m8lP2&7fcyMYQ!1M;^FR;sjOc3
zVbBQ{=w#1|l*&V8;97BPmJNs7T$UT=uTICE+QbbwTASl!yUk+<q6`jC7K@MhOZsjM
zY*jdbZ&-h=*G}oNqP$C6#9*^qlk{5MbA(|Mrgs$0#PD(DAHA1Kj(97XW#x59Qf7{;
zX?Y*G%{F2O6)8Du_TK*MEWKy1+1Id`c%P@|^7cuaUqxGxmPhjLUopSuO7DtzUKkiT
zU%QIz77xu}5o^{9;!w)=nLBSS9|i6edZX#SeM^qpm3>nvKIwK%2JOB-ZuA!U^CHsy
z{VXfzpF*&)#qy-FsS8p<_P)}s57uArH905m;Z!2>sb8VArkiOj7R))DqeSQ1L+-q7
zP}kAA8}#7dG)77em!??8cGYONHN_8O2rJY3pwFmAtD7Q{fRMmtdL}o;a+tvn4=_8J
z+y2z&!wPbKqPuLtC8!uL_a81UKpuKwVau3Ik_MOrG;|sFS3ujkGVz_XVw{Tt@`>+#
z&SQ9up|lsf>&k5UbI~48e7ViI<Hrk?S;tux4-n=3x1n3f4pHIFacP9s7g#+Wj5w7Q
zb@_53Yw>kcXK=;ECNuBB0DCh6qfNhs!W-)(`x}0->Y)>*d4)O1v$muB_`ZRcSwXGi
zQx*G_Yl|1^LaGH3mSz?hvTCTs#dD{6^&6C5g$2Aqw1wxpUG>S3mO3}XuZ;`F%dVGV
zmZeF|+;!C09+cm78aH`8i}=GEalh{t!pLu2#Gca3M33^*&ze^1`z3Z6Wp=`nem{-Q
z!J&$Qi26ZcsND_2(Eh-OCht6Wk7v{Gt{8ilu6`Z7hLI8qLn{u33HRfE-kHCUgpv?`
z!R6JgKS}-l<n#hQuTM_$$QnIjT!2ua4q?xbow9k2lXBFjDrpT9m}rIt;n<x1eihNp
zW|WB}*5@SB8YMD%7=7~zwoj7jI<qSu>E?<MyEn!ncZde(k0-{CiVPKM+~4Y9wCkM3
z8ap`ZTuElMVUbuj-<7qo(0v1XNjKG5ur^_o!D=^8x|E|p(r0DVm3;NEe~;6Pw<0G9
zDDg#F@gv#^N`*_wYnIVA^S%>jvK!NaypC37qQ%{$DlA>>#;VHns_Oo=3Y%D6mMRW5
z2<*{`OUw$rXW7nRx7>+pF+YFO$4|BLyq7NCYj8=NYCid~MQKzx@Qi!0;zpH=Lsn#f
zC(EaFB3*az{oHCv73m9h>1tT8b$bT~{E@mbw%nLtUJRcZ6wL<<WJ05x8qv&+=yVRv
zgh?}HnwT4WOK2-XueSdPBBO%CLgM}v&^UApCSyC3VIdPx!+N&@f!enYyQ4y4j`E`U
jkWFw@AfL>R<c0D*`MlsbK`S3T>=4AZb!FY!8Ib%pdiGBE

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_dismiss.png b/packages/SystemUI/res/drawable-mdpi/halo_dismiss.png
new file mode 100644
index 0000000000000000000000000000000000000000..6f07b07965e8190043d13c3104dfd1b2c7b65572
GIT binary patch
literal 1859
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
Xexfj;AbTkB&+CT64iEU7U!3^gn#$>o

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_marker_b.png b/packages/SystemUI/res/drawable-mdpi/halo_marker_b.png
new file mode 100644
index 0000000000000000000000000000000000000000..360951325b2fdf76861ca126b0825aa5adf5a56c
GIT binary patch
literal 1463
zcmY*ZX;70_6#W7LS)vt0S+wAcOGOGzK&fOvML>;KWQl+lmjnW0fItXg69%YZik$&P
zu>k@zNXw?kW(6sr*wT&(Wl;(OE@%LOs4M|e5U|JQN5?yp_ujqlo_o(d@0+B1xF1-l
zXQoFG#7f3NS1;_F@iWrV#QNwb-U@8wVCN&w1W}!-zsS;pzcJvT*Aaq<-%1e47YJej
zq2y75h^7+6_!)wriwVLwLek*rNDvxAk8hZ6NH8}ycX4rHv)Sj*pHE0gsIIP#i;Iho
zkLUCGiHV6xNl7s=F|o0+(b3U2ZrlhC4h{+m;&3<-5fSP%9*+kX!R+kp+}vDL;BvW9
zQBk-BTx}=<Lj>{A(9qP>)cpK>u~=MEQqtbuJ}@xQ+S-Z;;*pV&=qnHi&=h<C#|i@+
zXRNqF0!$<l6%`e=wY9x?@d8Cqs-U2tqoZSHW@d45acXL6aBvW}RaI3vIXP)*X#j$=
zx;|*A4KC(NPfwRfB)4zh23#(eqr%eC5^91HI+mB0gP~HXMA`ZI`N_%2p`oGP-d?Fx
z+SJrkQBiUI`gOq71_<2B%F289?#X1bzP`TU;o*gah2`bt_wU~Wi%4;CF;qg|l$4ah
z!orr8mj3>Jg+ifHsn8c`$e*5`#t3MNAl%v6*|D)PG;M5bgvbyCFM>A$f2f+3l~r0=
z`ryHX?(S|(jZ8F}o0|h$U{MeUxDyi-qobpctE;Q4xw$zrGZP#D2N|JIh)LC~pe=-g
zd+E}pyu3UxEGsL6IQ8}Qb#--EYieqsHsTOABO?Q3kdIPoIE4N0efZ#}Hn<2P0faw%
z_y8&TVo8Va<#h_Y+`X}XYMNxSCP_<+yw1X6{Te+j4U&d7Wv%(9O~y3t)g&K>Ev5$g
zE096bBpa^Z=5+G=e4edcvV7rHQ+BwgllA7$O^gf;%x(4@i^}_LbSa5uw!h%jyz=?)
z<yVr<o%CgT`<@C*$-epL?6T^qc%P|`H8b_r<G0K6%3=A)yP5I!k_2~4lCA~y0PDNL
zhK|8E)2g{C#k0TaBuOq`>S&TQbylt2w$s(~L|{a;P#DfWesrJR7b{7W)oa$7n3)=W
zrmy3;y#E9SBC!u2aP3^x(;>mxgW>AT+}06r#w0cQa!PuRv&TU{*Q=tnzv}t;cpA_m
zb+s9mA*RP2;<ViCg-optl8c9=+sn_5o8?kY^wS&S7qrv%|FN|=XvF{N-utZ_7Au6q
z4h;+722Tu*4z&%w8XtN0a%}jmT=CjswTaON4RVWfN})FErNL#-E?RYX<P=3Wo$=7p
znC<=ek)3UAO%z`_tyJpi{c!Q{A(^Ap%7*E4thd{?TkG$yci8W&t3Tb?+28a0QI{_H
z<TIzR3S*l)vvadY#k&}HGFUakMvAh>#T{Y??wsVVa^y!}n^J$j=Ce~-Kg+IFR-L}P
z{r=h6++QdZ|C{R+J-jC-4I#>F6$5uBp4{cC+MN<qZ}&t@dhG3Ft&we#IC@OfREfWp
zR_=~}^H2Jf68C(1B43_U`?_6bC9bWFDiUq@%EGEnBr;s>=T{XmsZSC3dy@#lad&tR
z_tXUzgx(@>^AiNJ1RQz*pM#CCrPA!IsrJ@18k1^Er`pkN?X5l@sHzLT(oX<kyugs4
zxc>oECe4AqV;6mggBq|sq{|Wj(~ljzc|n307N0{n2lCjQjf^l>Fvp9-3XF?<$icrU
OK``9hU2p9>llm{lHp}4v

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_marker_l.png b/packages/SystemUI/res/drawable-mdpi/halo_marker_l.png
new file mode 100644
index 0000000000000000000000000000000000000000..2fd09ae9825bd58444012f21b792d92698f98e8d
GIT binary patch
literal 1608
zcmZ`&c~FyA5Pu<|a!6D_PBn~xVr?)1w1QfS++#rq0YsDuM?lU%E(m7;u_7%X!U!S6
z0v)c3(u^&L9D|I52IVRpDtMrPTvF~(!eJLPW7|LaX1?!zZ?pS5c3(2xTpiU^^i&W+
zYR*n}6xcQ4F;c?9yM;KF2OBQL#>EDqpL0~#{T1PC5a>j4K`8zJLj21J$soj^K!`&^
zXo`lARUty!(ZWXelL#pY+`ggOLjsq}4G0K`h=_=fk55QQz~k}J(b2)d!D(q}iHV6R
zDJe-wNpW#;$;rvFv9Xz%nS4I~%9SfT9<R8#I6XbRu&^*BBqTI6G$SK}!C>U)=ZA%b
z0VapT0ko2mlFG_T$N@k&vRJH&ii)m}3x1;0>3{<)&!0bEUS59v`ZbUO2xPL^Y=J;9
zH#fJjvGMfjQ;-Llpd=<Hrm3lEZEbC7X{o%t8~{N!AOPLKz`)4J2*`j;IOgQ!OioUA
zcXu<HOb`z_kPIv`ne5)Zd-5OvwzRYW+Wh>yP$&dah`@pl^!E0Sjg5g{a4n|*d7u-J
zVP$7$PfSd7c6Ndu00-ovqN3T^+1A!phyZwLX{l5y1+Key@5;I04Xs#RU0qpODJv_3
zG_hE`xVQ*?fO0rCG&Fot@+ktU>g(&}nim!p;0QR?)zzPH{>@ceTMLCS7wB7abF;iH
zxw*N}2WX>2A^~6E4g?Pm4@0}aFGTwL`$tDdVWtlsK3rd4hg$GbRaFHPb#--s4}SCV
z@}{S!VGuAHXz$?QARxf7;2Y3Dd|O)^)Pff<4yGPGdK4ZW4t+~aO&$8Upb)rfYHDC2
zFn<^>OkaMlL?RJ%rl6nzF3E=vA2v5PK`rI$%zU_=Lu`tx2kig9FiN^)Gi@AJ<8(5^
zP*Len;aG{GB4(HC(E8PVSnS?}mGO(aG26bVY(KSK&9<x9<TH%s)G|w7K_Pkdt*1Ih
z@u0B7T2;xs{<f*=>1PGTxE*I-rtVYsnO=(2!R!v0|I<$=>YcZ`E=M{--KEF%;I2fE
zd20nN%v{ts|9&xSr~7a+cDr5o<_#m<(Z(90Noo73blEF+|HUX>yklR166sE}r3#ji
zw(3QFldP{y6y+0e4*YNe4x?vI*24B2J~ad0Fac*A?S_hQT3df{<!C1#7DD*;tq0S=
zs0xAvp|hP0)ucO+#zzi5mOMp!WBP&M&yLglJ>5M$273Af0v(ma%uCY~Q<M5S%>Bwt
zUEShBL6Pq{@qXNW-tF6w5i{@i?(w;<$vk2C;02e%8XvP!A6=eXY8;sv>FoG+=ji-m
z{SKw=DtH_9z+u&2@Txgizq{t3K02P2`TYZpTe&9uAfumX6sBaR-{N4DQ77+mpSjs=
zFn!!W|B0cn_$I;6?NY}6$DY&+l=EJGsR2BDx+lk_)>=Tjm_)M;)Yx&2=EOP^?whbp
zKnuAU=^ML^AfTN+qSdD5`vdnYi!7PK+Chs_WmlmEPeM(hX8l#+a*NFJx=*0Qk>={U
zMCM;6ik1^KZLTY-Y7_m$Y+bQ|cD;0AcfI!==G#E<lI7F<PCCfREW7YnR;x0=_@m*8
z&hH0WCC@y5jd-bbEo?)&_k{MWB>RnRUw3<RLiekoH7Q}IEk*JycCP1*;Vwtd>o?ST
z%H2D%8OLM#^3LpWw(hL{Eo7-nbmE9Xs^;QJuT5=Jzs5v+ii)%Ktmpmk0mh3aV<L7G
zA%<<rkB1z*F)%!1w*5JFkUyJl709H+hRjH0b0X;&kxZtN%&bV}R%XWzZ+(zfE_+M<
zQxM4r3JvD{Q$V7UEv+n$TUl7j3qB9+Jp=`MTMQnIV0NrOlaAc{L!;QHuJ%*|uDR(^
VQ!<IP#4Lp@<ZSP1cjq)M?QeS__zD03

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_marker_r.png b/packages/SystemUI/res/drawable-mdpi/halo_marker_r.png
new file mode 100644
index 0000000000000000000000000000000000000000..b9226fbffb083d18f324617024afcf0d9eede776
GIT binary patch
literal 1606
zcmZ`&do+}37=Oo%-4Vtjgrt@h)l9?GY%I0o7TdC7qIOps20O?wH<w}DVp*+mWY&H5
zNaa$-q&AbHBgfW3Irb=_(7Hq_jce}v$T{uqAN!v3eee4`-}C!Dzvp@0FT=zAu=*y0
zO$Z@%R~JW5*f+ytipRpck@zwPHe4{xjfT)wk?OLaGT7S#Ts++niv0|s#4`vjf-7+h
zAs!i_m!}Z2$wx>pqPYI3Eka6#9$(X)ARsI(%-`Ri&*w)(L=XrBfj|%&8=IV*92683
z7Z(>FAD@tr5FH&Y6bdskGNPiQ5)%{C($ZpLVv352Qc_a#^Yep)gPBYwi^WP!O$`YN
z$<56LEcnaI%S%d1fRM-I0e@g%Aeax|uS=IMaX1|K1SrTgFfcGXJKNLK0~vuC7N}}(
zZ(mtidHeQlVPPSc%iRzLsIs!MnVFfTrKQ`qZ%0N(f<lOg)I&o<-QC@g3rIjMo6YX%
z=olX#7l}mR-0)n#etmIq5pn^~Ms>hkTwJVBD1flBu@TsyMyPaTWTdmR6M6z3fP*#=
z2@q%wP(j|dwzjdcv8=2t_zLEoJ9j20CkqM+fO#WVO-&8tnwy&|EiDBx=g*&?pPye?
zSb(;G31QHU>FMd(+FF2v`9X$UE(Z^o8wVh%tE&TZYHAAff8eRCtOTCw>gs=I0fh|>
z4bU{04se2aD515r6*>v6$j;6NwNNrNYH)B6biycyhljhmx*!b118{kH`R?7jz$}x=
zKy5`u1q@<hVj?Fe2e8m;m=|DsdwbywLxCy)($v%hnt?DhG_<9q1?qyTffEAy-mj#j
zBxoJn0hlIS0T@kHRTbP5u~-ZZkw_$fg=@C9wzj&u3TjPEiu2%h_HjMky<q?Uh10XL
z)W>6#O;|#EZLG3M$w<Bh9=k1lxzAk_gVFJQF)uK}s@XM{@A>#6^P-0i>Pm*3*_WF!
z7_DP}EeMrV58W#^Qzl)hqu_Bn#SiRNw<SIMMgz0u^vuKwt&?vQ{yJJdqv2aL=|gio
zeJ{SjJl|&|!uRzQLpNml)wkMM;o#9vaHi*0I~>)BRrUMrnoG@(_AjRBhfn*7|2$0C
zWZfVo<GmM>jj@Kp=X9KLu7s$9GY(C3#_C#93^0PTr3$DG<A3C^V_yMIcl{SviEuf=
zL5R@2{$TF0Di{z@=;}zLn|B19g2l)YpY!pcdj<u4iFCbnj_v2EyAi2;QySs4k*{4m
z*1?@>N~4+tXnRpOsz*qsD`DP`sW<p@gsi8wcv|>Lv*5fwY4{skm#-Gy+1fU|iC%g)
z_36Zm>1hqTTCED<xwEdCx~eGsEIWPFL2Gzal<~_g?ccKRn<X;rL;}yL*STH$XjI0^
zxPC#@wOY;@4>ex<gUt55=9`^0_v|8B5O>!M+UuxEuT)7ZiS{=nqFd6&9kQz`ZnB#f
zf3I$6)^N(Mxq0o8^s=FstX$7QcJYza$X6z<ITWE(@6@Di<|eVyamxPULUiwpJ|$RD
zihsz@*S3!8kE1e-BljMc|ES2h*yfmx>sff3S0is=i+8Y1BQyTEa*`u>UGI31#1QOx
z%z7fX=+<nxKlb3e8}7Z{nOh^jkIT^S)0=#9Q?-X3e)XAPuD`!-4Qb?TFA|S7r91p2
z+B)K3Y8Xi>3%K{W<bZzKD_50Oukwzu61ymgk!#(BuGGvt(hn;9VdtND%!13^(gArT
zH&bsHLKM}6;=zMGzryHta-EKI8GhVAn*eqoY{-giNg<M{L`zFL*~*4Yv9Y4=UO$lM
z&-k?d2XLCjU<Sqf10d5at!?%lu-Rw50ocXtv;cs?dIm365I4$?9f&;qnBiQKyAypo
ZpF-MCvLusd*rgDKT%Ft<rS_+i{|3Ch`6d7W

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_marker_t.png b/packages/SystemUI/res/drawable-mdpi/halo_marker_t.png
new file mode 100644
index 0000000000000000000000000000000000000000..aa8162c91b2845d613a69bff3e5798af4af818b6
GIT binary patch
literal 1464
zcmY*Z2~d+q6yA_TBS%#{2p-6Iv{H?e0NN(XbbwGr1%U*V4q6iO!zjUUB!O^bAc__b
zqS$n}9YBqO2-qm-01gP#3P^;a2x_Gq76{0Zgm4A=oQ%_PXR^ER?f1R+y|?=(&BuGc
zmH9ezgpifz0j3|UTj95wgonBPhF~cygfLexSA;6$7V{h;*!Cd@{Jao~{~Dp>vk1+C
zD|rwh5f!1~V1yW%2-!sDKK9**keS%$FxvwFadB}XktiV{K`NCdCML$m$Cs3pgoTAk
zB$A}0r0D4A*x1;LiV8bBJ9l??E|&{16B15g01W6cF)@II5%qbPOz^`g!~`U;APblP
ziHwW{^U9SgIXO861qFBR+)=4iRaI4$m6b5xzkgq;RDwS%D=R%c9aI4xSf*%TLL86{
zVTD2=_(4NPM#k;ix9jWcJ32agdU}S2hQ`Oor>3T6W@ct*XXobTOf#6^92*-O92|WA
z{(W0pTWxJ^QBjdxE(c){4I+!hV%Vpoq=10By1MS}ZjDA`Fc{|N=Z!|ADb(cT<ix~;
zR;vX+MAqx|kg>C~v%0!EJ3AW`f>bE5xVZSun>PS6aUnaX>hJFdWK&a9O-)T{X=!0$
zVeaRVmzM`-Sy|bWCr_H2o4dNY1_lNo(Za$45W&24>lP@?&(Bw@)jFLHDs5?LDK9UF
zMx8r%4)jB#p!1L&26P4rNlQzE@X%hM^!4=ttF^Ti5<!Py1M(Uh8^M&xWI%+whMNNY
zAl`I?si~=u0(u2tpePgyC=fJ+hliV92q0kt>G*s;1c6YQnVF%Xp%{jN7&wA!5(orf
zf)ff^TwKieS2)1Sdm;4mX2JU9z?tFjM3Uu-Rcp!XY}Z&Xw;-9}NnhD*-_7*>i5Dpn
zi%)X{kGMH~vvIZ6QXFoX^(N|m&Y6P8>YkBFy}>Xwp?UYbGFN)sedkI%jznS0?)^17
zyD+02==<<dH{7aB@OD_W?#KMz8Kd^^hT?0|Q^$|8Sw~Mqq$uwG(Yx?A)6Lc?xvxfX
z+Si4$m2ACo+pZt{V{)DjN@=w4U!?(bTMGi7uztJCFL?sTwVO7rH^(ipTw}Loiw&MY
zz~hKS!sbg2E1)18_t1W3o1|?KzF(ZLC)1U^T^$lko=v`*mgV8&Ln0A~fnBfZF9rew
zQ$3iC4coTfyn*p}yqg34YgQ|mic~s1(B8Z%ljzTW+266-`GHC#)a$G)^_MSs9e&<I
z*;#rwg2{g*A(Ka#BO5p5<sJ`u_ts@!O?6VDG0~W0W_CvA?)J2P%VtVZLtzM+TiV;Z
z%KBOcYgf==uR}*#|0Kxnj^wI3F50w5YbPztFJ1_-J$SIWX~(XB0RPU8S1-SF-m|+>
z<y`sjL99?LGED1E=tecysaHAe{SFQ;ETz|VTFfhcGd&>YUtC>K34K^=volB)_pBXL
zuzo8GKKAI8KKp^@Lz%og`1h!5R2z#Gkx|RcFYq6B^^{|phvTDr#UHt^Yr@8AdyR!n
zOXKLiXHqZECBLY1KQG_lBF_D%;TcP*E_V!B{&VODC#5=n?-8oqG<ll1gh2_$Be^}l
zw#za;9Xh>D=y6QQ;|MWENHhiua-`CnDAYX^8jVeLWKf+Lj(c`|+E5K=k2ZZlh!F5j
zhD!b?P}wv(!})uLGu=e^_GH_qcWV1714|GpjO9dQ$dxDHV)mX9oG{D}<M1R=&oKBq
OMaa{`n|aSISoR;7c*;Wn

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_number.9.png b/packages/SystemUI/res/drawable-mdpi/halo_number.9.png
new file mode 100644
index 0000000000000000000000000000000000000000..a4164157d48e885af1bb3272485eac7fddaa3359
GIT binary patch
literal 194
zcmeAS@N?(olHy`uVBq!ia0vp^q9Dw{1|(OCFP#RYIz3$+Ln>}1Cn(7MX-`_js4c+F
zv{6OCdt#&N!e5aSc|}{iycjl0NJcQNiWj&UFu_;ow5)7%|L<Sl<UfCXt0>ldrTL2^
z?=%-Pk(6!;kBe_FT=>7;<AB0fh1vjd??lrtVx4XGq)xT{laB&oqc)=+DX-f{{Lk+3
ppB&Vs_Egi?tIp}GkX{eaT|T@<$MhEPt^zuW!PC{xWt~$(69Do*MfU&z

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_pulse1.png b/packages/SystemUI/res/drawable-mdpi/halo_pulse1.png
new file mode 100644
index 0000000000000000000000000000000000000000..0cb10bc985c023b24c67193e2cb9da4bcee82482
GIT binary patch
literal 3701
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/halo_x.png b/packages/SystemUI/res/drawable-mdpi/halo_x.png
new file mode 100644
index 0000000000000000000000000000000000000000..f1570abf6a7fd5607122a70dacd2821869580831
GIT binary patch
literal 1033
zcmeAS@N?(olHy`uVBq!ia0vp^!63}R3?#4QoHhbdEa{HEjtmSN`?>!lvI6-E$sR$z
z3=CCj3=9n|3=F@3LJcn%7)lKo7+xhXFj&oCU=S~uvn$Ysfq^kBz$e5NsNnx7pmqot
z39nE9hHPO;kRLG082N=c*aP<T3L0!!AV2p<E2r9#*I^QCz7(*?Y<-`?toSxwbn)jh
zR^8K&y?Oh;cX8R=x@yK&_sy^U!zQN0f5%jU?eAV&wn)tQ(!-g*CTSmyUf!Uv{bTx;
z!mp*Ohmr*5b?Bda5y&^;=Zq&FTH<cgv#dnIK}mx#$=lt9@jsL9Js?}r)5S3);_%xm
z?%{_L1X>@)G)V=DOkKgTC~5kl1jcIDjpj%0RbT(V-|(VL-|u`eop+m0KeH{KbS6Ve
z5C{TaHh7m$XZ%0!)IyOzYeOWa%BeGlgjQ!ynJs0rb>FV4KdRDy(iVH~UAb_j<prTF
z&Kz6YZr@^^bge|zZOP?Xe6e?J_tpw|THmr4=w<wP<Uv4?TBdvOVdcfiFMF=*PTjKj
zap3<WPeMHOGF_LaAKF~}Ss*v*;2*P;<3}C^m050>G`VK(>g?BswaLZWdf#tuFFzBj
zu>JY%@c6RjGwn5GqFy)u34CawA+)vZ^OGy{_${paV?5rd>8&@q?)kj!&YgRASKk+~
zv9Ys#eKdOdseOC2{x7ZYUUI)%@WJEH-Z{@ZJAlCJD!=e^Imu@pc9Vf2r&{6~QIe8a
zl4_M)lnSI6j0_Bobq&mP4GlvKjI0cdt&GgHK@5ZME#aq7H00)|WTsUjG#G>!T3VS{
zSeaNtG-zdB)C6jf1lbUrpH@<ySd_}(n3A8As^FQMn4TJxnwU~qcrq23KN%Q2UHx3v
IIVCg!0HQKta{vGU

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/ic_launcher_clear_active_holo.png b/packages/SystemUI/res/drawable-mdpi/ic_launcher_clear_active_holo.png
new file mode 100644
index 0000000000000000000000000000000000000000..2683beaa3b73f463f4e4d5c22b33fcaa69ec8d45
GIT binary patch
literal 949
zcmeAS@N?(olHy`uVBq!ia0vp^3LwnE3?yBabRA=0V3Z2*32_B-V`OAXR8%a5gggWU
z_!t;O7#LVJG%R>|{~tfzp`ehjqLQbg@*fD|;&N3~GNh$*3=AqIC5>cdvw`Bzo>l4V
zcUxFgDJU>9G5z=VPghX59uo3@%9JfmP8^z=OloTL+};28_O92_Id5VTCojLk($bli
z7ijMe1%)%Zy1`0H%PcH_Tp*BUVc9A!4iZ#U1ajrs*tUs_0~vFSje&xma&p@wBu?n)
z07XQYn6`+EcW7(tN=fZjRSi&7Jg=v>L0nvdm36kZ_9kOvZ$(9a0Rf=Oqw4A+%phOq
z^YgD37guFtV*~>(CMF3MmSA4q*UHMT6ct}9Dn62vdm=0QR!QllqT)LxCC0-Ien4$u
zB|(0{KpGbS8OFrH$e4aglbKQO`c(~PMy`|>*EHBuUUD#BSABJvGvNud(L;@EFVdJ8
zH5tXuFpA81ks|BJ&B&;*qjwh2SjHr8cNgAoTN1wlIh+L^k;OpT1B~5HX4?T3cze1y
zhFF|FJMnnlAqR<;`c*3zieIiiV3uI8x16Kp-tFJ}-FUWbRDRp)yyQ&ov)Qqk>5Tun
zQ;J%@mp=+Uk-8{&)fKyXhf~aT^P`rE*tW4c3y9T9I63kN?^RpWd+gD!mIuPSDs)!$
zX2iAndo1H)S-IT8`=#fj30|8vE-*>i^u=(xc|d{*Q|gK5eI;gxk2Tpb%y62RU9cx2
zVcy0keU~;TYEAd`kDD~7{=^w`kM7ndJ0$~py|zX<7VQhPzWRE()FkGJ%NH`XoqHa(
znK4uQll!f0e&35;mgVGr=@0xC_uon)=C`eN>ytOX^N&8<Q1SSi!^h)xkCHs%iY&ZN
z96O=;Mp@^XjOWiArivEt%8GfD9!Yio;a;}c`t1A9F+KavFU!$+A^oiTY1hN=$<k-C
zcFx%R(c5C*y`1>pn|j}-^*;VEt*rV($2sQTcdMWO53%2_VXs>LP;n_Rd{s+aBT7;d
zOH!?pi&B9UgOP!up)Lp+gczDx8JJrcS?U^CSQ!{Ni#)%Bq9HdwB{QuOU4xmGsR2ZT
z)3u5zKn;>08-nxGO3D+9QW+dm@{>{(JaZG%Q-e|yQz{EjrrH1%F?hQAxvX<aXaWEp
Cs7I~<

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/ic_launcher_clear_normal_holo.png b/packages/SystemUI/res/drawable-mdpi/ic_launcher_clear_normal_holo.png
new file mode 100644
index 0000000000000000000000000000000000000000..219f3e5cfd6dd591c157d0bd31df274931626a48
GIT binary patch
literal 802
zcmeAS@N?(olHy`uVBq!ia0vp^3LwnE0wix1Z>k4UOiAAEE)4(M`_JqL@;D1TB8!2v
z2N=7Z%(ernu=jLv4DmSrcJf~R>_moR_3x|CU1Xh@rJ^FX_}MiDvDy7Dg~~_#nohd8
zxJVpT@F+2m*7+mol=R;HNce3N!CeLtk~ZZT`R_BUWBxImubB7z`<(vomLHVov-A{m
zePQ`!dqDH?(-ekzE+<axk=_{lJYV@<Z;y|rq|W0=r`_L<bRE`uEKrzKuB&)HiRq?m
zN`b!kyz}XcZZs(iiRw3MSlpQT;`7g^OzX}h)gII}+F}>uaWurHZExujMh5ndXm;s-
z(cnvmS=SnEcRc?gEu-t$=kg#!+5W_QnT_Y|9xZEGzVuJ5iQnbu3*IgbiTxfWM$^BB
z|M(bVX62c3Lwo6KlkOW|I!b<PUGlrtUhXe+^UIMp>E1th*Mx`f*ilz=S9_`5)qqmh
zW$U-E-#+8xW9OQM^`bxLgm{Qw3bOm2E0Z7)@ipW1jD07)F8OXtp0zD>{gW%FuEqai
zJyZYT)`y_DHBxaEbN_2t#=l}He4F5&bhKxRW(rr3p|Q~6xbS6P<yEzw|C=)H)6H`;
z&&{j}t6KF&>7(tQnu6dhm+#qz+OGB2UMH|~)=i!2)25eCSw7O@c<(L~c_!m*&Z_06
zQio+CFUp4~Hd_m5FZ)wr|M#ls%0`KGO?AsujJDX!^W6D+|Br-J@uywYFF*E(%}l91
zC}U(Izdm(xt+0#PsxWhwoC=p;YMV|zHl3CF%<gBO;$^pR3!7)154Dmd44<_gE}3cO
z)c8h$Y1<st^7DuM=I&>Hb5phaG$U)@EYTzEOj6AG7df6D;j;hqn*U~|I}2|>`7B_X
zQY~?fC`m~yNwrEYN(E93Mh1q4x*%i_VrXV%U~Xk(scT?iWnkbe^85~phTQy=%(O~$
z4Q5uR1`rKS*D9s}HAsSN2+mI{DNig)WpGT%PfAtr%uP&B4N6T+sVqF1Y6Dcn;OXk;
Jvd$@?2>=fjQ;+}v

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/ic_notify_halo_normal.png b/packages/SystemUI/res/drawable-mdpi/ic_notify_halo_normal.png
new file mode 100755
index 0000000000000000000000000000000000000000..b5479342cbd9aa14ebf1dbff74c9d1649670580a
GIT binary patch
literal 1756
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-mdpi/ic_notify_halo_pressed.png b/packages/SystemUI/res/drawable-mdpi/ic_notify_halo_pressed.png
new file mode 100755
index 0000000000000000000000000000000000000000..595e044466dba603346b3fa63805e60cf8f32a29
GIT binary patch
literal 1512
zcmV<E1sD2>P)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800004XF*Lt006O%
z3;baP0000WV@Og>004R=004l4008;_004mL004C`008P>0026e000+nl3&F}00006
zVoOIv0RI600RN!9r;`8x010qNS#tmY3ljhU3ljkVnw%H_00inuL_t(o!^M|NY+cnA
zhQEKEd;Lno%OOAw5w9RXpek}eA);!_V*mj$LqeVL5R4EK1DG*lfDjBAwc}P5qe_ir
zKmtJ|)Pex>Qbc$KM8Jdwh~r0WU)yK>9h`IRgRzN;Ep<s-y4v^bz5cb<zaAU@&!XXx
zF#%C8o#s6TvR(!l-8ZzZgDs#B_zkeN{{3q~BruyW6)+9VcR{Qdz!|`uz)e8A_Qbj`
z030y0HS)!YjF$r@fE*qf>w4xFJ<<j62jHI5@jaExTvUqR64=l(LbwCW0t>?<W2*w`
zhM@O!l`pvg`UG2@<wXIvhxjhh!BiXuegsYe<w_teHb%ZCfB^bS`zoS%$f70tvvBUW
z^peqG-~=^ChDXL2-8V#Qql#BZOK1Qo3<H*aC%jYkFz{DPqreYM5V48M4J-m3Y%gzW
zAQiU>KQ8AUV33OJP`iIKr4!Pjz^@8VHTIQ?8w8Jp^IEEuFE$lG&HfG%hb%oA_EX_J
zNF${!-5`9oV2GOdo6Ug*;Dpi1QW}@@i*P=iiah{EMH08m`EM(Z0iDeT02L4BfO#tx
z<m{1i(2AY47tRm+HsN=SCWA)(-k^BJ>Hx=5@pixq;DyGAyJcSt>Wdm}XQSFxrB?Hv
zE{N|9Z-jkx`462N_%h@E7BDF|K*h>#FIdaO2-s4HT?=L#KwC@!Z!E%FRMjpUM-rH^
zbOiG$u%kxXhuH!2wSY;(e&98hyJ6H|+Ehd}6~WSQW>0X3llvCU89m_>rFnj$jMocs
za+Po{8cmCw=oVZ<k>)IkcB@MmsxsLv$-T0-m(I(9voRUcQAK>2@Xc(=R6FQRb1#qq
z<G>`p+=^H1TYy@l`-TjZRE?q=(H@akV4eoH85HDuGEb!9;}Q;s`FnrivkMqbG3m-f
zOO0mvE($?E(m;bRWr&Fq7S>2Z7e>8BXuG9z0c`IEUn4jI9G^FzwXNp{3h$jwji~|v
z&{Qs<U(O-m3Tvt7bwJ+$bE^U{DuX-$95FQj>720t2)s)*{Y;)LIXIL0D4;B~44@&s
zz&632lrCCAW&e=qFlcsF#tYA<;#=WSa4wyb{?sD(0^5Ni#H`J9!b}~;rschcZQ<Ny
zxWlM1bNGErUkcBzm2!)QanOOVzwT}(8cK72IBx_l1h#}IR4MGP7O=%|L4mImJdlbj
z8`h5ty^`p^z<klvdh{R9^4mW@+NG#1%?Y20*aa%;P@D(eS&${tLcQO^@^CvSxTJ92
z0z7ENUh2*V&H|65^gQTWPSFcGz;{Uh4ExGby18qm71yNwnCuS%znRkKHggi~uy+`C
zC%V2%;I4!{YWSPc*Hp8jR~^L~EN%mXvac6@)QaDG#rP(ew>?{PAdvcMZ~T;3&JP67
zq~ZW@tTynJ?RXIwxAcz8)8TSFiCZjfS)vp4AoZ+uf$+SX{{j6a6>kFHQx&Wwwyr8G
za=8thC48xzw}S36y4q6znu_gt;Uj_<4gX5TA>epz`BK3;<uu#?(gFtRkX#z%9>Xr7
zOALdCUcrK3-1sZOhemIw;^W%o)3rx`HkPkf7J(^X&eHLc;uFDsIR~j8H$7C<aN3F=
zOEj+P`<dG1*;IVW5Ue9CLG=P^0WE=CSyzG=RRJz(G@;d=XB&EuGyttC>v<vn4{;<*
zI8;dry#N3JC3HntbYx+4WjbSWWnpw>05UK!Gc7PSEio}vFf=+bGdeXjD=;!TFfgsc
zL{k6&03~!qSaf7zbY(hiZ)9m^c>ppnF*7YNHZ3tQR53X^G&njmIV&(SIxsLQY0)VF
O0000<MNUMnLSTZn9+ou#

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-nodpi/bubble_black_l.9.png b/packages/SystemUI/res/drawable-nodpi/bubble_black_l.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..13dd31a22ae2ff76719327b42dd66322dc9fd736
GIT binary patch
literal 1779
zcmbVN4NMbv6t955tjtdY*#c)PqFCBqdo8rKVClzbMv<=x%uOimm0n7FwRg2G4z2hx
zr=k(rM5c_`ObQYm&IN@DjSA>gKvb3~Xjl-ZQzp9MRFqwTx|tYFcDeii|M%|w-h03I
zk^3S!>4ShNAyY^sQh+=`l1l8w#AEUICDz!C)7OY?E-uZ)(@+g=QJP?qNR8&gfLyQ4
zgHvIp+P3N(EFh7*HAs3Uo~cOWt57{%>DHlJ^+p0sA_?NGMx{yz<3KK)hZuyEKN_1U
z0HPLBGB^sR!YGEdNJ4=LPAf=CR~6_~JT)aQ77$qZgaJK_D*>xM-+=M0Lduw3K5=%7
z85Cel1=k5F<3VLAk^wPlf&mVl9i?J|Ai(9)L5RcUf;51|1X&CwadV?Uh|l5jS<%46
zMIpSI)Ea)OL^k1zcoR~zIBw)K7#53#Zei0=Qyv54@px_<ELIeu5rx?dxY8PBz^EPz
z5*SmN5F?JD2Ec7mnTwinA%%!^oPyq{P`os3z$Ow!q>N!z8W|v+$<XWFyvDRKJQe;o
zjMr*o={6(GNQE)fY*G>R&`>>KB6n|g<W?l2;V&~GL{XIa5>#c@!v<U~5mJaRbTy*p
z^FT<#j)B<G@nVjY1%e``1dNwRcwBb0SSFIhcx=253yD~4sR$B@IWYuM$`ZwZQXa@;
zvqW4Tj{|`otlWU%N`nga_(cf66Ik9Gv3#)!R^q5B9Yym!9gwU=aTL>{MnIg#1r}x?
z1~qEI7P-qa&Q=1OkkznSW<vGASbq7)Yy9(AZ{t0VRsWxyF^FIo?&kPUvv@>A2fB|h
zTc3D&IXtj|m>3f=8WqQy*u=z9<q}c4_1eAO-lWUPB-c>IQH9sqjkh1PMm+ds%TT;y
zK~s^j4_i2NYRQ&MdCXSwt|N6jy1&Aw%k6b$M_BVZ?QvjU?ekSh9hLgCM`>Lno2Iv0
z)J<{X>)E=FzQYIUIeTX>=_!(R`iF?9+WA_a;>sCNk*r7-$axe-6Z;RZ-0=17=J&Qk
zAKys8$Y<6z1^m=e*l4>Gev2C!S7nx^Ew$zPG(KL?T&oK&dp<Mye$vLUf$P4^A3nL4
zU)ol+T)TCKrgx~?{QIp{HIvJa?<+|kjpUh~UW%KgSDe)~*?y3B+kupTyY|+S2HWC8
zYqCu@{}u~wel}eA-Hi`3p4O3T=k#QiY`%0U=EaXEo*f(18bZk!b6V)Mt{aiiHiIB>
z&%^rtn;eT|WnPJ>d2%`I;$@96sy^B|MuTAWj++<3YS$}*bQIcM^?8CUB<fwoo=_f@
z>Y+WJ2cP1JJai_w1&)EMx|Ty{+v5)8@7qMXI8fls+r4-&b7jxn&~n7ppS*QHC-mES
zLLvE1R<%>5s3;~~gmO$Y$Laa8FAAUbT^<-*GV5${c&`+je4+11Uw8X9VNT`VnHM_x
zhTG4dtQRC+?OArQc!k$M06Fc;<zUwt7hdz+S>)H)=E4s;oCo|G9^3DnDLs}QSf;6*
zr0EV!O^uh=l$Dfk(8Mw$o~)j3eyDG1nd9wPT{+1&Bxh{7B7s~>y{AGh=K`&Ly>GDA
zo}%a^c?U2%Nsflfb9N+)Ji4x&R@~0WJ>QCue9NmNWo0zQuYKRB$-&x#k-U(gpM%hK
zw!Z>`we(N>SBy3=DnjRnH8+h8g_I4?)|@;Y?;jK$VJ$^<fg>~*t<E-Bo6>R@@!1~!
zn07gB%2dcwO~U-ALf^kXGApO@gwD@m_fBlv(-RcY|75sc(3aIWux96@`_|1V@+c{0
zu8HjKZ+RBI;kSq7xl}S#zeC_~o@xwq7T$(fT|KPrYE20B)vCD5`e*j2PcW%=jy-Aa
S`qAU=-;i9IBsm<PQ}hpAb)q}~

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-nodpi/bubble_black_r.9.png b/packages/SystemUI/res/drawable-nodpi/bubble_black_r.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..82ed95c662f69295c413877f33601b2232010ccd
GIT binary patch
literal 1795
zcmeAS@N?(olHy`uVBq!ia0vp^y+B;f!3HGl!Vlj9Qj#UE5hcO-X(i=}MX3yqDfvmM
z3ZA)%>8U}fi7AzZCsS=07?_nZLn2Bde0{8v^K<nQL2C3WatnaE85nHrD+&^mvr|hH
zl2X$%^K6yg@7}MZkeOnu6mIHk;9KCFnvv;IRg@ZB<rk7%m7Q#vqGWHUU{hfQG$1#%
zBvGLvHz%*ys=`(YY_1iM4HDK@QUEI{$+lI3I4Z(7K*2e`C{@8!&saCvz|c^^%uLVF
z#MI2pP)EVYz|ctF0Eo<V4Na^}&8&>f6`()~Xj@TAnpKdC8`Lf!&sHg;q@=(~U%$M(
zT(8_%FTW^V-_X+15@d#vkuFe$ZgFK^Nn(X=Ua>OF1ees}<f6=ilFa-(1(1n}N%^HE
zwn{*kLcEY$05>+T7#d8#0MoBXEYLU9GXQxBrqI_HztY@Xxa#7Ppj3o=u^L<)Qdy9y
zACy|0Us{w5jJPyqkW~d%&PAz-CHX}m`T04pPz=b(FUc>?$S+WE4mMNJ2+zz*$uBR~
z1grP;werj>E=kNwPW5!LRRWrzmzkMj<zjB>YHDF(>1=B5W@zYYWa(z&W@&C@Y3yif
z;^g9N0MqM|pIn-onpXnTn}X2mh*K{pDdZLaZFWg5$}CGwaVyHtRRDY0DigO`%yF6r
z)tiFbEfzTS>H{644~kf%h=vIPQxAv<Pqsh~JmIJ20aJSsFj+gZ9MuNqmU2%Q$B>F!
zZ|-i)yX?TwkU0OX#Zt}<1|Rr%zOXLfKX{;}f+MVLMG^y}KBGrRW4lJjUeQOg0!)lv
zmsGZ87mN3Gs+oPfIp_Vqc&pTv0xS2=E8dpey-A1py0Ful`%7xpD=j#7blx8S4H7y}
z!X3_-h(9^3H)Cd-gYyE#3j&Q$I-|qE`PuECCQSl!nBNrp`mHs%98hlT%X*|yrn64=
zL-xBpKK&v4#nk>6ZhURBHSznB1u>~?o3&V<EoVzf`JN(lHlk1P_K921iq7Qx@|nzV
z?3Y`Wb>zk;d|&lC-<&_;&Mut6R@3&<cVTC1XJ_x+4Z2mKNz78yuKZo~@mtsJfBtvo
z$<%nc6$<h?t$UZZ^Ya>kmp1(Oef{!o^riid(KyJnUd43}`>buJr@N{@FN<<toF>7l
zcCXvvGV2`I-}Q6WRB@QFNHOt(JOiT_C_?xMPwu|BLVZfXddZ|^3&XlA*@O%)3uHj_
z2}0?{Hgt1x)_tArzdCw-d8vA?bg=l_?ts3CKl|2&H7qkKU0?V0*3r3J-U=%(|K!2)
z&_L_4O3eMev5c>*WrQ=XG@F{+Em`>JAzxgHg=NKt`rHb8N&YU4m-cfm2uR(!^zq4)
zpKnfoa<w{r=<^nVR7Lf>m-0<Cbyii^m;B24R{8T1tHrXkSxjQ44{WSzUoinq{Acrh
zrcGn=D~sM+u4fe=vdc_n|9++U(EiP<i{$%WDj&)^_EYURzva1z$eo<adz-7XmPNkY
zxY0VF@A~@u_j0>mILfx})H%M?svysHk7Un!_V2%nWZH}U-!6I9y;6o-JYD7j1G~uq
zM&1IQ7G|jj4Qv(*82efa9GD^E8wL0>8X)3ghk%M49^200d(v=B(c-6+-|z58AlA%z
zg$~SfZWWx{w=ORAvy91smHf{SKkoMryZol~Xus*cyyz)U^W^7Lv?MOSy6@Qzw^vR7
zU#`17cjmE+lFJtzi(kyv8(+XByj%Uk57u-si62JF8Gjl#8*Hg&?o}@k`}O>6jaK^C
zE5EOFW!dleaeLFwINiUkt53e-G|AIFeKq%u&|argO}grf9Gw5}tAA|4TN?Steo4^&
l<YmBAjuFop&ih#;82s<#E|^k&M;=rydAj<!taD0e0sz%&t2zJx

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_back_left.png b/packages/SystemUI/res/drawable-xhdpi/halo_back_left.png
new file mode 100755
index 0000000000000000000000000000000000000000..94fdd6ee63b39138fc7d5fdcf0dcde30bdfee948
GIT binary patch
literal 6034
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
GjQJl>!P%Jr

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_back_right.png b/packages/SystemUI/res/drawable-xhdpi/halo_back_right.png
new file mode 100755
index 0000000000000000000000000000000000000000..33efa1a561efbe12f1e6a6e40d7c20341678b2dd
GIT binary patch
literal 5994
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
bqvob~*1{^EmJYf4=k!}g^A4;`10DQ7rd!)<

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_bg.png b/packages/SystemUI/res/drawable-xhdpi/halo_bg.png
new file mode 100755
index 0000000000000000000000000000000000000000..caa83b010b8d5863b727a2bf9a1446e57687f987
GIT binary patch
literal 5399
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_bigred.png b/packages/SystemUI/res/drawable-xhdpi/halo_bigred.png
new file mode 100755
index 0000000000000000000000000000000000000000..505ed26248804fdfcbd0d20eb7fddfdb58de9555
GIT binary patch
literal 6306
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
NTr#piRvWlQ{|^Z^f=B=W

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_black_x.png b/packages/SystemUI/res/drawable-xhdpi/halo_black_x.png
new file mode 100755
index 0000000000000000000000000000000000000000..ab5662aa922d631ed344800cba7cecc743ea57cb
GIT binary patch
literal 6016
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

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_dismiss.png b/packages/SystemUI/res/drawable-xhdpi/halo_dismiss.png
new file mode 100755
index 0000000000000000000000000000000000000000..f8f23749ebb252d28166489c085251423e1cde57
GIT binary patch
literal 6143
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
EA0*a9%>V!Z

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_marker_b.png b/packages/SystemUI/res/drawable-xhdpi/halo_marker_b.png
new file mode 100755
index 0000000000000000000000000000000000000000..efff86d0f0021c45c445a47ef7db61e2de082188
GIT binary patch
literal 2527
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
YL5~!wT%ruux^U&9yL(fACP!xe8-{=l`~Uy|

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_marker_l.png b/packages/SystemUI/res/drawable-xhdpi/halo_marker_l.png
new file mode 100755
index 0000000000000000000000000000000000000000..1bef9867dc08a525bdadf1116de737cb65f96788
GIT binary patch
literal 2194
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
UXl+RgMF0Q*07*qoM6N<$f)$NB6951J

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_marker_r.png b/packages/SystemUI/res/drawable-xhdpi/halo_marker_r.png
new file mode 100755
index 0000000000000000000000000000000000000000..92094453337a064e56d6ace7df70d3f80ec3a2cd
GIT binary patch
literal 2183
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
JPDHLkV1m5D7J2{x

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_marker_t.png b/packages/SystemUI/res/drawable-xhdpi/halo_marker_t.png
new file mode 100755
index 0000000000000000000000000000000000000000..788db7df2b5f5a7e1da5923bc30ebb35333fb30f
GIT binary patch
literal 2473
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
QwDR*rqj-^jb7k)R6DFnue*gdg

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_number.9.png b/packages/SystemUI/res/drawable-xhdpi/halo_number.9.png
new file mode 100755
index 0000000000000000000000000000000000000000..42e3cac11f9bbfcfc3d7a2f57650d37874eddc27
GIT binary patch
literal 1149
zcmeAS@N?(olHy`uVBq!ia0vp^8X(NU1|)m_?Z^dEk|nMYCBgY=CFO}lsSJ)O`AMk?
zp1FzXsX?iUDV2pMQ*9U+n3Xa^B1$5BeXNr6bM+EIYV;~{3xK*A7;Nk-3KEmEQ%e+*
zQqwc@Y?a>c-mj#PnPRIHZt82`Ti~3Uk?B!Ylp0*+7m{3+ootz+WN)WnQ(*-(AUCxn
zQK2F?C$HG5!d3}vt`(3C64qBz04piUwpD^SD#ABF!8yMuRl!uxSU1_g&``n5OwZ87
z)XdCKN5ROz&`93^h|F{iO{`4Ktc=VRpg;*|TTx1yRgjAt)Gi>;Rw<*Tq`*pFzr4I$
zuiRKKzbIYb(9+TpWQLKEE>MMTab;dfVufyAu`<jAm(=3qqRfJl%=|nBkco*&`K2Yc
zN<f!FypUVq>kBtHuNWFoz#!AFNG#Ad)HBe}%?0@jth%@)C>7xhtg4GcDhpEegHnt0
zON)|$@sXws(+mtd{1$-}0$pR}lAm0fo0?bR>0+w{6wyn`OtCUDbhb2iF)?>GwJ<j{
zbTzU7(w62<ZpOyuW(F>nt}wlxdBr7(dC93Ty_pETW_a~lITxiSmgE<O<mczWVlN;g
zza+mnBfmhwIoM1=BRn%NCBM8_6BM*im!=kFmZhe+73JqDfWyWr6U}~*+bvB^T#PMD
zjLn^#O<j!)4IK?!44qtDEX|C~o!uN=ER>*nQ?U4(pk95TWAs50ixkl?Az<nOG2zJ;
z$bl#P)I4BnF9IfOIliJ<z%236)5S5Q;?|oRd%2n&co-fW5nFiY!KJm;_fIVU(z~nt
z^&^E==DloZJ>Sd^csgquOVjP2g8IwZoH;gxDI~@4T#qW>BycyuS=@bQ@iLzCHz%yD
zWf019pWbBD{NBwya`I~~!NXH8H*_y+@>M>edC+so<O4EaT=Q@3W14sB)108<HLDIA
zC$OD5+`wk?;LPs3S{V+^|7-$kmPNDLvn~oP;4C<M-_JUYC*!~oN8X;WgZ2NPgzsnn
zYX7Lt&SUAF=6#Hl)NiYXUC`E<H{JKr0fU=Ygk)#4DV%S~Ry|?Cly}@#<5tvrf!cRA
llkV={V)(v)QhA|p0>jtqA?|BkjQBwXf~TvW%Q~loCID|ji8%lO

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/halo_pulse1.png b/packages/SystemUI/res/drawable-xhdpi/halo_pulse1.png
new file mode 100755
index 0000000000000000000000000000000000000000..8ebd9ac155e99cbdbe4d039d73c94bb3a2168522
GIT binary patch
literal 10308
zcmcI~2UJsC)+l@;h@B#cieLy32!xIX1OyTwGz~q{L=veX5PAtHDAIe8u0ccu0RxD1
z1r-P)hTc)>H6Wc3_~Xoc^XAR}{qxp)YrU*w<(_+YJG-2H?mj#6mZA2k;}?!IF)^J&
z=)jDan3#2c|BkUT?gWbQ9A*6RdBH8bjB)q8eC_ZUCUrFKE=CZ6wR6B2VeHWU9_^Ux
zOiV}aIhj~^Ss3Um+2gPfyWcPnKdd_gn~CYVnxDI!y$i-m@Gi!|$xQ`7t!n}ZI-ykn
z<_ZSV2JV^|M<<;CJjOV{(8NB##U6?VsHqBG_fujJz+$}Y1pTnCZk|ehDuBPyRbpKK
zzAXh1{2PduiwfZHLRlEx64b=uF@g#ZIZ1nI85u!EMTm^Nf})~~grKanjI5M2<Etns
zBd?^Os3dz;@E;!lgBu=wPss?T^$%W*kqW@k%gbF!O3K&Q7vd`i!QmaGWS~&!ZyK_)
zk_-q*Pk%QrJ3mP`PoY04z%ZWncqex+C!Cw$Z;Ezzao%1k0EVQ0p90q1z~G;R-8}!H
zD2B?U{OsJNWFXQ~SnTh4{SDgF%Lwzo#P~~SPZNK4jFb_^6X%V$XV~MO(4WW*-Th}q
zzX2K2DBZ+6F^pp83d7lZV=-=C2$%|h@dSc)LMusY%0l6AMa`@7n(}a285s>34Mi;l
zIP9tnOc4fG(EO9eU*W<PrR5dj(sG&#3JNkZa9Is?83j$ahL(mLTvI_&M(a;pgqx?A
zotr)8PrgnJzW>0L{g1dxns|(z7Y=WN!@2(H0k<4+UN}!joV%c=v7#Wz+{q1%^Ys+_
zZJxi+7KXt)`C!mmcpO&nZ~9eo`V0R5=Xw7f7ybXDGbx5JQoo(!U!3L7TMQ5Uefdw<
zXAJ%sJQz1d#NZjB(OvBn$HW9=SW4Z*Z+IzZHyMNRZ_Nv=3sk%}7|zU^K;SxyGI4+O
z^4<5wPfsHwKY!GnrnXVdFhwTfW-*bG7tWc(Jk*(yXVrZYFn7Ye?=y#I*wxa;v(|fe
zb8D&f^v2ojd#p2%yqkTNzVkiRxCzg$+3Q_2RcfG8*oXH_OoBJrkbf`<G8PILJJWp-
zGt*gNCMF^a(~T4+rU*_ZCdR{m8~z*YzYYIyP#LiQGuPjA|3!%Z&gMU(GG_Cq{Qn*G
zH{HLU>px)sGwN@>{8LTRLld7e^VWoq!q|;P-y3#JIPKw2Cx{E`o_Dz7!?~@jpr)sC
zxmU+Mq2~1n4->LEIMrS^Jm=$NFa3p%oM_ul@QOnO*ID71?DHd)7EiFSAz=H9@N3M-
zX0Ujx)#AOCSy+Z%lP5hM>SXqMV)dP2t_}mb9;iMu^@Q{8%G+3A7OUR^ixc0Kt*}{|
z<j0I?2JSDyeb)^OUKt;*ZO_o9{$m4ai2)<BMk^_Tw8&O5e}Mjtl=6}}8PS#uR)miW
z;M*#$^BfkrZO()BU2Qbu#ip-x@nEkchF5c7bkpcD*F6(Ox?w5z1(QRq+={uTAM9O(
zG=@dJMaBohEs>RzQEv^1*EIm+FP7uQhL?xGV)pJofBVYurtTeUc3&uQNg<-5NR1)2
zzEe~V=XZTCOHnd3@<lOdRROMC>A1*!<+2E(G|@{@huBD8hbz}RvT<XJZE!j0ngYkg
z=q*Re<sK^inPb;Hm2UGh=r-1@`*pNPAiLexSrI|qxk_#{s5K)-x@E#rO6GMs3?ez)
z4p%mdw+?^Il86!RxuinRd7{3m=Gx=pCO*s+(0OrVy$)y+ax=>^O16Hv@A*u)G>5Rh
zb|!yen;f6|R~YGJ^;#R1rJ%bNtPpHXF-#GZ6spy|Q=ywqU-LoW)G1RXHq}wbRTM&y
zT>=HO{qwl+UqMJJ71A)H5~W2oUp$I*l=x&bBhw5^S(*@w1sHRnjf=aTZsv3)U9y$5
z<1em+#{5x@2$kZ-+BE;F+_5W|J5hW1&dBLz=b<A;ZOSfbyeDbOIkJle9?;b<oTpzZ
znyusXJzuo)ZDLFHYhjd6jvIA=Cf5*eqZ!?U@AhE0-dXtP(Cpaf*DkW-Ujw~-C|_?W
z>lbafu3l}(qp(>9i_R~nycCC;md%rfQWN#f)yl?cf)N3<+9oa1X2iOF`^p?K2U4_0
zyFN%hpeTHBQF}SClL#1a*|?lnmN<1+gbb{OrAU83PU&kURj?yU%{TmNr#zzottj?Y
zROHMR1*%XzqN{UWWvL|c{V=(p6jv1xoC9bRN<E-`|LSrMn+x!`OkB2hSG^ldpse)J
zf-R6PhAGjJUiI2uks!Mu;f!d2181VWZo>GPIidbp?&VG0*fV`DSmO%~C}jS`cH?^k
z^%P7ZZ0~LTBk%%XQqdSx7bRh?lYRMA-tEd0+;+Ja>JRdx<jYL1zQ=9Y@cf|;5n+S_
zBvF|7P$m{or+_b6DN8%q(6rW>L}ribwK{fF4`h0q9s#Tw8$Rd0Erghfs$ruXCf82f
z%k}Sjl~j-~{IzG}aQD#P?QE)B&*3J4o_E<vm6sj==1Q|ZJ?}oq4kpZ}Wmd$k-1pU#
zdp`8Krqgyki$9Ly_7*QcM7xkzzBk-LP^qppFv$=PxLI|ikKg@GE%$X5wRW<GZ%C8W
zTnOEtQfh?W)c}%Hq&+v&Vd)W^S|&*~Albg_NkQfm$Q%3}beK&Sn{s^uEsi)w1i55Y
zfxF%0B;9d)pvl95+flNR%rd~-Ri0%H__xOkoBLDW>7^4ChjIm>j!&6$oG5_qc{{|5
zy(_bvp<e3sMUDbh_|+C}75}N7Wa60fG-wM_EcLBauWm#_>5UYCY}gSYYpNfTVzVs-
zSGGmY=&H=h-49CHR|I#&%p8G2<lB;h^<eBm!1j0U*YzuA0jN@B$QV2d*ww$dqaISo
z;$K00X{BO!5uw<35#sP6QgQJv<m#&!7Z`m@&|7Us=dd;P1#Ncvh^nf1aE)r-SfU^=
z=lnGi!@2%QikZH}3lAr40M^dDieCZozw@<3^?PEp5*k?5Ar8S_D|!R+3)Z4vYgLC0
zPawmwhLp{^*OxX!ife`TL$*HT3Rs{Fy&M<|=-=i&7@wrSsU03#vVyyHd-n}7r?7X#
zp~)&AG_MFZtQr3BLI)pGA~^1Ibju2z;oQgmsd`NoAQfNxg}g_375H-mPJ5wRks`q>
zq4F(Ef<t)ev6u4oIS09<jj)kI=0*d8yXd?^y~VybT*p*QAJis-h#S5ThkZVzmF8hR
zZx_`(VO&{lfjaeF^ocF^@@@E!IsoD`1+!msg`qzhD#<fZf?!5|oa!u47}n=<B?MJT
zMLcPM30S@=uQg!*a_6CHaqq0z)m2k-E${l&FdJOLHGToULlotpGn}4wBE#zv!?u2p
zgooaEg`g#LZ}O`-V6aoHh&6MwxSwXmrxtas10=g$FRmSFT>j$|cEKRtZ2J@Kb;)^Y
z_|HR|%EM#{Us!VtTL514!g=Jq-D95(lX5UR-9mX?mZ$^cg5g||0PF8BzTf{EI~-Rh
z=t;$$4T`Hdk<^I>%t>-i3hl)NJ#Ez{t6?zog1q}HZ&jq667$ux@~&_Q$2<bH90Of`
zW`O9{3qCMIcIomDsxqx{AxNc_1!7T`w!`X-xe6ZV|MV6%Yvd^$xE<i1x@~O+eq(E0
z8B$3~c^M@#i=7ud^E-0Wkx50W?dKi<8)mwAyXeZ`LZFiBt#wl{n_F(h{(ViWZrS;c
z2n9*a^vpha-uCW%L>XWQ3@$##8a3GDINgm^7DCN*yKAOBA1~id((fGkx`_x@Oqh~`
z({NzD`?(cfO+%s6<}Dd8^%=m=U=jYVPU#Ce_ifE!yH~&i%liqyU2E{{r)s{{sDTL<
zfUd>8O5>}w*6?I->hXYD!n53Ur-;L6UdsA!X7gM1>x$zclcjOJ2=a+-wNjJO**NMg
zmP281;r-7@j5rB+R6C_SUCcKJ*syz-#}+iKyg_ROEvs49pe=&#Lwa@a!@T&m&Q+(R
zg1nbO$UAwR>)U3AglzK*2WQ?^Hpy0>Nf0i&y7UORs8yp9x+@2!iO`t>brSWjiTYpR
zK!jHjO7gGmPqb`Q3$#_tv-|{uckgFN4Q%n{w2eDpUKb1$yHyu}MW>@S5g#~&D<d2;
zyH^$tv<iZ##wL^Wgu{Ftyi5{0E75$C$smpEQ`f9&exvH)si+mg``Mo1152}s2|h9(
z0-)=7rDOC<)~z%)a9>~(aGs-Mpv21EhmvNS8wy-+Ua}1Ei0f?}5l02oe9OCC^Le_p
zGNiQJYwX^RRpFxqW@HlH(laAUZEO0y>PwTZfrNcKO5<HUz55AMjRv1a&@9{Y&!;(>
zcnbm*nlZX9hZaHzqg9UQ9oo{rI52KQ@=c_tU93<fTb9&U_nK2usPan)S-)=((#iby
z<=Ns2Iy3p>!D|X-whb-e>BBqsQ-!9AxNPh1Xg`j>jMPxgEYYi>Lz`YbO=q?SdhC6V
z-A0UK^w?a7<J?-t+wqh%o?n4)b~}f!T5izNUwxv<+rX|>fn)^9Md|2wH#19pC&O4m
zh|AUBvBse^Lj+nT+}toNnhzC#o{vtjdX_w><(;1GHV?lV0b=M_r`lLp{YR8yBRccU
zcfZcuvdA6pg3&I^fCHZ_=*Vg}2FlQ7XO#Hi)8&Tj#bh&xKd*LL1uQk6Eex8^WuSQK
z`wk&bWSbo<CA_$Ejx)q0d9UDwFrb|v)M0qm)F*6Cw(n6layw$cVvoDkym(~l^2j==
z$zze!6alikiF(U7y+tt=IJx?XHy5eo+tgPk94Tmf&?cK=DNZWc`s8f}`L&qwo)yDd
zh^mdpi*QOJg^93~w_Z8z@A$!p0OpEqZ~7ql5rl_}&B1N;bHa27pySpPj|-Q_L$rwX
zh><-bzw}oZg$<h~Ioxlg9P7?3J3SXo%`L+c5+C6f-WNxUh+^n%$aIX=_1p{WWm~Zh
zOsY9+V&KASjXmTCIna@cc#?C`i2`OKEbVP2uG_&UNJDJftzguWGZ8&zdYCW;7V0oT
z^VynB-Y)nNcavu|!}M`Knk(kMkS@#6S%ZLA%ZnFtU*yp+tijGL9oIfq1#u@+ZSA&P
z03FUD{)qH0;&92t`h%RSXcj)(ywL;^V)i||&-^=mgr>@+N5lPvB6~+mE*C?O8H1Bs
zz(Va7Pa5>s3Esu2^wbkdd^UHdF&>L(#6m2nP?Z>?U0+Nazv@pqU4QYl)#}~xU*?FC
zmBQ0^2AjnE{4~~4%I20s6HA2D;M6YzRXR-^!o+NG#O+vM@l3_FpifKAn5Qn@_ow&X
z>(pq2kCsJC(Eao90SzkxFS&!f0hvp`vo(NR39Qp?HKc4cE_^AIBoMMjoo|$f7_XXy
zU<Q3anuD*FZE+ae4J$yMAj4A6M<ZvzU+M?K2hz73f31B{Z%uN_&kLR1$|{pE>FiN6
zLQbovt(0k{Mc|zu4OMLb8W=k(KkVWnuT5XVXXJ7D%ng@JsxlSVI80_%YNb7o?|`Lz
zIn+uqmTd3cP@oQ~-6-0U!dhG%63Ki>i4hOXa7(uAyJYLIQ6KJlL>-`OgyWYe>r+$>
zo2)*S$WEEsfu$BDXKy3NpC|vk9r^1<u|S(TgE>*yNfI`nvnT3k+4TH<!&|R!FK)_1
z(~uYmgQl^9h+jwymukV9X@(o0RwKuBZ^0N86<{!S97|>UwywazK7C_SxYNpZS_Itj
zD7(d*qz_N=*o&3mm^NvXRXrP5O$zDu?<b!N4UjZ)JFli5-Z{H!i*4}+Ny#pNIHprh
zkdk+QnulF`e3UY!aw=(Q{Y~6!`N=QudGC(Dz}miUBQX;EbR|MI4HI;BrzEDLGDqNs
zYDC4LAfkI^jblnM`IJd_P_1M2qHq7)^C7H9=usFnu~~mpd3QPB;@6LBN2T4`pJOEg
zWc-^qEX#`OuUu2?>Ikw;01~rb^(r@RX7Fjxz4!kZF6Xfq85X0Sy_Sk;5~<xMlrJBZ
z1n6o$iNGhpGn{QWy~<CYw`C6u)Fg)sw#sE*LK_B;U+!h^UgLZg%cm}z!+|u61x`vG
z7MZ0T-F-0Gfm?QCggL1jhig>oUH-7<?;|oTLT4CHOutD5IpW9stL1HFi`qE@z?U^f
zW}*i=lrLvwY}9cP3Yn0G4=+h3E1Gt);p2LIf+^(&Z)cA-<Hat<qzg*E5tt+_j6v3i
z`_13kX6&v=Q!gS7;Xppcc#+~gL>`Uye45QIVQNP^*{mXjz?{Nc*~v<fQc8o!9DzaK
zkn{;d1bRDaY#Z979E)6W;=K2+%sMH4&cVjAj`E9;91|o&j%2JEKKkX$EpIn!N5v2f
z3DeLJJ&R+o`Ql^z-2fqG7?eWt3R?J?_`xS$;gSw4byBij1Qh^7Nk07Pl2odT28IJU
zrsWGp`3ub1j#57M!=~Cm+vviHACtVox`&W23&2cHpwm@iwx3;iymd<7jks+C)t<8m
zKu0?V+D$+W(~`KHpCClc?(bFpXk4sNONGxUb5evtvq$Bx3wMc@EG5ZcF6Lw=OA3-B
zQ_(w*Z24WQjl~9@UQyA^OcrkUJKWoT%A2iYex9Bjf!8fy%(v~w9hI$vqGcE(e)JCw
zC0Hkpq)%COZnN0|$VEeE`W}>@g>i;oDwKT{!;7)u8>LoW+x>%>-S!e+#WMdzyXYDz
z8)9d+lpqL3ZvB=_3mX0f&emb5`l={>M&m4e&!aXfo)u}Rd>L+LZoN@k16NHdYHebx
z3u~1N0!H97jZ4HsFR{?j!eafs4*bQTv?CWwMS5pwED?A>!91n;#D@o@xOj(G&z~r9
zY=u%Em}@L)#6{qTg*t*0+{(&Tq}261*1QlEwN2#kBiEE&8rAf%@DwhwR`s8|IUgS2
z?=PcnnvaoqeoSd6|M2|bnr%&1Vm(D-fk8bI(H1vW*fdNpPZ{$KT<{Digl3ii$gj$V
zPjt<4Fd{(_^|^=3I>j=qm*(Cf_4L6tQN4tkl4nsMw$IK+5%{Q{l~rgw&*d|xlQ#LF
zoEXD2LC>TO`MTPDO|@&0GZ2Z#j2Qh0PpX;j$?c}2;9O&@sOBlHRQ`*Qy6Taw`o=oU
zbM^@QPh;v){*%$11==Z|pMM=Di)*<ImVv_}e!(#pOWfi?g^I+I+-=zeQSVzOC#t@_
zO#qTE9rh~s?O%Xi^a@FDyy%T$|H&|4VsKz!Te!EU=wPm#oDmY3lx>A9O_s<hObNb<
zU@X++$V9Znm*CaGvfAzX%L4W-V5)b1*vpRKthQd|(JoOI;;8F%i6lh&F{n^0sYvJP
z?Z8ziKX;rhabs@o`#fuW=Uibn3&KZ^biF5hz;Byt&d@So8E1rJxP9}IL*uGyf@j{_
z^<N1Ue?VtWgN#<!Zq`lG7p)<MM@MiZm9jNMG9xF6Z?1?EA1;P^?QcdN0Sg<PS3~-^
z)S3hdQi0e-YZ>1~<;1<ljooV;(?IPM`bXYz>V#VhSbFaR-cRIJj6ll{JSoR<!i=`g
zeR1oiszs$_2KD&wh;c;r6XqMF7HqJKycYuvI+@`a-~2jcN7MUW58TXs)_O4ZjzUg)
z^PqqRirru=4FL=MCwj7Ya}SjUug+Qy*$#Ee1ITMh&-=1>_WNB#yLx?W)OJVaXo*TS
z40o@M=pH%sVGCDjr-HFIiIi^DO!8piqncBlp=Kii<OZk^0v!n|)JUVl<WW^LR|}D;
zO|QZ}Sc)|Z)W^y9s^`yjpSaW>b3zL3Em6ff*=IYE;a}k|NqJ5-RzZaFka5@PX_u^S
z9Fa`nL4(K{FHLE`B+VcdvjumnZx5+u&~llG*<|kPu1(<KisAl_hjC63;zRM1SH9HJ
zeSIi4#aP1dPn9T%tUXYqIL9>X1PStLUz4&jplBm9B`j2-ka!F^Jy$s5-I?FEJ?IYi
z6j%=acD_wL<(M28fs5x^K3!nL*yd<})5oIDlv|`p?=|b^EXDPy`qaagbis>Gv?%dF
zB%|)ZNOkaZMykvB#>0PS7W`_dpOJkB`K+NnoHSRFcMb2!9MlJ-NXsLL8AhI9<k9Y<
zd|IhtAm^9EIf@eJl!%VJqQu1VD{Yh{w4d77KQs_~e{`xwO!B6#54Y!8LcQNWCVy`e
zjL#W-=D?g+-}&$h%zxcRZ}$Z;$8j_N1!JQr-0_YZR5dYvXIe0BVmmd|P4D@rN`43@
z(y&I_9%057F4Z3pox0w{Z!7VGNaVlGW%^m@dmH|+VAPwQWV(JZ8^6%MMk;5M75yrm
z30!6*A712V(#b5}xx;31@#^l&?GcGF^Nhu^hjantXPT4ZyM|j%)nb|Z54QZJlssgA
z#)2Y2a-@<KTYC&!6V5Y$GVY9NGV?Bf6pMdGi4>Xi3hdvKSW_Z7QmgQ?52%&`^Np?D
z^u7%}fG!%9984pW71lMAT|xpMAC8<eEp^oSP}BHzPDi#c$Zp1Svu;~2C7KVxi3I3&
zQ}tmr=P!ZAeZBL8yIfWvRiskcbEYp?eZNnqqqFga#CGRHzmRp&*H*sW<}rIkr=%e1
zT*9FY_1#qCGKIX_-KSD5Q4uTkJ><sMR)+&8#dd-dG1ZTN^yAS2mH5g!uzG;n#%Uq~
z#x5oK>STV$1oyHyeLOKrJpTCU&rr+ZGg|H6z*+dmN3K<5_}Ea!pG|CXmX}%9-0i*l
zEkcAtSRR)8MzHuuE3fWqBe_%Q``3PEUmalEkUly?m&<MfA=@X#r=2`rwhsZ*o>&JB
zfQ$!IBSrWaj+YQA&Xy5DDr}pqgOA+9aO?@2@es|~X0odm%V23V!=!t9dJpc&iB)gw
z*_2=jOtYf8HIt5{+Uclhp=Jqz4{h+&KIXw5W>fxa*6_<smH45mGZy{^{M4rU8pn84
z-HBVKYK!jQms5c)ck;7zYG#RC>D!0{IOTLVmHvgyT>DmN>;?>B;<PIk8;wNI^9s=J
zQ7#WWm_KnZsKim*;q*6@-kFuNsFfVX%WHKD;d^!A!pE87^uUaPK6u?ISwWjuazYIu
z9|?M<m08qCK6=p*yYa^c4h22Fa<oG=YVRI@gf}VXQKZDS4P!Nx-5+f@v#YWISj$tf
zsyrm&F)wYxfHk8>hz~Pg%BD>dCHY6!)b9(pjKsoe<)@^yc*wFTBBW7e#0#FEo$$m8
zC65MkQQ16+Reee$cA9*vMn_h^A=Z%-sZl3?Jx;v%$Re`+*9Cg+wt0ZSpa(l@2B634
zmnMpENkH%W(^S{sQm4(y%a5j2kIdG@fNFXfjMI`%_E0TSJk}4$Ww)WB3p)zWq$)^F
zcuXhrrBXXY&h$7uNes1TZ>zNIX=a1ysnZKOyAl$;1uH+~;iLfZu-~--KXKAV>bE9)
z%tZS70g<3VvZ83DNj#@Wv{}jQTFtC`BZ5DWf8s;FnzR05ey4WN&`-ra^=V@Gucs8A
zdurDl12e(~M$QdyNu|#C=M4@M>Cvfrm8cXOU*dp*<*=w?=d@;yPMQZ0YAl2h_;KKg
z=;mHNG^PYkFt$Z)$ODa&tV_u<h}~w+l-2JWFDW!2VT0DAyWKy3ho(zuL}T&>>ra0x
zFW75+Q6nL&n&>5ItAAOqo6Y4bXxO17I~u23!Kk_@B}Y?KpH$BrAOwjIc{mD$i49h_
z=h#Nlqu+iYXR4%6x4zE4xm4kw>+Bb6BN);9L1~`NP1G~gIcdt38_{T8HYr+oC^1}x
z<gPgjPmu^xXB5m<zc2U0((G)X+nUeHBJhuh7X)-xhgGQHk<@GMSqnQN(AuTmpnii-
zQ{zG3mM($8r^kt1qqOLzXA!|N5sV@u@%P$Pe#Y3nVy_5qy3ReS_b}+jtdQB3sTtVu
zuozv_leU#!fadGEnk#SD4^Ld1y>74PB20(cdK}<NF1`22MFQuKxLR_J@&B0Zta4|Z
z!ki?zMoDO*0`i7tUuTc|mD{vN=Mc2I!roS<NyXstPIhWaPuT4D{a@4yWSTJ@7ec5p
z@80ipIEVZ?=Sj~@B_wtA>BuUOV}TsP^<PNY9mjeKyXaM^6`FCCKb+@-mmO^-wh;W~
zMKAG`?hZo1>7@_n3E|$MCCTW)`oI<kbpn}uZZ;?I9OB^HuOkj86y_D#0F06uDy>4H
z=v|ro)S_7cVVW<1UkX)Y#a1QtrF^8jiXesxXY*6LLjG_p_@0?iTimHdgt58q$*gU)
z0Ay2{*u442>o#S9kAeO<M$}LGuNnrw6);C|+Jr~EM5G0Wq`oEOr7m8{%^z50X0x5?
zpg|a$kq*<l$gK;+jt|GQGIBCOq^t-)U810Iv><I7LolQtHM6lD8#uZd8e&_pf6r3s
zRZbF6Xw?4LwE866>e%?r{p;t7c7hKc09v(E6a&a}1+d1a;qjwx$mghbA*(ZTu48le
zsSXEjv**(86=I^s5XWTCA;POgQ8jyA+FnihU5t|F*XpLe?o^f(W)5U?gjQOSa8t8-
zL<LY+;Ni7fW$QO6ZsnwjUssi$cp@>*9z#lYGid0bcAk3jr7V^VPD~#)uoB=dFtmkP
zdIk5TLWZ|XtP-Zw^#*i|zQlv<9%A?k6BwcU%a&?(!9RxOdphu4CpowyklVWPNg_IE
zbz7pLHsJcI+#p+XN%W=8t?cUY&ga9=E-|#AQoGgIW{!d$n@OB%4{$546>EIf<*W_(
z<fg2Wc;pPS`B)qNbGNx;$--ehwcF(|=+4i(;IcUj$&*XzV(-l8I7mm%+sZsyg|?pR
zy$+;&=MJBQaU52t&F`DY<+0NOG-ox{xoJ7qpv@i4%?wu(K0`jw{4hb1f1iAAMXoj$
zWXFQZxG;rauW&9zq0aa{Gy0_v&@l44{%1a~q1p@XioCOEspQaE)}WuqJfRd*@z9ck
z2^0CDs)F^Z$*vcB8QXo0jgGu1D2Y&M)1&>SYydH-Mc`RK6$(p=;QV|m&D;CI!Tyih
z&A!L=XVyn=sQMx@uZk~^zB&@@AqC4wn#KdjqlY6eY-NM47rI4MgKLBH0XjX0vxl_p
z&5#NEU2k>IA|JK&kUxkI=@MURQ*jHB!i8!!aP7v7cRCxWd82nk&#u&jaa!=OTp>Y2
zDmkE<e~PbiXCm|Wfo4nB)7qxn^PB!kVt(=s8fA6HMOB4^!B}FJBmo*%3rbSI2xGVB
zv3|iSV|28y&z?8@%t}2%cJ0ySICj`i{Az}ZWlEB2v7?I?!5=F`RzjX;)Say5Gq^C?
zNPE-Lsl<wSn>?U;K**F*!}w{s0OWIVv`=(__Ti$lK3}DJiu9EtKL~&P(S;Fy+;l`)
z$Fxa7VX9Zq?%P6cZ!8JF=_Yk|yDu`=@k+aT7|>Riv7JS+f6Jc`D#<4MN3zUMtGa}h
zJ`(M%a(@h*-%PwYoGWxt1K5AZB*3V$p0`J37HEe~4u9yKG>ww(GD?{z_)(2E=ERoj
z(LX3pY+d%<3a0v)zQug(8KCdp0Cb$gNFaJ#%=|(o-$VspU1+d*+P3!cj&jJEtW6v1
zxaxTowZb;p#tkj&NR!f&#~CNG7G6WIIWT?wI?|U-bBUFsIKqR7BVkS3CFn`yj1Szg
z?^D-Gviuo}XGOr6!{)kaln$8L2Pob%F<3g=uN$-;5E~nyrVVP?8t^v-wu%ST8;r5~
z&Z(%DHZ|Q6`j}fKK$*F(ks|$of^kMhy!-6lpB8sXpzPR6Q2V?U-2L%juCaZ!9z;q<
z-<sVe8d!sp-Dv!X)%8E~jp~{%I56V=;Rn~bAEn(is3CFmPK)VqUE(_eCT{}Ko3&Zn
zB_4Y6ley?;i-gJgC{95}Y2Isy+wMhFMe*C)e|R8sMG(2qbXGv@SZ{6*vm)y80_q45
z!P_M_JnnCkIC-2dd6?4z9MHA$q%5lDPgtg$rKSr~O;RlB%ey*pYuJSvzx&4-1+FK=
zIXraznek?Xo${^fR-F{K#RFEvI-1_85T)uXF6&zBidP$+aiXupOwEPqo?$@})fzj(
z3Hf&IMx#a?m@NOLW1Pr8n!jjejD`0jxd)Tao-r8?N-|nl(6CZb@v+<6UpR{JP6sq@
z){b3azWjWHZg+9Z>8oCX<vF-d7%hw^Nxz*GE68}oVR<<8?kOx8)M9z!a+cBJgO3)k
zYa8{Dv*PeDHpJ8Ip;e>u#xaqG{@e7gZWq(QkD`BUrHheAONdA-hu=L0Po=YXGUj?C
zWEHBuIj<BxdGn*qSNC?2nJ8IZ56Y>|h(Im7&m>nlgYsAqqj5mKzHIdF1uPnMwTk4V
zc#7?qpsu5&eua-QtG$!Y?FdrOPr5uj`QCh$v~kz+a=j;`twIWw>5W8Zy_DU*7?ytC
zbj$L(11z3#P#U6Bfygbw;>+y${HvDpzeIA&{Em0=&g^TQ!<z<>!g!KcZ3!2^*6&7&
zH0hUXU{kDwXOU-CE29(Rv({5=NWWP?P$KhRwyON+Mv(v5LvkbKA3ZLA-6Qh9HG2G2
zKgsX*nEx4-@yhZ4vB4$sFPnA#MVkLvIO9);C#0F=j~^G-pQHQy?(0Lq4Pm7kcS8RQ
D(3R>!

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/ic_notify_halo_normal.png b/packages/SystemUI/res/drawable-xhdpi/ic_notify_halo_normal.png
new file mode 100755
index 0000000000000000000000000000000000000000..d491fd2e142c9d224c06110f757a4299c065f4f6
GIT binary patch
literal 5517
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
P00000NkvXXu0mjfgb`xN

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/ic_notify_halo_pressed.png b/packages/SystemUI/res/drawable-xhdpi/ic_notify_halo_pressed.png
new file mode 100755
index 0000000000000000000000000000000000000000..a1a171dd709ab21c9eee4a2d9b578275e4910a83
GIT binary patch
literal 5567
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
N002ovPDHLkV1mNVR5t(s

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/drawable-xhdpi/ic_qs_quickmemo.png b/packages/SystemUI/res/drawable-xhdpi/ic_qs_quickmemo.png
new file mode 100644
index 0000000000000000000000000000000000000000..9c17ced5daa5d78080f1c044805a960f1c262082
GIT binary patch
literal 721
zcmeAS@N?(olHy`uVBq!ia0vp^Mj*_=3?wxlRx|^t8v#BcuK$NA*s>t+BhZf?B|(0{
z3?Zw}{J**}fz#}vU--{_=JRj)ml~`q-Eza&>5rVm2cd6s4$pjE&2wApbJPSj(PPrP
zE_GFG51g!`>pji#Nv!MMSH11Y9*Sw1X2+SAFfcGCc)B=-cpQH_^>$FRfk4|zwk52d
znpeYCh-tHWt?UYW{qsUq#eefjGHb<Ko*cV4^WEM3lk+$IET5clOYL8g$+m5c3MI+M
z|8Sa=21x5>&)rbo=wp#xeL|4oMo&YoC({nuFtKTI;ZOXE`SoutzjWAT?o!(=t9)JM
zJDaVJxUXjNXz6xY&L{cc6kn%BkOSL)!HshlYAtI1uw!+bNkCDG^VH3A9;jZlnC9+N
z)jBEU-bNFZGb)qKEt8Gy&w873r~WcZJ@Zm>)_)JCljkLcf3Dc#wCMMTCc}fNnvZv$
zIS}J3kuoLkaP~~e=nv1ecK$q<loDauxAFK4gU2UXUfzBsS@vUg>GaD}8bj`{NqZ;1
z<MtPw{s>Y3s~6tPG}O1-XfJ46zCL5d!%4gMD!unrNOD{8b=J{4eJ74-D>g^3*X62`
ziFy<5eS{^sMtZ~Tch>u5<%`1^z82iJ^WLs|biH2eui5|ql|SNU)l+(BE82Vs7=H|&
Lu6{1-oD!M<()zoo

literal 0
HcmV?d00001

diff --git a/packages/SystemUI/res/layout/halo_bubble.xml b/packages/SystemUI/res/layout/halo_bubble.xml
new file mode 100644
index 0000000..add6355
--- /dev/null
+++ b/packages/SystemUI/res/layout/halo_bubble.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<FrameLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content">
+
+        <RelativeLayout
+            android:id="@+id/halo_content"      
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content">
+
+            <ImageView
+                android:id="@+id/halo_bg"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:src="@drawable/halo_bg"/>
+
+            <ImageView
+                android:id="@+id/app_icon"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"                
+                android:layout_centerVertical="true"
+                android:layout_centerHorizontal="true"/>
+
+            <ImageView
+                android:id="@+id/halo_overlay"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"                
+                android:layout_centerVertical="true"
+                android:layout_centerHorizontal="true"
+                android:alpha="0"/>
+
+        </RelativeLayout>
+
+</FrameLayout>
diff --git a/packages/SystemUI/res/layout/halo_number.xml b/packages/SystemUI/res/layout/halo_number.xml
new file mode 100644
index 0000000..cfd38a2
--- /dev/null
+++ b/packages/SystemUI/res/layout/halo_number.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content">
+
+    <TextView
+        android:id="@+id/number"
+        android:animateLayoutChanges="true"
+        android:layout_width="wrap_content" 
+        android:layout_height="wrap_content"
+        android:paddingLeft="5dp"
+        android:paddingRight="5dp"
+        android:paddingTop="2dp"
+        android:paddingBottom="2dp"
+        android:background="@drawable/halo_number"
+        android:textColor="#fff"
+        android:textStyle="bold"
+        android:textSize="16sp"/>
+
+</LinearLayout>
diff --git a/packages/SystemUI/res/layout/halo_speech.xml b/packages/SystemUI/res/layout/halo_speech.xml
new file mode 100644
index 0000000..b0ff2c0
--- /dev/null
+++ b/packages/SystemUI/res/layout/halo_speech.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<LinearLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content">
+
+    <RelativeLayout
+        android:layout_width="@dimen/halo_content_max_width"
+        android:layout_height="wrap_content">
+
+        <RelativeLayout
+            android:id="@+id/ticker"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content">
+
+            <TextView
+                android:id="@+id/bubble_r"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:paddingLeft="20dp"
+                android:paddingRight="20dp"
+                android:paddingTop="17dp"
+                android:paddingBottom="30dp"
+                android:background="@drawable/bubble_black_r"
+                android:singleLine="false"
+                android:textColor="#ffffff"
+                android:maxLines = "3"
+                android:visibility="gone"/>
+
+            <TextView
+                android:id="@+id/bubble_l"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:paddingLeft="20dp"
+                android:paddingRight="20dp"
+                android:paddingTop="17dp"
+                android:paddingBottom="30dp"
+                android:background="@drawable/bubble_black_l"
+                android:singleLine="false"
+                android:textColor="#ffffff"
+                android:maxLines = "3"
+                android:visibility="gone"/>
+
+        </RelativeLayout>
+
+    </RelativeLayout>
+
+</LinearLayout>
diff --git a/packages/SystemUI/res/layout/halo_trigger.xml b/packages/SystemUI/res/layout/halo_trigger.xml
new file mode 100644
index 0000000..f16a4a7
--- /dev/null
+++ b/packages/SystemUI/res/layout/halo_trigger.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<com.android.systemui.statusbar.halo.Halo
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent">
+</com.android.systemui.statusbar.halo.Halo>
diff --git a/packages/SystemUI/res/layout/quick_settings_tile_quickmemo.xml b/packages/SystemUI/res/layout/quick_settings_tile_quickmemo.xml
new file mode 100644
index 0000000..bf61913
--- /dev/null
+++ b/packages/SystemUI/res/layout/quick_settings_tile_quickmemo.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2012 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<TextView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    style="@style/TextAppearance.QuickSettings.TileView"
+    android:id="@+id/quickmemo_tileview"
+    android:layout_width="wrap_content"
+    android:layout_height="wrap_content"
+    android:layout_gravity="center"
+    android:gravity="center"
+    android:drawableTop="@drawable/ic_qs_quickmemo"
+    />
diff --git a/packages/SystemUI/res/layout/status_bar_expanded_header.xml b/packages/SystemUI/res/layout/status_bar_expanded_header.xml
index 1d26558..fb8d2e3 100644
--- a/packages/SystemUI/res/layout/status_bar_expanded_header.xml
+++ b/packages/SystemUI/res/layout/status_bar_expanded_header.xml
@@ -74,9 +74,19 @@
         android:padding="2dp"
         />
 
+    <ImageView android:id="@+id/halo_button"
+        android:layout_width="50dp"
+        android:layout_height="50dp"
+        android:scaleType="center"
+        android:src="@drawable/ic_notify_halo_normal"
+        android:background="@drawable/ic_notify_button_bg"
+        android:contentDescription="@string/accessibility_halo"
+        />     
+
     <ImageView android:id="@+id/clear_all_button"
         android:layout_width="50dp"
         android:layout_height="50dp"
+        android:layout_marginStart="5dp"
         android:scaleType="center"
         android:src="@drawable/ic_notify_clear"
         android:contentDescription="@string/accessibility_clear_all"
@@ -85,7 +95,7 @@
     <FrameLayout android:id="@+id/settings_button_holder"
         android:layout_width="50dp"
         android:layout_height="50dp"
-        android:layout_marginStart="12dp"
+        android:layout_marginStart="5dp"
         >
         <ImageView android:id="@+id/settings_button"
             android:layout_width="50dp"
diff --git a/packages/SystemUI/res/menu/recent_popup_menu.xml b/packages/SystemUI/res/menu/recent_popup_menu.xml
index eecfb9a..b992707 100644
--- a/packages/SystemUI/res/menu/recent_popup_menu.xml
+++ b/packages/SystemUI/res/menu/recent_popup_menu.xml
@@ -20,4 +20,5 @@
 <menu xmlns:android="http://schemas.android.com/apk/res/android">
     <item android:id="@+id/recent_remove_item" android:title="@string/status_bar_recent_remove_item_title" />
     <item android:id="@+id/recent_inspect_item" android:title="@string/status_bar_recent_inspect_item_title" />
+    <item android:id="@+id/recent_launch_floating" android:title="@string/status_bar_recent_floating_item_title" />
 </menu>
diff --git a/packages/SystemUI/res/values-es/strings.xml b/packages/SystemUI/res/values-es/strings.xml
index 6e5be0a..53b5f27 100644
--- a/packages/SystemUI/res/values-es/strings.xml
+++ b/packages/SystemUI/res/values-es/strings.xml
@@ -25,6 +25,7 @@
     <string name="status_bar_please_disturb_button" msgid="3345398298841572813">"Mostrar notificaciones"</string>
     <string name="status_bar_recent_remove_item_title" msgid="6026395868129852968">"Eliminar de la lista"</string>
     <string name="status_bar_recent_inspect_item_title" msgid="7793624864528818569">"Informacin de la aplicacin"</string>
+    <string name="status_bar_recent_floating_item_title">Modo flotante</string>
     <string name="status_bar_no_recent_apps" msgid="6576392951053994640">"No hay aplicaciones recientes."</string>
     <string name="status_bar_accessibility_dismiss_recents" msgid="4576076075226540105">"Ignorar aplicaciones recientes"</string>
   <plurals name="status_bar_accessibility_recent_apps">
diff --git a/packages/SystemUI/res/values-land/dimens.xml b/packages/SystemUI/res/values-land/dimens.xml
index ab71371..3d42a3a 100644
--- a/packages/SystemUI/res/values-land/dimens.xml
+++ b/packages/SystemUI/res/values-land/dimens.xml
@@ -40,4 +40,8 @@
 
     <!-- The fixed height of each tile -->
     <dimen name="quick_settings_cell_height">100dp</dimen>
+
+    <dimen name="pie_panel_padding">100dp</dimen>
+
+    <dimen name="halo_content_max_width">350dp</dimen>
 </resources>
diff --git a/packages/SystemUI/res/values/dimens.xml b/packages/SystemUI/res/values/dimens.xml
index 77d0452..e9e4d12 100644
--- a/packages/SystemUI/res/values/dimens.xml
+++ b/packages/SystemUI/res/values/dimens.xml
@@ -244,4 +244,7 @@
 
     <dimen name="pie_sysinfo_radius">165dp</dimen>
     <dimen name="pie_sysinfo_height">85sp</dimen>
+
+    <dimen name="halo_content_max_width">250dp</dimen>
+
 </resources>
diff --git a/packages/SystemUI/res/values/strings.xml b/packages/SystemUI/res/values/strings.xml
index 5767e63..0aa3336 100644
--- a/packages/SystemUI/res/values/strings.xml
+++ b/packages/SystemUI/res/values/strings.xml
@@ -41,6 +41,9 @@
     <!-- Title shown in recents popup for inspecting an application's properties -->
     <string name="status_bar_recent_inspect_item_title">App info</string>
 
+    <!-- Title shown in recents popup for showing app in floating mode -->
+    <string name="status_bar_recent_floating_item_title">Floating mode</string>
+
     <!-- Message shown in the middle of the screen after clicking on the recent apps button
          when there are no recent apps to show. Also used for accessibility. [CHAR LIMIT=45]-->
     <string name="status_bar_no_recent_apps">No recent apps</string>
@@ -429,6 +432,9 @@
     <!-- Notification text: when GPS has found a fix [CHAR LIMIT=50] -->
     <string name="gps_notification_found_text">Location set by GPS</string>
 
+    <!-- Content description of the halo button in the notification panel for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
+    <string name="accessibility_halo">Create notification halo.</string>
+
     <!-- Content description of the clear button in the notification panel for accessibility (not shown on the screen). [CHAR LIMIT=NONE] -->
     <string name="accessibility_clear_all">Clear all notifications.</string>
 
@@ -488,6 +494,8 @@
     <string name="quick_settings_location_label">Location in use</string>
     <!-- QuickSettings: Media device [CHAR LIMIT=NONE] -->
     <string name="quick_settings_media_device_label">Media device</string>
+    <!-- QuickSettings: QuickMemo [CHAR LIMIT=NONE] -->
+    <string name="quick_settings_quickmemo_label">QuickMemo</string>
     <!-- QuickSettings: RSSI [CHAR LIMIT=NONE] -->
     <string name="quick_settings_rssi_label">RSSI</string>
     <!-- QuickSettings: RSSI (No network) [CHAR LIMIT=NONE] -->
diff --git a/packages/SystemUI/src/com/android/systemui/Transparent.java b/packages/SystemUI/src/com/android/systemui/Transparent.java
new file mode 100644
index 0000000..7d36b3f
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/Transparent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2013 ParanoidAndroid Project.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui;
+
+import android.app.LayerActivity;
+
+public class Transparent extends LayerActivity {
+
+}
diff --git a/packages/SystemUI/src/com/android/systemui/quicksettings/QuickMemoTile.java b/packages/SystemUI/src/com/android/systemui/quicksettings/QuickMemoTile.java
new file mode 100644
index 0000000..a905e7a
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/quicksettings/QuickMemoTile.java
@@ -0,0 +1,41 @@
+
+package com.android.systemui.quicksettings;
+
+import android.content.Context;
+import android.content.Intent;
+import android.view.View;
+
+import com.android.systemui.R;
+import com.android.systemui.statusbar.phone.QuickSettingsController;
+
+public class QuickMemoTile extends QuickSettingsTile {
+
+    public QuickMemoTile(Context context, QuickSettingsController qsc) {
+        super(context, qsc);
+
+        mOnClick = new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mQsc.mBar.collapseAllPanels(true);
+                mContext.sendBroadcast(new Intent("com.lge.QuickClip.action.START_QUICKCLIP"));
+            }
+        };
+    }
+
+    @Override
+    void onPostCreate() {
+        updateTile();
+        super.onPostCreate();
+    }
+
+    @Override
+    public void updateResources() {
+        updateTile();
+        super.updateResources();
+    }
+
+    private synchronized void updateTile() {
+        mDrawable = R.drawable.ic_qs_quickmemo;
+        mLabel = mContext.getString(R.string.quick_settings_quickmemo_label);
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
index d212787..5512ee3 100644
--- a/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/recent/RecentsPanelView.java
@@ -805,6 +805,16 @@ public class RecentsPanelView extends FrameLayout implements OnItemClickListener
                     } else {
                         throw new IllegalStateException("Oops, no tag on view " + selectedView);
                     }
+                } else if (item.getItemId() == R.id.recent_launch_floating) {
+                    ViewHolder viewHolder = (ViewHolder) selectedView.getTag();
+                    if (viewHolder != null) {
+                        final TaskDescription ad = viewHolder.taskDescription;
+                        Intent intent = ad.intent;
+                        intent.addFlags(Intent.FLAG_FLOATING_WINDOW
+                                | Intent.FLAG_ACTIVITY_CLEAR_TASK);
+                        dismissAndGoBack();
+                        getContext().startActivity(intent);
+                    }
                 } else {
                     return false;
                 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
index 856b3d5..cba1f0c 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/BaseStatusBar.java
@@ -50,7 +50,12 @@ import android.content.pm.PackageManager.NameNotFoundException;
 import android.content.res.Resources;
 import android.database.ContentObserver;
 import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
 import android.graphics.Paint;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffXfermode;
 import android.graphics.Rect;
 import android.net.Uri;
 import android.os.Build;
@@ -83,6 +88,13 @@ import android.widget.PopupMenu;
 import android.widget.RemoteViews;
 import android.widget.TextView;
 
+import com.android.systemui.statusbar.halo.Halo;
+import com.android.systemui.statusbar.phone.QuickSettingsContainerView;
+import com.android.systemui.statusbar.phone.Ticker;
+import com.android.systemui.statusbar.policy.BatteryController;
+import com.android.systemui.statusbar.policy.Clock;
+import com.android.systemui.statusbar.policy.NetworkController;
+
 import java.util.ArrayList;
 import java.util.Locale;
 
@@ -168,6 +180,26 @@ public abstract class BaseStatusBar extends SystemUI implements
     private ArrayList<NavigationBarCallback> mNavigationCallbacks =
             new ArrayList<NavigationBarCallback>();
 
+    // Halo
+    protected Halo mHalo = null;
+    protected Ticker mTicker;
+    protected boolean mHaloActive;
+    protected boolean mHaloTaskerActive = false;
+    protected ImageView mHaloButton;
+    protected boolean mHaloButtonVisible = true;
+
+    // Policy
+    public NetworkController mNetworkController;
+    public BatteryController mBatteryController;
+    public SignalClusterView mSignalCluster;
+    public Clock mClock;
+
+    // left-hand icons 
+    public LinearLayout mStatusIcons;
+
+    // Statusbar view container
+    public ViewGroup mBarView;
+
     // Pie Control
     protected PieController mPieController;
 
@@ -191,6 +223,36 @@ public abstract class BaseStatusBar extends SystemUI implements
     private boolean mDeviceProvisioned = false;
     private int mAutoCollapseBehaviour;
 
+    private boolean mShowNotificationCounts;
+
+    public Ticker getTicker() {
+        return mTicker;
+    }
+
+    public void collapse() {
+    }
+
+    public QuickSettingsContainerView getQuickSettingsPanel() {
+        // This method should be overriden
+        return null;
+    }
+
+    public Handler getHandler() {
+        return mHandler;
+    }
+
+    public IStatusBarService getService() {
+        return mBarService;
+    }
+
+    public NotificationData getNotificationData() {
+        return mNotificationData;
+    }
+
+    public NotificationRowLayout getNotificationRowLayout() {
+        return mPile;
+    }
+
     public IStatusBarService getStatusBarService() {
         return mBarService;
     }
@@ -305,6 +367,9 @@ public abstract class BaseStatusBar extends SystemUI implements
             // If the system process isn't there we're doomed anyway.
         }
 
+        mHaloActive = Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.HALO_ACTIVE, 0) == 1;
+
         createAndAddWindows();
 
         disable(switches[0]);
@@ -369,10 +434,57 @@ public abstract class BaseStatusBar extends SystemUI implements
                         mPieController.userSwitched(mCurrentUserId);
                     }
                 }
-            }
-        }, filter);
+            }}, filter);
 
         mLocale = mContext.getResources().getConfiguration().locale;
+
+        // Listen for HALO state
+        mContext.getContentResolver().registerContentObserver(
+                Settings.System.getUriFor(Settings.System.HALO_ACTIVE), false, new ContentObserver(new Handler()) {
+            @Override
+            public void onChange(boolean selfChange) {
+                updateHalo();
+            }});
+
+        updateHalo();
+    }
+
+    public void setHaloTaskerActive(boolean haloTaskerActive, boolean updateNotificationIcons) {
+        mHaloTaskerActive = haloTaskerActive;
+        if (updateNotificationIcons) {
+            updateNotificationIcons();
+        }
+    }
+
+    protected void updateHaloButton() {
+        if (mHaloButton != null) {
+            mHaloButton.setVisibility(mHaloButtonVisible && !mHaloActive ? View.VISIBLE : View.GONE);
+        }
+    }
+
+    protected void updateHalo() {
+        mHaloActive = Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.HALO_ACTIVE, 0) == 1;
+
+        updateHaloButton();
+
+        if (mHaloActive) {
+            if (mHalo == null) {
+                LayoutInflater inflater = (LayoutInflater) mContext
+                        .getSystemService(Context.LAYOUT_INFLATER_SERVICE); 
+                mHalo = (Halo)inflater.inflate(R.layout.halo_trigger, null);
+                mHalo.setLayerType (View.LAYER_TYPE_HARDWARE, null);
+                WindowManager.LayoutParams params = mHalo.getWMParams();
+                mWindowManager.addView(mHalo,params);
+                mHalo.setStatusBar(this);
+            }
+        } else {
+            if (mHalo != null) {
+                mHalo.cleanUp();
+                mWindowManager.removeView(mHalo);
+                mHalo = null;
+            }
+        }
     }
 
     public void userSwitched(int newUserId) {
@@ -907,11 +1019,12 @@ public abstract class BaseStatusBar extends SystemUI implements
         return new NotificationClicker(intent, pkg, tag, id);
     }
 
-    private class NotificationClicker implements View.OnClickListener {
-        private PendingIntent mIntent;
-        private String mPkg;
-        private String mTag;
-        private int mId;
+    public class NotificationClicker implements View.OnClickListener {
+        public PendingIntent mIntent;
+        public String mPkg;
+        public String mTag;
+        public int mId;
+        public boolean mFloat;
 
         NotificationClicker(PendingIntent intent, String pkg, String tag, int id) {
             mIntent = intent;
@@ -920,6 +1033,10 @@ public abstract class BaseStatusBar extends SystemUI implements
             mId = id;
         }
 
+        public void makeFloating(boolean floating) {
+            mFloat = floating;
+        }
+
         public void onClick(View v) {
             try {
                 // The intent we are sending is for the application, which
@@ -934,9 +1051,17 @@ public abstract class BaseStatusBar extends SystemUI implements
             }
 
             if (mIntent != null) {
+
+                if (mFloat && !"android".equals(mPkg)) {
+                    Intent transparent = new Intent(mContext, com.android.systemui.Transparent.class);
+                    transparent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_FLOATING_WINDOW);
+                    mContext.startActivity(transparent);
+                }
+
                 int[] pos = new int[2];
                 v.getLocationOnScreen(pos);
                 Intent overlay = new Intent();
+                if (mFloat) overlay.addFlags(Intent.FLAG_FLOATING_WINDOW | Intent.FLAG_ACTIVITY_CLEAR_TASK);
                 overlay.setSourceBounds(
                         new Rect(pos[0], pos[1], pos[0]+v.getWidth(), pos[1]+v.getHeight()));
                 try {
@@ -1034,6 +1159,41 @@ public abstract class BaseStatusBar extends SystemUI implements
         }
     }
 
+    private Bitmap createRoundIcon(StatusBarNotification notification) {
+        // Construct the round icon
+        BitmapDrawable bd = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.halo_bg);
+        int iconSize = bd.getBitmap().getWidth();
+        int smallIconSize = mContext.getResources().getDimensionPixelSize(R.dimen.status_bar_icon_size);        
+        Bitmap roundIcon = Bitmap.createBitmap(iconSize, iconSize, Bitmap.Config.ARGB_8888);
+        Canvas canvas = new Canvas(roundIcon);
+        canvas.drawARGB(0, 0, 0, 0);
+
+        if (notification.getNotification().largeIcon != null) {           
+            Paint smoothingPaint = new Paint();
+            smoothingPaint.setAntiAlias(true);
+            smoothingPaint.setFilterBitmap(true);
+            smoothingPaint.setDither(true);
+            canvas.drawCircle(iconSize / 2, iconSize / 2, iconSize / 2.3f, smoothingPaint);
+            smoothingPaint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
+            Bitmap scaledBitmap = Bitmap.createScaledBitmap(notification.getNotification().largeIcon, iconSize, iconSize, true);
+            canvas.drawBitmap(scaledBitmap, null, new Rect(0, 0,
+                    iconSize, iconSize), smoothingPaint);
+        } else {
+            try {
+                Drawable icon = StatusBarIconView.getIcon(mContext,
+                    new StatusBarIcon(notification.getPackageName(), notification.getUser(), notification.getNotification().icon,
+                    notification.getNotification().iconLevel, 0, notification.getNotification().tickerText)); 
+                if (icon == null) icon = mContext.getPackageManager().getApplicationIcon(notification.getPackageName());
+                int margin = (iconSize - smallIconSize) / 2;
+                icon.setBounds(margin, margin, iconSize - margin, iconSize - margin);
+                icon.draw(canvas);
+            } catch (Exception e) {
+                // NameNotFoundException
+            }
+        }
+        return roundIcon;
+    }
+
     protected StatusBarIconView addNotificationViews(IBinder key,
             StatusBarNotification notification) {
         if (DEBUG) {
@@ -1055,8 +1215,19 @@ public abstract class BaseStatusBar extends SystemUI implements
             handleNotificationError(key, notification, "Couldn't create icon: " + ic);
             return null;
         }
+
+        NotificationData.Entry entry = new NotificationData.Entry(key, notification, iconView,
+                createRoundIcon(notification));
+        entry.hide = entry.notification.getPackageName().equals("com.paranoid.halo");
+
+        final PendingIntent contentIntent = notification.getNotification().contentIntent;
+        if (contentIntent != null) {
+            entry.floatingIntent = makeClicker(contentIntent,
+                    notification.getPackageName(), notification.getTag(), notification.getId());
+            entry.floatingIntent.makeFloating(true);
+        }
+
         // Construct the expanded view.
-        NotificationData.Entry entry = new NotificationData.Entry(key, notification, iconView);
         if (!inflateViews(entry, mPile)) {
             handleNotificationError(key, notification, "Couldn't expand RemoteViews for: "
                     + notification);
@@ -1087,6 +1258,7 @@ public abstract class BaseStatusBar extends SystemUI implements
             lp.height = rowHeight;
         }
         entry.row.setLayoutParams(lp);
+        if (entry.hide) entry.row.setVisibility(View.GONE);
         return expand;
     }
 
@@ -1177,9 +1349,9 @@ public abstract class BaseStatusBar extends SystemUI implements
                 && notification.getScore() == oldNotification.getScore();
                 // score now encompasses/supersedes isOngoing()
 
-        boolean updateTicker = notification.getNotification().tickerText != null
+        boolean updateTicker = (notification.getNotification().tickerText != null
                 && !TextUtils.equals(notification.getNotification().tickerText,
-                        oldEntry.notification.getNotification().tickerText);
+                        oldEntry.notification.getNotification().tickerText)) || mHaloActive;
         boolean isTopAnyway = isTopNotification(rowParent, oldEntry);
         if (contentsUnchanged && bigContentsUnchanged && (orderUnchanged || isTopAnyway)) {
             if (DEBUG) Slog.d(TAG, "reusing notification for key: " + key);
@@ -1190,15 +1362,22 @@ public abstract class BaseStatusBar extends SystemUI implements
                 if (bigContentView != null && oldEntry.getLargeView() != null) {
                     bigContentView.reapply(mContext, oldEntry.getLargeView(), mOnClickHandler);
                 }
-                // update the contentIntent
+                // update contentIntent and floatingIntent
                 final PendingIntent contentIntent = notification.getNotification().contentIntent;
                 if (contentIntent != null) {
                     final View.OnClickListener listener = makeClicker(contentIntent,
                             notification.getPackageName(), notification.getTag(), notification.getId());
                     oldEntry.content.setOnClickListener(listener);
+                    oldEntry.floatingIntent = makeClicker(contentIntent,
+                            notification.getPackageName(), notification.getTag(), notification.getId());
+                    oldEntry.floatingIntent.makeFloating(true);
                 } else {
                     oldEntry.content.setOnClickListener(null);
+                    oldEntry.floatingIntent = null;
                 }
+                // Update the roundIcon
+                oldEntry.roundIcon = createRoundIcon(notification);
+
                 // Update the icon.
                 final StatusBarIcon ic = new StatusBarIcon(notification.getPackageName(),
                         notification.getUser(),
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
index a6c3526..3903f53 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
@@ -17,10 +17,13 @@
 package com.android.systemui.statusbar;
 
 import android.service.notification.StatusBarNotification;
+import android.app.Notification;
+import android.graphics.Bitmap;
 import android.os.IBinder;
 import android.view.View;
 import android.widget.ImageView;
 
+import com.android.systemui.statusbar.BaseStatusBar.NotificationClicker;
 import com.android.systemui.R;
 
 import java.util.Comparator;
@@ -35,53 +38,83 @@ public class NotificationData {
         public StatusBarNotification notification;
         public StatusBarIconView icon;
         public View row; // the outer expanded view
-        public View content; // takes the click events and sends the PendingIntent
+        public View content; // takes the click events and sends the
+                             // PendingIntent
         public View expanded; // the inflated RemoteViews
         public ImageView largeIcon;
+        protected boolean hide = false;
+        protected Bitmap roundIcon;
         protected View expandedLarge;
-        public Entry() {}
+        protected NotificationClicker floatingIntent;
+
+        public Entry() {
+        }
+
         public Entry(IBinder key, StatusBarNotification n, StatusBarIconView ic) {
             this.key = key;
             this.notification = n;
             this.icon = ic;
         }
+
+        public Entry(IBinder key, StatusBarNotification n, StatusBarIconView ic, Bitmap ri) {
+            this.key = key;
+            this.notification = n;
+            this.icon = ic;
+            this.roundIcon = ri;
+        }
+
         public void setLargeView(View expandedLarge) {
             this.expandedLarge = expandedLarge;
             writeBooleanTag(row, R.id.expandable_tag, expandedLarge != null);
         }
+
         public View getLargeView() {
             return expandedLarge;
         }
+
+        public NotificationClicker getFloatingIntent() {
+            return floatingIntent;
+        }
+
+        public Bitmap getRoundIcon() {
+            return roundIcon;
+        }
+
         /**
          * Return whether the entry can be expanded.
          */
         public boolean expandable() {
             return NotificationData.getIsExpandable(row);
         }
+
         /**
          * Return whether the entry has been manually expanded by the user.
          */
         public boolean userExpanded() {
             return NotificationData.getUserExpanded(row);
         }
+
         /**
          * Return whether the entry has been manually dismissed by the user.
          */
         public boolean userDismissed() {
             return NotificationData.getUserDismissed(row);
         }
+
         /**
          * Set the flag indicating that this was manually expanded by the user.
          */
         public boolean setUserExpanded(boolean userExpanded) {
             return NotificationData.setUserExpanded(row, userExpanded);
         }
+
         /**
          * Return whether the entry is being touched by the user.
          */
         public boolean userLocked() {
             return NotificationData.getUserLocked(row);
         }
+
         /**
          * Set the flag indicating that this is being touched by the user.
          */
@@ -89,6 +122,7 @@ public class NotificationData {
             return NotificationData.setUserLocked(row, userLocked);
         }
     }
+
     private final ArrayList<Entry> mEntries = new ArrayList<Entry>();
     private final Comparator<Entry> mEntryCmp = new Comparator<Entry>() {
         // sort first by score, then by when
@@ -97,8 +131,8 @@ public class NotificationData {
             final StatusBarNotification nb = b.notification;
             int d = na.getScore() - nb.getScore();
             return (d != 0)
-                ? d
-                : (int)(na.getNotification().when - nb.getNotification().when);
+                    ? d
+                    : (int) (na.getNotification().when - nb.getNotification().when);
         }
     };
 
@@ -122,7 +156,7 @@ public class NotificationData {
     public int add(Entry entry) {
         int i;
         int N = mEntries.size();
-        for (i=0; i<N; i++) {
+        for (i = 0; i < N; i++) {
             if (mEntryCmp.compare(mEntries.get(i), entry) > 0) {
                 break;
             }
@@ -182,7 +216,7 @@ public class NotificationData {
         return false;
     }
 
-    protected static boolean readBooleanTag(View view, int id)  {
+    protected static boolean readBooleanTag(View view, int id) {
         if (view != null) {
             Object value = view.getTag(id);
             return value != null && value instanceof Boolean && ((Boolean) value).booleanValue();
@@ -190,7 +224,7 @@ public class NotificationData {
         return false;
     }
 
-    protected static boolean writeBooleanTag(View view, int id, boolean value)  {
+    protected static boolean writeBooleanTag(View view, int id, boolean value) {
         if (view != null) {
             view.setTag(id, Boolean.valueOf(value));
             return value;
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/halo/CustomObjectAnimator.java b/packages/SystemUI/src/com/android/systemui/statusbar/halo/CustomObjectAnimator.java
new file mode 100644
index 0000000..89323bb
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/halo/CustomObjectAnimator.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2013 ParanoidAndroid.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.halo;
+
+import android.os.Handler;
+import android.animation.ObjectAnimator;
+import android.animation.TimeInterpolator;
+import android.animation.ValueAnimator.AnimatorUpdateListener;
+import android.animation.ValueAnimator;
+import android.animation.Animator;
+import android.view.View;
+
+public class CustomObjectAnimator {
+
+    private View rootView;
+    private Handler handler = new Handler();
+    private ObjectAnimator animator;
+
+    public CustomObjectAnimator(View root) {
+        rootView = root;
+    }
+
+    public void animate(ObjectAnimator newInstance, TimeInterpolator interpolator, AnimatorUpdateListener update) {
+        runAnimation(newInstance, interpolator, update, null);
+    }
+
+    public void animate(final ObjectAnimator newInstance, final TimeInterpolator interpolator,
+            final AnimatorUpdateListener update, long startDelay, final Runnable executeAfter) {
+
+        handler.postDelayed(new Runnable() {
+            public void run() {
+                runAnimation(newInstance, interpolator, update, executeAfter);
+            }}, startDelay);
+    }
+
+    private void runAnimation(ObjectAnimator newInstance, TimeInterpolator interpolator,
+            AnimatorUpdateListener update, final Runnable executeAfter) {
+
+        // Terminate old instance, if present
+        cancel(false);
+        animator = newInstance;
+
+        // Invalidate
+        if (update == null) {
+            animator.addUpdateListener(new AnimatorUpdateListener() {
+                @Override
+                public void onAnimationUpdate(ValueAnimator animation) {
+                    rootView.invalidate();
+                }});
+        } else {
+            animator.addUpdateListener(update);
+        }
+        
+        animator.setInterpolator(interpolator);
+
+        if (executeAfter != null) {
+            animator.addListener(new Animator.AnimatorListener() {
+                boolean canceled = false;
+                @Override public void onAnimationRepeat(Animator animation) {}
+                @Override public void onAnimationStart(Animator animation) {}
+                @Override public void onAnimationCancel(Animator animation) {
+                    canceled = true;
+                }
+                @Override public void onAnimationEnd(Animator animation) {
+                    if (!canceled) executeAfter.run();
+                }});
+        }
+        
+        animator.start();
+    }
+
+    public void cancel(boolean unschedule) {
+        if (unschedule) handler.removeCallbacksAndMessages(null);
+        if (animator != null) animator.cancel();
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/halo/Halo.java b/packages/SystemUI/src/com/android/systemui/statusbar/halo/Halo.java
new file mode 100644
index 0000000..57e538d
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/halo/Halo.java
@@ -0,0 +1,1078 @@
+/*
+ * Copyright (C) 2013 ParanoidAndroid.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.halo;
+
+import android.app.Activity;
+import android.app.ActivityManagerNative;
+import android.app.KeyguardManager;
+import android.app.PendingIntent;
+import android.app.Notification;
+import android.app.INotificationManager;
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.AnimatorSet;
+import android.animation.ObjectAnimator;
+import android.animation.ValueAnimator;
+import android.animation.ValueAnimator.AnimatorUpdateListener;
+import android.animation.Keyframe;
+import android.animation.PropertyValuesHolder;
+import android.content.Context;
+import android.content.ContentResolver;
+import android.content.res.Configuration;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.database.ContentObserver;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Rect;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.Point;
+import android.graphics.PixelFormat;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.PorterDuffColorFilter;
+import android.graphics.Matrix;
+import android.os.Handler;
+import android.os.RemoteException;
+import android.os.Vibrator;
+import android.os.ServiceManager;
+import android.provider.Settings;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.util.Log;
+import android.view.animation.Animation;
+import android.view.animation.Animation.AnimationListener;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.OvershootInterpolator;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.TranslateAnimation;
+import android.animation.TimeInterpolator;
+import android.view.Display;
+import android.view.View;
+import android.view.Gravity;
+import android.view.GestureDetector;
+import android.view.ViewGroup;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.WindowManager;
+import android.view.View.OnTouchListener;
+import android.view.ViewTreeObserver;
+import android.view.ViewTreeObserver.OnGlobalLayoutListener;
+import android.view.SoundEffectConstants;
+import android.view.Window;
+import android.view.WindowManager;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.ImageView.ScaleType;
+import android.widget.TextView;
+import android.widget.LinearLayout;
+import android.widget.RelativeLayout;
+import android.widget.ScrollView;
+import android.service.notification.StatusBarNotification;
+
+import com.android.systemui.R;
+import com.android.systemui.statusbar.BaseStatusBar.NotificationClicker;
+import com.android.internal.statusbar.StatusBarIcon;
+import com.android.systemui.statusbar.StatusBarIconView;
+import com.android.systemui.statusbar.NotificationData;
+import com.android.systemui.statusbar.BaseStatusBar;
+import com.android.systemui.statusbar.phone.Ticker;
+
+public class Halo extends FrameLayout implements Ticker.TickerCallback {
+
+    public static final String TAG = "HaloLauncher";
+
+    enum State {
+        IDLE,
+        HIDDEN,
+        DRAG,
+        GESTURES
+    }
+
+    enum Gesture {
+        NONE,
+        TASK,
+        UP,
+        DOWN
+    }
+
+    private Context mContext;
+    private PackageManager mPm;
+    private Handler mHandler;
+    private BaseStatusBar mBar;
+    private WindowManager mWindowManager;
+    private Display mDisplay;
+    private Vibrator mVibrator;
+    private LayoutInflater mInflater;
+    private INotificationManager mNotificationManager;
+    private SettingsObserver mSettingsObserver;
+    private GestureDetector mGestureDetector;
+
+    private HaloEffect mEffect;
+    private WindowManager.LayoutParams mTriggerPos;
+    private State mState = State.IDLE;
+    private Gesture mGesture = Gesture.NONE;
+
+    private View mRoot;
+    private View mContent, mHaloContent;
+    private NotificationData.Entry mLastNotificationEntry = null;
+    private NotificationData.Entry mCurrentNotficationEntry = null;
+    private NotificationClicker mContentIntent, mTaskIntent;
+    private NotificationData mNotificationData;
+    private String mNotificationText = "";
+
+    private Paint mPaintHoloBlue = new Paint();
+    private Paint mPaintWhite = new Paint();
+    private Paint mPaintHoloRed = new Paint();
+
+    private boolean isBeingDragged = false;
+    private boolean mHapticFeedback;
+    private boolean mHideTicker;
+    private boolean mFirstStart = true;
+    private boolean mInitialized = false;
+    private boolean mTickerLeft = true;
+    private boolean mIsNotificationNew = true;
+    private boolean mOverX = false;
+    private boolean mInteractionReversed = true;
+
+    private int mIconSize, mIconHalfSize;
+    private int mScreenWidth, mScreenHeight;
+    private int mKillX, mKillY;
+    private int mMarkerIndex = -1;
+
+    private int oldIconIndex = -1;
+    private float initialX = 0;
+    private float initialY = 0;
+    private boolean hiddenState = false;
+
+    private final class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.HALO_REVERSED), false, this);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.HALO_HIDE), false, this);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.HAPTIC_FEEDBACK_ENABLED), false, this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            mInteractionReversed =
+                    Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_REVERSED, 1) == 1;
+            mHideTicker =
+                    Settings.System.getInt(mContext.getContentResolver(), Settings.System.HALO_HIDE, 0) == 1;
+            mHapticFeedback = Settings.System.getInt(mContext.getContentResolver(),
+                    Settings.System.HAPTIC_FEEDBACK_ENABLED, 1) != 0;
+
+            if (!selfChange) {
+                mEffect.wake();
+                mEffect.ping(mPaintHoloBlue, HaloEffect.WAKE_TIME);
+                mEffect.nap(HaloEffect.SNAP_TIME + 1000);
+                if (mHideTicker) mEffect.sleep(HaloEffect.SNAP_TIME + HaloEffect.NAP_TIME + 2500, HaloEffect.SLEEP_TIME);
+            }
+        }
+    }
+
+    public Halo(Context context, AttributeSet attrs) {
+        this(context, attrs, 0);
+    }
+
+    public Halo(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        mContext = context;
+        mPm = mContext.getPackageManager();
+        mWindowManager = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
+        mInflater = (LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        mVibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
+        mNotificationManager = INotificationManager.Stub.asInterface(
+                ServiceManager.getService(Context.NOTIFICATION_SERVICE));
+        mDisplay = mWindowManager.getDefaultDisplay();
+        mGestureDetector = new GestureDetector(mContext, new GestureListener());
+        mHandler = new Handler();
+        mRoot = this;
+
+        mSettingsObserver = new SettingsObserver(new Handler());
+        mSettingsObserver.observe();
+        mSettingsObserver.onChange(true);
+
+        // Init variables
+        BitmapDrawable bd = (BitmapDrawable) mContext.getResources().getDrawable(R.drawable.halo_bg);
+        mIconSize = bd.getBitmap().getWidth();
+        mIconHalfSize = mIconSize / 2;
+
+        mTriggerPos = getWMParams();
+
+        // Init colors
+        mPaintHoloBlue.setAntiAlias(true);
+        mPaintHoloBlue.setColor(0xff33b5e5);
+        mPaintWhite.setAntiAlias(true);
+        mPaintWhite.setColor(0xfff0f0f0);
+        mPaintHoloRed.setAntiAlias(true);
+        mPaintHoloRed.setColor(0xffcc0000);
+
+        // Create effect layer
+        mEffect = new HaloEffect(mContext);
+        mEffect.setLayerType (View.LAYER_TYPE_HARDWARE, null);
+        mEffect.pingMinRadius = mIconHalfSize;
+        mEffect.pingMaxRadius = (int)(mIconSize * 1.1f);
+        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
+                WindowManager.LayoutParams.MATCH_PARENT,
+                WindowManager.LayoutParams.MATCH_PARENT,
+                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,
+                      WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
+                      | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                      | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE
+                      | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH
+                      | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
+              PixelFormat.TRANSLUCENT);
+        lp.gravity = Gravity.LEFT|Gravity.TOP;
+        mWindowManager.addView(mEffect, lp);
+    }
+
+    private void initControl() {
+        if (mInitialized) return;
+
+        mInitialized = true;
+
+        // Get actual screen size
+        mScreenWidth = mEffect.getWidth();
+        mScreenHeight = mEffect.getHeight();
+
+        mKillX = mScreenWidth / 2;
+        mKillY = mIconHalfSize;
+
+        if (!mFirstStart) {
+            if (mEffect.getHaloY() < 0) mEffect.setHaloY(0);
+            if (mEffect.getHaloY() > mScreenHeight-mIconSize) mEffect.setHaloY(mScreenHeight-mIconSize);
+            mEffect.nap(500);
+            if (mHideTicker) mEffect.sleep(HaloEffect.SNAP_TIME + HaloEffect.NAP_TIME + 2500, HaloEffect.SLEEP_TIME);
+        } else {
+            // Do the startup animations only once
+            mFirstStart = false;
+            updateTriggerPosition(0, mScreenHeight / 2 - mIconHalfSize);
+            mEffect.setHaloX(0);
+            mEffect.setHaloY(mScreenHeight / 2 - mIconHalfSize);
+            mEffect.nap(500);
+            if (mHideTicker) mEffect.sleep(HaloEffect.SNAP_TIME + HaloEffect.NAP_TIME + 2500, HaloEffect.SLEEP_TIME);
+        }
+    }    
+
+    private void updateTriggerPosition(int x, int y) {
+        try {
+            mTriggerPos.x = x;
+            mTriggerPos.y = y;
+            mWindowManager.updateViewLayout(mRoot, mTriggerPos);
+        } catch(Exception e) {
+            // Probably some animation still looking to move stuff around
+        }
+    }
+
+    private void loadLastNotification(boolean includeCurrentDismissable) {
+        if (mNotificationData.size() > 0) {
+            //oldEntry = mLastNotificationEntry;
+            mLastNotificationEntry = mNotificationData.get(mNotificationData.size() - 1);
+
+            // If the current notification is dismissable we might want to skip it if so desired
+            if (!includeCurrentDismissable) {
+                if (mNotificationData.size() > 1 && mLastNotificationEntry != null &&
+                        mLastNotificationEntry.notification == mCurrentNotficationEntry.notification) {
+                    boolean cancel = (mLastNotificationEntry.notification.getNotification().flags &
+                            Notification.FLAG_AUTO_CANCEL) == Notification.FLAG_AUTO_CANCEL;
+                    if (cancel) mLastNotificationEntry = mNotificationData.get(mNotificationData.size() - 2);
+                } else if (mNotificationData.size() == 1) {
+                    boolean cancel = (mLastNotificationEntry.notification.getNotification().flags &
+                            Notification.FLAG_AUTO_CANCEL) == Notification.FLAG_AUTO_CANCEL;
+                    if (cancel) {
+                        // We have one notification left and it is dismissable, clear it...
+                        clearTicker();
+                        return;
+                    }
+                }
+            }
+
+            if (mLastNotificationEntry.notification != null
+                    && mLastNotificationEntry.notification.getNotification() != null
+                    && mLastNotificationEntry.notification.getNotification().tickerText != null) {
+                mNotificationText = mLastNotificationEntry.notification.getNotification().tickerText.toString();
+            }
+
+            tick(mLastNotificationEntry, "", 0, 0);
+        } else {
+            clearTicker();
+        }
+    }
+
+    public void setStatusBar(BaseStatusBar bar) {
+        mBar = bar;
+        if (mBar.getTicker() != null) mBar.getTicker().setUpdateEvent(this);
+        mNotificationData = mBar.getNotificationData();
+        loadLastNotification(true);
+    }
+
+    void launchTask(NotificationClicker intent) {
+
+        // Do not launch tasks in hidden state
+        if (mState == State.HIDDEN) return;
+
+        try {
+            ActivityManagerNative.getDefault().resumeAppSwitches();
+            ActivityManagerNative.getDefault().dismissKeyguardOnNextActivity();
+        } catch (RemoteException e) {
+            // ...
+        }
+
+        if (intent!= null) {
+            intent.onClick(mRoot);
+        }
+    }
+
+    class GestureListener extends GestureDetector.SimpleOnGestureListener {
+        
+        @Override
+        public boolean onSingleTapUp (MotionEvent event) {
+            playSoundEffect(SoundEffectConstants.CLICK);
+            return true;
+        }
+
+        @Override
+        public boolean onFling(MotionEvent event1, MotionEvent event2, 
+                float velocityX, float velocityY) {
+            return true;
+        }
+
+        @Override
+        public boolean onSingleTapConfirmed(MotionEvent event) {
+            if (mState != State.DRAG) {
+                launchTask(mContentIntent);
+            }
+            return true;
+        }
+
+        @Override
+        public boolean onDoubleTap(MotionEvent event) {
+            if (!mInteractionReversed) {
+                mState = State.GESTURES;
+                mEffect.wake();
+                mBar.setHaloTaskerActive(true, true);
+            } else {
+                // Move
+                mState = State.DRAG;
+                mEffect.intro();
+            }
+            return true;
+        }
+    }
+
+    void resetIcons() {
+        final float originalAlpha = mContext.getResources().getFraction(R.dimen.status_bar_icon_drawing_alpha, 1, 1);
+        for (int i = 0; i < mNotificationData.size(); i++) {
+            NotificationData.Entry entry = mNotificationData.get(i);
+            entry.icon.setAlpha(originalAlpha);
+        }
+    }
+
+    void setIcon(int index) {
+        float originalAlpha = mContext.getResources().getFraction(R.dimen.status_bar_icon_drawing_alpha, 1, 1);
+        for (int i = 0; i < mNotificationData.size(); i++) {
+            NotificationData.Entry entry = mNotificationData.get(i);
+            entry.icon.setAlpha(index == i ? 1f : originalAlpha);
+        }
+    }
+
+    @Override
+    public boolean onTouchEvent(MotionEvent event) {
+        mGestureDetector.onTouchEvent(event);
+
+        final int action = event.getAction();
+        switch(action) {
+            case MotionEvent.ACTION_DOWN:
+                // Stop HALO from moving around, unschedule sleeping patterns
+                if (mState != State.GESTURES) mEffect.unscheduleSleep();
+
+                mMarkerIndex = -1;
+                oldIconIndex = -1;
+                
+                mGesture = Gesture.NONE;
+                hiddenState = mState == State.HIDDEN;
+                if (mState == State.HIDDEN) {
+                    mEffect.wake();
+                    if (mHideTicker) {
+                        mEffect.sleep(2500, HaloEffect.SLEEP_TIME);
+                    } else {
+                        mEffect.nap(2500);
+                    }
+                    return true;
+                }
+
+                initialX = event.getRawX();
+                initialY = event.getRawY(); 
+                break;
+
+            case MotionEvent.ACTION_CANCEL:
+            case MotionEvent.ACTION_UP:
+                if (hiddenState) break;
+
+                resetIcons();
+                mBar.setHaloTaskerActive(false, true);
+                mEffect.setHaloOverlay(HaloProperties.Overlay.NONE, 0f);
+                updateTriggerPosition(mEffect.getHaloX(), mEffect.getHaloY());
+
+                mEffect.outro();
+                mEffect.killTicker();
+                mEffect.unscheduleSleep();
+
+                // Do we erase ourselves?
+                if (mOverX) {
+                    Settings.System.putInt(mContext.getContentResolver(),
+                            Settings.System.HALO_ACTIVE, 0);
+                    return true;
+                }
+                    
+                if (mGesture == Gesture.TASK) {
+                    // Launch tasks
+                    if (mTaskIntent != null) {
+                        playSoundEffect(SoundEffectConstants.CLICK);
+                        launchTask(mTaskIntent);
+                    }
+                    mEffect.nap(0);
+                    if (mHideTicker) mEffect.sleep(HaloEffect.NAP_TIME + 1500, HaloEffect.SLEEP_TIME);
+                } else if (mGesture == Gesture.DOWN) {
+                    // Hide from sight
+                    playSoundEffect(SoundEffectConstants.CLICK);
+                    mEffect.sleep(0, HaloEffect.NAP_TIME / 2);
+                } else if (mGesture == Gesture.UP) {
+                    // Dismiss notification
+                    playSoundEffect(SoundEffectConstants.CLICK);
+
+                    if (mContentIntent != null) {
+                        try {
+                            mBar.getService().onNotificationClear(mContentIntent.mPkg, mContentIntent.mTag, mContentIntent.mId);
+                        } catch (RemoteException ex) {
+                            // system process is dead if we're here.
+                        }
+                    }
+
+                    // Find next entry
+                    NotificationData.Entry entry = null;
+                    if (mNotificationData.size() > 0) {
+                        for (int i = mNotificationData.size() - 1; i >= 0; i--) {
+                            NotificationData.Entry item = mNotificationData.get(i);
+                            if (mCurrentNotficationEntry != null
+                                    && mCurrentNotficationEntry.notification == item.notification) {
+                                continue;
+                            }
+                            boolean cancel = (item.notification.getNotification().flags &
+                                    Notification.FLAG_AUTO_CANCEL) == Notification.FLAG_AUTO_CANCEL;
+                            if (cancel) {
+                                entry = item;
+                                break;
+                            }
+                        }
+                    }
+
+                    // When no entry was found, take the last one
+                    if (entry == null && mNotificationData.size() > 0) {
+                        loadLastNotification(false);
+                    } else {
+                        tick(entry, "", 0, 0);
+                    }
+
+                    mEffect.nap(1500);
+                    if (mHideTicker) mEffect.sleep(HaloEffect.NAP_TIME + 3000, HaloEffect.SLEEP_TIME);
+                } else {
+                    // No gesture, just snap HALO
+                    mEffect.snap(0);
+                    mEffect.nap(HaloEffect.SNAP_TIME + 1000);
+                    if (mHideTicker) mEffect.sleep(HaloEffect.SNAP_TIME + HaloEffect.NAP_TIME + 2500, HaloEffect.SLEEP_TIME);
+                }
+
+                mState = State.IDLE;
+                mGesture = Gesture.NONE;
+                break;
+
+            case MotionEvent.ACTION_MOVE:
+                if (hiddenState) break;
+               
+                float distanceX = mKillX-event.getRawX();
+                float distanceY = mKillY-event.getRawY();
+                float distanceToKill = (float)Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
+
+                distanceX = initialX-event.getRawX();
+                distanceY = initialY-event.getRawY();
+                float initialDistance = (float)Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
+
+                if (mState != State.GESTURES) {
+                    // Check kill radius
+                    if (distanceToKill < mIconSize) {
+                        // Magnetize X
+                        mEffect.setHaloX((int)mKillX - mIconHalfSize);
+                        mEffect.setHaloY((int)(mKillY - mIconHalfSize));
+                            
+                        if (!mOverX) {
+                            if (mHapticFeedback) mVibrator.vibrate(25);
+                            mEffect.ping(mPaintHoloRed, 0);
+                            mEffect.setHaloOverlay(HaloProperties.Overlay.BLACK_X, 1f);
+                            mOverX = true;
+                        }
+
+                        return false;
+                    } else {
+                        if (mOverX) mEffect.setHaloOverlay(HaloProperties.Overlay.NONE, 0f);
+                        mOverX = false;
+                    }
+
+                    // Drag
+                    if (mState != State.DRAG) {
+                        if (initialDistance > mIconSize * 0.7f) {
+                            if (mInteractionReversed) {
+                                mState = State.GESTURES;
+                                mEffect.wake();
+                                mBar.setHaloTaskerActive(true, true);
+                            } else {
+                                mState = State.DRAG;
+                                mEffect.intro();
+                                if (mHapticFeedback) mVibrator.vibrate(25);
+                            }
+                        }
+                    } else {
+                        int posX = (int)event.getRawX() - mIconHalfSize;
+                        int posY = (int)event.getRawY() - mIconHalfSize;
+                        if (posX < 0) posX = 0;
+                        if (posY < 0) posY = 0;
+                        if (posX > mScreenWidth-mIconSize) posX = mScreenWidth-mIconSize;
+                        if (posY > mScreenHeight-mIconSize) posY = mScreenHeight-mIconSize;
+                        mEffect.setHaloX(posX);
+                        mEffect.setHaloY(posY);
+
+                        // Update resources when the side changes
+                        boolean oldTickerPos = mTickerLeft;
+                        mTickerLeft = (posX + mIconHalfSize < mScreenWidth / 2);
+                        if (oldTickerPos != mTickerLeft) {
+                            mEffect.updateResources();
+                        }
+                    }
+                } else {
+                    // We have three basic gestures, one horizontal for switching through tasks and
+                    // two vertical for dismissing tasks or making HALO fall asleep
+
+                    int deltaX = (int)(mTickerLeft ? event.getRawX() : mScreenWidth - event.getRawX());
+                    int deltaY = (int)(mEffect.getHaloY() - event.getRawY() + mIconSize);
+                    int horizontalThreshold = (int)(mIconSize * 1.5f);
+                    int verticalThreshold = mIconSize;
+
+                    // Switch icons
+                    if (deltaX > horizontalThreshold) {
+                    if (mGesture != Gesture.TASK) mEffect.setHaloOverlay(HaloProperties.Overlay.NONE, 0f);
+
+                    mGesture = Gesture.TASK;
+                    
+                    deltaX -= horizontalThreshold;
+                    if (mNotificationData != null && mNotificationData.size() > 0) {
+                        int items = mNotificationData.size();
+
+                        // This will be the lenght we are going to use
+                        int indexLength = (mScreenWidth - mIconSize * 2) / items;
+
+                        // Calculate index
+                        mMarkerIndex = mTickerLeft ? (items - deltaX / indexLength) - 1 : (deltaX / indexLength);
+
+                        // Watch out for margins!
+                        if (mMarkerIndex >= items) mMarkerIndex = items - 1;
+                        if (mMarkerIndex < 0) mMarkerIndex = 0;
+                    }
+                } else if (Math.abs(deltaY) > verticalThreshold) {
+                    mMarkerIndex = -1;
+
+                    // Up & down gestures
+                    int newDeltaY = Math.abs(deltaY) - verticalThreshold;
+                    boolean gestureChanged = false;
+
+                    if (deltaY > 0) {
+                        if (mGesture != Gesture.UP) {
+                            mGesture = Gesture.UP;
+                            gestureChanged = true;
+                            mEffect.setHaloOverlay(HaloProperties.Overlay.DISMISS, 1f);
+                        }
+                    } else {
+                        if (mGesture != Gesture.DOWN) {
+                            mGesture = Gesture.DOWN;
+                            gestureChanged = true;
+                            mEffect.setHaloOverlay(mTickerLeft ? HaloProperties.Overlay.BACK_LEFT
+                                    : HaloProperties.Overlay.BACK_RIGHT, 1f);
+                        }
+                    }
+
+                    if (gestureChanged) {
+                        mMarkerIndex = -1;
+                        mEffect.killTicker();
+                        if (mHapticFeedback) mVibrator.vibrate(10);
+                    }
+
+                } else {
+                    mMarkerIndex = -1;
+                    if (mGesture != Gesture.NONE) mEffect.setHaloOverlay(HaloProperties.Overlay.NONE, 0f);
+                    mGesture = Gesture.NONE;
+                }
+
+                // If the marker index changed, tick
+                if (mMarkerIndex != oldIconIndex) {
+                    oldIconIndex = mMarkerIndex;
+
+                    // Make a tiny pop if not so many icons are present
+                    if (mHapticFeedback && mNotificationData.size() < 10) mVibrator.vibrate(1);
+
+                    try {
+                        if (mMarkerIndex == -1) {
+                            mTaskIntent = null;
+                            resetIcons();
+                            tick(mLastNotificationEntry, mNotificationText, 0, 250);
+
+                            // Ping to notify the user we're back where we started
+                            mEffect.ping(mPaintHoloBlue, 0);
+                        } else {
+                            setIcon(mMarkerIndex);
+
+                            NotificationData.Entry entry = mNotificationData.get(mMarkerIndex);
+                            String text = "";
+                            if (entry.notification.getNotification().tickerText != null) {
+                                text = entry.notification.getNotification().tickerText.toString();
+                            }
+                            tick(entry, text, 0, 250);
+                            mTaskIntent = entry.getFloatingIntent();
+                        }
+                    } catch (Exception e) {
+                        // IndexOutOfBoundsException
+                    }
+                }
+            }
+
+            mEffect.invalidate();
+            break;
+        }
+        return false;
+    }
+
+    public void cleanUp() {
+        // Remove pending tasks, if we can
+        mEffect.unscheduleSleep();
+        mHandler.removeCallbacksAndMessages(null);
+        // Kill callback
+        mBar.getTicker().setUpdateEvent(null);
+        // Flag tasker
+        mBar.setHaloTaskerActive(false, false);
+        // Kill the effect layer
+        if (mEffect != null) mWindowManager.removeView(mEffect);
+        // Remove resolver
+        mContext.getContentResolver().unregisterContentObserver(mSettingsObserver);
+    }
+
+    class HaloEffect extends HaloProperties {
+
+        public static final int WAKE_TIME = 300;
+        public static final int SNAP_TIME = 300;
+        public static final int NAP_TIME = 1000;
+        public static final int SLEEP_TIME = 2000;
+        public static final int PING_TIME = 1500;
+        public static final int PULSE_TIME = 1500;
+        public static final int TICKER_HIDE_TIME = 2500;
+        public static final int NAP_DELAY = 4500;
+        public static final int SLEEP_DELAY = 6500;  
+
+        private Context mContext;
+        private Paint mPingPaint;
+        private int pingRadius = 0;
+        private int mPingX, mPingY;
+        protected int pingMinRadius = 0;
+        protected int pingMaxRadius = 0;        
+        private boolean mPingAllowed = true;
+
+        private Bitmap mMarkerL, mMarkerT, mMarkerR, mMarkerB;
+        private Bitmap mBigRed;
+        private Bitmap mPulse;
+        private Paint mPulsePaint = new Paint();
+        private Paint mMarkerPaint = new Paint();
+        private Paint xPaint = new Paint();
+
+        CustomObjectAnimator xAnimator = new CustomObjectAnimator(this);
+        CustomObjectAnimator tickerAnimator = new CustomObjectAnimator(this);
+
+        public HaloEffect(Context context) {
+            super(context);
+
+            mContext = context;
+            setWillNotDraw(false);
+            setDrawingCacheEnabled(false);
+
+            mBigRed = BitmapFactory.decodeResource(mContext.getResources(),
+                    R.drawable.halo_bigred);
+            mPulse = BitmapFactory.decodeResource(mContext.getResources(),
+                    R.drawable.halo_pulse1);
+            mMarkerL = BitmapFactory.decodeResource(mContext.getResources(),
+                    R.drawable.halo_marker_l);
+            mMarkerT = BitmapFactory.decodeResource(mContext.getResources(),
+                    R.drawable.halo_marker_t);
+            mMarkerR = BitmapFactory.decodeResource(mContext.getResources(),
+                    R.drawable.halo_marker_r);
+            mMarkerB = BitmapFactory.decodeResource(mContext.getResources(),
+                    R.drawable.halo_marker_b);
+
+            mPulsePaint.setAntiAlias(true);
+            mPulsePaint.setAlpha(0);   
+            mMarkerPaint.setAntiAlias(true);
+            mMarkerPaint.setAlpha(0);
+            xPaint.setAntiAlias(true);
+            xPaint.setAlpha(0);
+
+            updateResources();
+        }
+
+        @Override
+        public void onSizeChanged(int w, int h, int oldw, int oldh) {
+            onConfigurationChanged(null);
+        }
+
+        @Override
+        public void onConfigurationChanged(Configuration newConfiguration) {
+            // This will reset the initialization flag
+            mInitialized = false;
+            // Generate a new content bubble
+            updateResources();
+        }
+
+        @Override
+        protected void onLayout (boolean changed, int left, int top, int right, int bottom) {
+            super.onLayout (changed, left, top, right, bottom);
+            // We have our effect-layer, now let's kickstart HALO
+            initControl();
+        }
+
+        public void killTicker() {
+            tickerAnimator.animate(ObjectAnimator.ofFloat(this, "haloContentAlpha", 0f).setDuration(250),
+                    new DecelerateInterpolator(), null);
+        }
+
+        public void ticker(String tickerText, int delay, int startDuration) {
+            if (tickerText == null || tickerText.isEmpty()) {
+                killTicker();
+                return;
+            }
+
+            mHaloTextViewL.setVisibility(mTickerLeft ? View.VISIBLE : View.GONE);
+            mHaloTextViewR.setVisibility(mTickerLeft ? View.GONE : View.VISIBLE);
+
+            mHaloTextViewR.setText(tickerText);
+            mHaloTextViewL.setText(tickerText);
+
+            float total = TICKER_HIDE_TIME + startDuration + 1000;
+            PropertyValuesHolder tickerUpFrames = PropertyValuesHolder.ofKeyframe("haloContentAlpha",
+                    Keyframe.ofFloat(0f, mHaloTextViewL.getAlpha()),
+                    Keyframe.ofFloat(startDuration / total, 1f),
+                    Keyframe.ofFloat((TICKER_HIDE_TIME + startDuration) / total, 1f),
+                    Keyframe.ofFloat(1f, 0f));
+            tickerAnimator.animate(ObjectAnimator.ofPropertyValuesHolder(this, tickerUpFrames).setDuration((int)total),
+                    new DecelerateInterpolator(), null, delay, null);
+        }
+
+        public void ping(final Paint paint, final long delay) {
+            if ((!mPingAllowed && paint != mPaintHoloRed)
+                    && mGesture != Gesture.TASK) return;
+
+            mHandler.postDelayed(new Runnable() {
+                public void run() {
+                    mPingAllowed = false;
+
+                    mPingX = mHaloX + mIconHalfSize;
+                    mPingY = mHaloY + mIconHalfSize;
+;
+                    mPingPaint = paint;
+
+                    int c = Color.argb(0xff, Color.red(paint.getColor()), Color.green(paint.getColor()), Color.blue(paint.getColor()));
+                    mPulsePaint.setColorFilter(new PorterDuffColorFilter(c, PorterDuff.Mode.SRC_IN));
+
+                    CustomObjectAnimator pingAnimator = new CustomObjectAnimator(mEffect);
+                    pingAnimator.animate(ObjectAnimator.ofInt(mPingPaint, "alpha", 200, 0).setDuration(PING_TIME),
+                            new DecelerateInterpolator(), new AnimatorUpdateListener() {
+                                @Override
+                                public void onAnimationUpdate(ValueAnimator animation) {
+                                    pingRadius = (int)((pingMaxRadius - pingMinRadius) *
+                                            animation.getAnimatedFraction()) + pingMinRadius;
+                                    invalidate();
+                                }});
+
+                    CustomObjectAnimator pulseAnimator = new CustomObjectAnimator(mEffect);
+                    pulseAnimator.animate(ObjectAnimator.ofInt(mPulsePaint, "alpha", 100, 0).setDuration(PULSE_TIME),
+                            new AccelerateInterpolator(), null);
+
+                    // prevent ping spam            
+                    mHandler.postDelayed(new Runnable() {
+                        public void run() {
+                            mPingAllowed = true;
+                        }}, PING_TIME / 2);
+
+                }}, delay);
+        }
+
+        public void intro() {
+            xAnimator.animate(ObjectAnimator.ofInt(xPaint, "alpha", 255).setDuration(PING_TIME / 3),
+                    new DecelerateInterpolator(), null);
+        }
+
+        public void outro() {
+            xAnimator.animate(ObjectAnimator.ofInt(xPaint, "alpha", 0).setDuration(PING_TIME / 3),
+                    new AccelerateInterpolator(), null);
+        }
+
+        CustomObjectAnimator snapAnimator = new CustomObjectAnimator(this);
+
+        public void wake() {
+            unscheduleSleep();
+            if (mState == State.HIDDEN) mState = State.IDLE;
+            int newPos = mTickerLeft ? 0 : mScreenWidth - mIconSize;
+            updateTriggerPosition(newPos, mHaloY);
+            snapAnimator.animate(ObjectAnimator.ofInt(this, "haloX", newPos).setDuration(WAKE_TIME),
+                    new DecelerateInterpolator(), null);
+        }
+
+        public void snap(long delay) {
+            int newPos = mTickerLeft ? 0 : mScreenWidth - mIconSize;
+            updateTriggerPosition(newPos, mHaloY);
+            snapAnimator.animate(ObjectAnimator.ofInt(this, "haloX", newPos).setDuration(SNAP_TIME),
+                    new DecelerateInterpolator(), null, delay, null);
+        }
+
+        public void nap(long delay) {
+            final int newPos = mTickerLeft ? -mIconHalfSize : mScreenWidth - mIconHalfSize;
+            snapAnimator.animate(ObjectAnimator.ofInt(this, "haloX", newPos).setDuration(NAP_TIME),
+                    new DecelerateInterpolator(), null, delay, new Runnable() {
+                        public void run() {
+                            updateTriggerPosition(newPos, mHaloY);
+                        }});
+        }
+
+        public void sleep(long delay, int speed) {
+            final int newPos = (int)(mTickerLeft ? -mIconSize*0.8f : mScreenWidth - mIconSize*0.2f);
+            snapAnimator.animate(ObjectAnimator.ofInt(this, "haloX", newPos).setDuration(speed),
+                    new DecelerateInterpolator(), null, delay, new Runnable() {
+                        public void run() {
+                            mState = State.HIDDEN;
+                            final int triggerWidth = (int)(mTickerLeft ? -mIconSize*0.7f : mScreenWidth - mIconSize*0.3f);
+                            updateTriggerPosition(triggerWidth, mHaloY);
+                        }});
+        }
+
+        public void unscheduleSleep() {
+            snapAnimator.cancel(true);
+        }
+
+        @Override
+        protected void onDraw(Canvas canvas) {
+            int state;
+
+            // Ping
+            if (mPingPaint != null) {
+                canvas.drawCircle(mPingX, mPingY, pingRadius, mPingPaint);
+                int w = mPulse.getWidth() + (int)(mIconSize * 1.2f * mPulsePaint.getAlpha() / 100);
+                Rect r = new Rect(mPingX - w / 2, mPingY - w / 2, mPingX + w / 2, mPingY + w / 2);
+                canvas.drawBitmap(mPulse, null, r, mPulsePaint);
+            }
+
+            // Content
+            state = canvas.save();
+
+            int y = mHaloY - mHaloTickerContent.getMeasuredHeight() + (int)(mIconSize * 0.2);
+            if (y < 0) y = 0;
+
+            int x = mHaloX + (int)(mIconSize * 0.92f);
+            int c = mHaloTickerContent.getMeasuredWidth();
+            if (x > mScreenWidth - c) {
+                x = mScreenWidth - c;
+                if (mHaloX > mScreenWidth - (int)(mIconSize * 1.5f) ) {
+                    x = mHaloX - c + (int)(mIconSize * 0.08f);
+                }
+            }
+
+            state = canvas.save();
+            canvas.translate(x, y);
+            mHaloContentView.draw(canvas);
+            canvas.restoreToCount(state);
+
+            // X
+            float fraction = 1 - ((float)xPaint.getAlpha()) / 255;
+            int killyPos = (int)(mKillY - mBigRed.getWidth() / 2 - mIconSize * fraction);
+            canvas.drawBitmap(mBigRed, mKillX - mBigRed.getWidth() / 2, killyPos, xPaint);
+
+            // Horizontal Marker
+            if (mGesture == Gesture.TASK) {
+                if (y > 0 && mNotificationData != null && mNotificationData.size() > 0) {
+                    int pulseY = mHaloY + mIconHalfSize - mMarkerR.getHeight() / 2;
+                    int items = mNotificationData.size();
+                    int indexLength = (mScreenWidth - mIconSize * 2) / items;
+
+                    for (int i = 0; i < items; i++) {
+                        float pulseX = mTickerLeft ? (mIconSize * 1.5f + indexLength * i)
+                                : (mScreenWidth - mIconSize * 1.5f - indexLength * i - mMarkerR.getWidth());
+                        boolean markerState = mTickerLeft ? mMarkerIndex >= 0 && i < items-mMarkerIndex : i <= mMarkerIndex;
+                        mMarkerPaint.setAlpha(markerState ? 255 : 100);
+                        canvas.drawBitmap(mTickerLeft ? mMarkerR : mMarkerL, pulseX, pulseY, mMarkerPaint);
+                    }
+                }
+            }
+
+            // Vertical Marker
+            if (mGesture == Gesture.UP || mGesture == Gesture.DOWN) {
+                int xPos = mHaloX + mIconHalfSize - mMarkerT.getWidth() / 2;
+                int yTop = (int)(mHaloY + mIconHalfSize - mIconSize * 1.2f - mMarkerT.getHeight() / 2);
+                int yButtom = (int)(mHaloY + mIconHalfSize + mIconSize * 1.2f - mMarkerT.getHeight() / 2);
+                mMarkerPaint.setAlpha(mGesture == Gesture.UP ? 255 : 100);
+                canvas.drawBitmap(mMarkerT, xPos, yTop, mMarkerPaint);
+                mMarkerPaint.setAlpha(mGesture == Gesture.DOWN ? 255 : 100);
+                canvas.drawBitmap(mMarkerB, xPos, yButtom, mMarkerPaint);
+            }
+
+
+            // Bubble
+            state = canvas.save();
+            canvas.translate(mHaloX, mHaloY);
+            mHaloBubble.draw(canvas);
+            canvas.restoreToCount(state);
+
+            // Number
+            if (mState == State.IDLE || mState == State.GESTURES && !(mGesture == Gesture.UP || mGesture == Gesture.DOWN)) {
+                state = canvas.save();
+                canvas.translate(mTickerLeft ? mHaloX + mIconSize - mHaloNumber.getMeasuredWidth() : mHaloX, mHaloY);
+                mHaloNumberView.draw(canvas);
+                canvas.restoreToCount(state);
+            }
+        }
+    }
+
+    public WindowManager.LayoutParams getWMParams() {
+        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
+                mIconSize,
+                mIconSize,
+                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT,
+                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
+                        | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
+                        | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS
+                        | WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
+                        | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,
+                PixelFormat.TRANSLUCENT);
+        lp.gravity = Gravity.LEFT|Gravity.TOP;
+        return lp;
+    }
+
+    void clearTicker() {
+        mEffect.mHaloIcon.setImageDrawable(null);
+        mEffect.mHaloNumber.setAlpha(0f);
+        mContentIntent = null;
+        mCurrentNotficationEntry = null;
+        mEffect.killTicker();
+        mEffect.updateResources();
+        mEffect.invalidate();
+    }
+
+    void tick(NotificationData.Entry entry, String text, int delay, int duration) {
+        if (entry == null) {
+            clearTicker();
+            return;
+        }
+
+        StatusBarNotification notification = entry.notification;
+        Notification n = notification.getNotification();
+
+        // Deal with the intent
+        mContentIntent = entry.getFloatingIntent();
+        mCurrentNotficationEntry = entry;
+
+        // set the avatar
+        mEffect.mHaloIcon.setImageDrawable(new BitmapDrawable(mContext.getResources(), entry.getRoundIcon()));
+
+        // Set Number
+        if (n.number > 0) {
+            mEffect.mHaloNumber.setText((n.number < 100) ? String.valueOf(n.number) : "99+");
+            mEffect.mHaloNumber.setAlpha(1f);
+        } else {
+            mEffect.mHaloNumber.setAlpha(0f);
+        }
+
+        // Set text
+        mEffect.ticker(text, delay, duration);
+
+        mEffect.updateResources();
+        mEffect.invalidate();
+    }
+
+    // This is the android ticker callback
+    public void updateTicker(StatusBarNotification notification, String text) {
+
+        boolean allowed = false; // default off
+        try {
+            allowed = mNotificationManager.isPackageAllowedForHalo(notification.getPackageName());
+        } catch (android.os.RemoteException ex) {
+            // System is dead
+        }
+
+        for (int i = 0; i < mNotificationData.size(); i++) {
+            NotificationData.Entry entry = mNotificationData.get(i);
+
+            if (entry.notification == notification) {
+
+                // No intent, no tick ...
+                if (entry.notification.getNotification().contentIntent == null) return;
+
+                mIsNotificationNew = true;
+                if (mLastNotificationEntry != null && notification == mLastNotificationEntry.notification) {
+                    // Ok, this is the same notification
+                    // Let's give it a chance though, if the text has changed we allow it
+                    mIsNotificationNew = !mNotificationText.equals(text);
+                }
+
+                if (mIsNotificationNew) {
+                    mNotificationText = text;
+                    mLastNotificationEntry = entry;
+
+                    if (allowed) {
+                        tick(entry, text, HaloEffect.WAKE_TIME, 1000);
+
+                        // Pop while not tasking, only if notification is certified fresh
+                        if (mGesture != Gesture.TASK) mEffect.ping(mPaintHoloBlue, HaloEffect.WAKE_TIME);
+                        if (mState == State.IDLE || mState == State.HIDDEN) {
+                            mEffect.wake();
+                            mEffect.nap(HaloEffect.NAP_DELAY);
+                            if (mHideTicker) mEffect.sleep(HaloEffect.SLEEP_DELAY, HaloEffect.SLEEP_TIME);
+                        }
+                    }
+                }
+                break;
+            }
+        }
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/halo/HaloProperties.java b/packages/SystemUI/src/com/android/systemui/statusbar/halo/HaloProperties.java
new file mode 100644
index 0000000..fd88042e
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/halo/HaloProperties.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2013 ParanoidAndroid.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.statusbar.halo;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.TextView;
+import android.animation.ObjectAnimator;
+import android.view.animation.DecelerateInterpolator;
+
+import com.android.systemui.R;
+
+public class HaloProperties extends FrameLayout {
+
+    public enum Overlay {
+        NONE,
+        BLACK_X,
+        BACK_LEFT,
+        BACK_RIGHT,
+        DISMISS
+    }
+
+    private LayoutInflater mInflater;
+
+    protected int mHaloX = 0, mHaloY = 0;
+    protected float mHaloContentAlpha = 0;
+
+    private Drawable mHaloDismiss;
+    private Drawable mHaloBackL;
+    private Drawable mHaloBackR;
+    private Drawable mHaloBlackX;
+    private Drawable mHaloCurrentOverlay;
+
+    protected View mHaloBubble;
+    protected ImageView mHaloIcon, mHaloOverlay;
+
+    protected View mHaloContentView, mHaloTickerContent;
+    protected TextView mHaloTextViewR, mHaloTextViewL;
+
+    protected View mHaloNumberView;
+    protected TextView mHaloNumber;
+
+    CustomObjectAnimator mHaloOverlayAnimator;
+
+    public HaloProperties(Context context) {
+        super(context);
+
+        mHaloDismiss = mContext.getResources().getDrawable(R.drawable.halo_dismiss);
+        mHaloBackL = mContext.getResources().getDrawable(R.drawable.halo_back_left);
+        mHaloBackR = mContext.getResources().getDrawable(R.drawable.halo_back_right);
+        mHaloBlackX = mContext.getResources().getDrawable(R.drawable.halo_black_x);
+
+        mInflater = (LayoutInflater)mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+        mHaloBubble = mInflater.inflate(R.layout.halo_bubble, null);
+        mHaloIcon = (ImageView) mHaloBubble.findViewById(R.id.app_icon);
+        mHaloOverlay = (ImageView) mHaloBubble.findViewById(R.id.halo_overlay);
+
+        mHaloContentView = mInflater.inflate(R.layout.halo_speech, null);
+        mHaloTickerContent = mHaloContentView.findViewById(R.id.ticker);
+        mHaloTextViewR = (TextView) mHaloTickerContent.findViewById(R.id.bubble_r);
+        mHaloTextViewL = (TextView) mHaloTickerContent.findViewById(R.id.bubble_l);
+        mHaloTextViewL.setAlpha(0f);
+        mHaloTextViewR.setAlpha(0f);
+
+        mHaloNumberView = mInflater.inflate(R.layout.halo_number, null);
+        mHaloNumber = (TextView) mHaloNumberView.findViewById(R.id.number);
+        mHaloNumber.setAlpha(0f);
+
+        mHaloOverlayAnimator = new CustomObjectAnimator(this);
+    }        
+
+    public void setHaloX(int value) {
+        mHaloX = value;
+    }
+
+    public void setHaloY(int value) {
+        mHaloY = value;
+    }
+
+    public int getHaloX() {
+        return mHaloX; 
+    }
+
+    public int getHaloY() {
+        return mHaloY;
+    }
+
+    public void setHaloContentAlpha(float value) {
+        mHaloContentAlpha = value;
+        mHaloTextViewL.setAlpha(value);
+        mHaloTextViewR.setAlpha(value);
+    }
+
+    public float getHaloContentAlpha() {
+        return mHaloContentAlpha;
+    }
+
+    public void setHaloOverlay(Overlay overlay) {
+        setHaloOverlay(overlay, mHaloOverlay.getAlpha());
+    }
+
+    public void setHaloOverlay(Overlay overlay, float overlayAlpha) {
+
+        Drawable d = null;
+
+        switch(overlay) {
+            case BLACK_X:
+                d = mHaloBlackX;
+                break;
+            case BACK_LEFT:
+                d = mHaloBackL;
+                break;
+            case BACK_RIGHT:
+                d = mHaloBackR;
+                break;
+            case DISMISS:
+                d = mHaloDismiss;
+                break;
+        }
+
+        if (d != mHaloCurrentOverlay) {
+            mHaloOverlay.setImageDrawable(d);
+            mHaloCurrentOverlay = d;
+        }
+
+        mHaloOverlayAnimator.animate(ObjectAnimator.ofFloat(mHaloOverlay, "alpha", overlayAlpha).setDuration(250),
+                new DecelerateInterpolator(), null);
+
+        updateResources();
+    }
+
+    public void updateResources() {
+        mHaloContentView.measure(MeasureSpec.getSize(mHaloContentView.getMeasuredWidth()),
+                MeasureSpec.getSize(mHaloContentView.getMeasuredHeight()));
+        mHaloContentView.layout(0, 0, 0, 0);
+
+        mHaloBubble.measure(MeasureSpec.getSize(mHaloBubble.getMeasuredWidth()),
+                MeasureSpec.getSize(mHaloBubble.getMeasuredHeight()));
+        mHaloBubble.layout(0, 0, 0, 0);
+
+        mHaloNumberView.measure(MeasureSpec.getSize(mHaloNumberView.getMeasuredWidth()),
+                MeasureSpec.getSize(mHaloNumberView.getMeasuredHeight()));
+        mHaloNumberView.layout(0, 0, 0, 0);
+    }
+}
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
index 1a090cc..700607c 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java
@@ -269,7 +269,6 @@ public class PhoneStatusBar extends BaseStatusBar {
     PowerWidget mPowerWidget;
 
     // ticker
-    private Ticker mTicker;
     private View mTickerView;
     private boolean mTicking;
 
@@ -392,6 +391,10 @@ public class PhoneStatusBar extends BaseStatusBar {
             if (mSettingsButton != null && mHasFlipSettings) {
                 mSettingsButton.setVisibility(userSetup ? View.VISIBLE : View.INVISIBLE);
             }
+            if (mHaloButton != null && mHasFlipSettings) {
+                mHaloButtonVisible = userSetup;
+                updateHaloButton();
+            }
             if (mSettingsPanel != null) {
                 mSettingsPanel.setEnabled(userSetup);
             }
@@ -534,7 +537,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
         mClearButton.setOnClickListener(mClearButtonListener);
         mClearButton.setAlpha(0f);
-        mClearButton.setVisibility(View.INVISIBLE);
+        mClearButton.setVisibility(View.GONE);
         mClearButton.setEnabled(false);
         mDateView = (DateView)mStatusBarWindow.findViewById(R.id.date);
 
@@ -569,6 +572,14 @@ public class PhoneStatusBar extends BaseStatusBar {
                 mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
             }
         }
+
+        mHaloButton = (ImageView) mStatusBarWindow.findViewById(R.id.halo_button);
+        if (mHaloButton != null) {
+            mHaloButton.setOnClickListener(mHaloButtonListener);
+            mHaloButtonVisible = true;
+            updateHaloButton();
+        }
+
         if (mHasFlipSettings) {
             mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
             if (mNotificationButton != null) {
@@ -607,6 +618,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         mTicker = new MyTicker(context, mStatusBarView);
         TickerView tickerView = (TickerView)mStatusBarView.findViewById(R.id.tickerText);
         tickerView.mTicker = mTicker;
+        if (mHaloActive) mTickerView.setVisibility(View.GONE);
 
         mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
 
@@ -1215,6 +1227,9 @@ public class PhoneStatusBar extends BaseStatusBar {
         if (mSettingsButton != null) {
             mSettingsButton.setEnabled(isDeviceProvisioned());
         }
+        if (mHaloButton != null) {
+            mHaloButton.setEnabled(isDeviceProvisioned());
+        }
     }
 
     @Override
@@ -1239,7 +1254,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         for (int i=0; i<N; i++) {
             Entry ent = mNotificationData.get(N-i-1);
             if (!((provisioned && ent.notification.getScore() >= HIDE_ICONS_BELOW_SCORE)
-                    || showNotificationEvenIfUnprovisioned(ent.notification))) continue;
+                    || showNotificationEvenIfUnprovisioned(ent.notification) || mHaloTaskerActive)) continue;
             if (!notificationIsForCurrentUser(ent.notification)) continue;
             toShow.add(ent.icon);
         }
@@ -1322,7 +1337,7 @@ public class PhoneStatusBar extends BaseStatusBar {
                 && mFlipSettingsView.getVisibility() == View.VISIBLE
                 && mScrollView.getVisibility() != View.VISIBLE) {
             // the flip settings panel is unequivocally showing; we should not be shown
-            mClearButton.setVisibility(View.INVISIBLE);
+            mClearButton.setVisibility(View.GONE);
         } else if (mClearButton.isShown()) {
             if (clearable != (mClearButton.getAlpha() == 1.0f)) {
                 ObjectAnimator clearAnimation = ObjectAnimator.ofFloat(
@@ -1331,7 +1346,7 @@ public class PhoneStatusBar extends BaseStatusBar {
                     @Override
                     public void onAnimationEnd(Animator animation) {
                         if (mClearButton.getAlpha() <= 0.0f) {
-                            mClearButton.setVisibility(View.INVISIBLE);
+                            mClearButton.setVisibility(View.GONE);
                         }
                     }
 
@@ -1346,7 +1361,7 @@ public class PhoneStatusBar extends BaseStatusBar {
             }
         } else {
             mClearButton.setAlpha(clearable ? 1.0f : 0.0f);
-            mClearButton.setVisibility(clearable ? View.VISIBLE : View.INVISIBLE);
+            mClearButton.setVisibility(clearable ? View.VISIBLE : View.GONE);
         }
         mClearButton.setEnabled(clearable);
 
@@ -1644,7 +1659,7 @@ public class PhoneStatusBar extends BaseStatusBar {
     final int FLIP_DURATION = (FLIP_DURATION_IN + FLIP_DURATION_OUT);
 
     Animator mScrollViewAnim, mFlipSettingsViewAnim, mNotificationButtonAnim,
-        mSettingsButtonAnim, mClearButtonAnim;
+        mSettingsButtonAnim, mHaloButtonAnim, mClearButtonAnim;
 
     @Override
     public void animateExpandNotificationsPanel() {
@@ -1670,6 +1685,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         if (mFlipSettingsViewAnim != null) mFlipSettingsViewAnim.cancel();
         if (mScrollViewAnim != null) mScrollViewAnim.cancel();
         if (mSettingsButtonAnim != null) mSettingsButtonAnim.cancel();
+        if (mHaloButtonAnim != null) mHaloButtonAnim.cancel();
         if (mNotificationButtonAnim != null) mNotificationButtonAnim.cancel();
         if (mClearButtonAnim != null) mClearButtonAnim.cancel();
 
@@ -1707,6 +1723,11 @@ public class PhoneStatusBar extends BaseStatusBar {
         mSettingsButtonAnim = start(
             ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 1f)
                 .setDuration(FLIP_DURATION));
+        mHaloButtonVisible = true;
+        updateHaloButton();
+        mHaloButtonAnim = start(
+            ObjectAnimator.ofFloat(mHaloButton, View.ALPHA, 1f)
+                .setDuration(FLIP_DURATION));
         mClearButton.setVisibility(View.VISIBLE);
         mClearButton.setAlpha(0f);
         setAreThereNotifications(); // this will show/hide the button as necessary
@@ -1752,6 +1773,8 @@ public class PhoneStatusBar extends BaseStatusBar {
         mFlipSettingsView.setScaleX(1f);
         mFlipSettingsView.setVisibility(View.VISIBLE);
         mSettingsButton.setVisibility(View.GONE);
+        mHaloButtonVisible = false;
+        updateHaloButton();
         mScrollView.setVisibility(View.GONE);
         mScrollView.setScaleX(0f);
         mPowerWidget.setVisibility(View.GONE);
@@ -1811,6 +1834,7 @@ public class PhoneStatusBar extends BaseStatusBar {
         if (mFlipSettingsViewAnim != null) mFlipSettingsViewAnim.cancel();
         if (mScrollViewAnim != null) mScrollViewAnim.cancel();
         if (mSettingsButtonAnim != null) mSettingsButtonAnim.cancel();
+        if (mHaloButtonAnim != null) mHaloButtonAnim.cancel();
         if (mNotificationButtonAnim != null) mNotificationButtonAnim.cancel();
         if (mClearButtonAnim != null) mClearButtonAnim.cancel();
 
@@ -1842,6 +1866,11 @@ public class PhoneStatusBar extends BaseStatusBar {
                     .setDuration(FLIP_DURATION),
                     mScrollView, View.INVISIBLE));
         mPowerWidget.setVisibility(View.GONE);
+        mHaloButtonAnim = start(
+            setVisibilityWhenDone(
+                ObjectAnimator.ofFloat(mHaloButton, View.ALPHA, 0f)
+                    .setDuration(FLIP_DURATION),
+                    mScrollView, View.INVISIBLE));
         mNotificationButton.setVisibility(View.VISIBLE);
         mNotificationButtonAnim = start(
             ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 1f)
@@ -1894,6 +1923,7 @@ public class PhoneStatusBar extends BaseStatusBar {
             if (mFlipSettingsViewAnim != null) mFlipSettingsViewAnim.cancel();
             if (mScrollViewAnim != null) mScrollViewAnim.cancel();
             if (mSettingsButtonAnim != null) mSettingsButtonAnim.cancel();
+            if (mHaloButtonAnim != null) mHaloButtonAnim.cancel();
             if (mNotificationButtonAnim != null) mNotificationButtonAnim.cancel();
             if (mClearButtonAnim != null) mClearButtonAnim.cancel();
 
@@ -1902,6 +1932,9 @@ public class PhoneStatusBar extends BaseStatusBar {
             mPowerWidget.updateVisibility();
             mSettingsButton.setAlpha(1f);
             mSettingsButton.setVisibility(View.VISIBLE);
+            mHaloButton.setAlpha(1f);
+            mHaloButtonVisible = true;
+            updateHaloButton();
             mNotificationPanel.setVisibility(View.GONE);
             mFlipSettingsView.setVisibility(View.GONE);
             mNotificationButton.setVisibility(View.GONE);
@@ -2329,8 +2362,8 @@ public class PhoneStatusBar extends BaseStatusBar {
 
     @Override
     protected void tick(IBinder key, StatusBarNotification n, boolean firstTime) {
-        // no ticking in lights-out mode
-        if (!areLightsOn()) return;
+        // no ticking in lights-out mode, except if halo is active
+        if (!areLightsOn() && !mHaloActive) return;
 
         // no ticking in Setup
         if (!isDeviceProvisioned()) return;
@@ -2342,7 +2375,8 @@ public class PhoneStatusBar extends BaseStatusBar {
         // until status bar window is attached to the window manager,
         // because...  well, what's the point otherwise?  And trying to
         // run a ticker without being attached will crash!
-        if (n.getNotification().tickerText != null && mStatusBarContainer.getWindowToken() != null) {
+        if (n.getNotification().tickerText != null && mStatusBarContainer.getWindowToken() != null
+                && !mHaloActive) {
             if (0 == (mDisabled & (StatusBarManager.DISABLE_NOTIFICATION_ICONS
                             | StatusBarManager.DISABLE_NOTIFICATION_TICKER))) {
                 mTicker.addEntry(n);
@@ -2358,27 +2392,33 @@ public class PhoneStatusBar extends BaseStatusBar {
         @Override
         public void tickerStarting() {
             mTicking = true;
-            mStatusBarContents.setVisibility(View.GONE);
-            mTickerView.setVisibility(View.VISIBLE);
-            mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_up_in, null));
-            mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_up_out, null));
+            if (!mHaloActive) {
+                mStatusBarContents.setVisibility(View.GONE);
+                mTickerView.setVisibility(View.VISIBLE);
+                mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_up_in, null));
+                mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_up_out, null));
+            }
         }
 
         @Override
         public void tickerDone() {
-            mStatusBarContents.setVisibility(View.VISIBLE);
-            mTickerView.setVisibility(View.GONE);
-            mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
-            mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_down_out,
-                        mTickingDoneListener));
+            if (!mHaloActive) {
+                mStatusBarContents.setVisibility(View.VISIBLE);
+                mTickerView.setVisibility(View.GONE);
+                mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
+                mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_down_out,
+                            mTickingDoneListener));
+            }
         }
 
         @Override
         public void tickerHalting() {
-            mStatusBarContents.setVisibility(View.VISIBLE);
-            mTickerView.setVisibility(View.GONE);
-            mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
-            // we do not animate the ticker away at this point, just get rid of it (b/6992707)
+            if (!mHaloActive) {
+                mStatusBarContents.setVisibility(View.VISIBLE);
+                mTickerView.setVisibility(View.GONE);
+                mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
+                // we do not animate the ticker away at this point, just get rid of it (b/6992707)
+            }
         }
     }
 
@@ -2659,6 +2699,18 @@ public class PhoneStatusBar extends BaseStatusBar {
         }
     };
 
+    private View.OnClickListener mHaloButtonListener = new View.OnClickListener() {
+        public void onClick(View v) {
+            // Activate HALO
+            Settings.System.putInt(mContext.getContentResolver(),
+                    Settings.System.HALO_ACTIVE, 1);
+            // Switch off regular ticker
+            mTickerView.setVisibility(View.GONE);
+            // Collapse
+            animateCollapsePanels();
+        }
+    };
+
     private final View.OnClickListener mClockClickListener = new View.OnClickListener() {
         @Override
         public void onClick(View v) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java
index ce58f2a..40985e1 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettings.java
@@ -373,6 +373,27 @@ class QuickSettings {
                 new QuickSettingsModel.BasicRefreshCallback(settingsTile));
         parent.addView(settingsTile);
         mDynamicSpannedTiles.add(settingsTile);
+
+        // QuickMemo
+        QuickSettingsTileView quickMemoTile = (QuickSettingsTileView)
+                inflater.inflate(R.layout.quick_settings_tile, parent, false);
+        quickMemoTile.setContent(R.layout.quick_settings_tile_quickmemo, inflater);
+        quickMemoTile.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mBar.collapseAllPanels(true);
+                mContext.sendBroadcast(new Intent("com.lge.QuickClip.action.START_QUICKCLIP"));
+            }
+        });
+        mModel.addQuickMemoTile(quickMemoTile, new QuickSettingsModel.RefreshCallback() {
+            @Override
+            public void refreshView(QuickSettingsTileView view, State state) {
+                TextView tv = (TextView) view.findViewById(R.id.quickmemo_tileview);
+                tv.setText(state.label);
+            }
+        });
+        parent.addView(quickMemoTile);
+        mDynamicSpannedTiles.add(quickMemoTile);
     }
 
     private void addSystemTiles(ViewGroup parent, LayoutInflater inflater) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsController.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsController.java
index cc4f187..325ca3a 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsController.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsController.java
@@ -32,6 +32,7 @@ import static com.android.internal.util.cm.QSConstants.TILE_MOBILEDATA;
 import static com.android.internal.util.cm.QSConstants.TILE_NETWORKMODE;
 import static com.android.internal.util.cm.QSConstants.TILE_NFC;
 import static com.android.internal.util.cm.QSConstants.TILE_PROFILE;
+import static com.android.internal.util.cm.QSConstants.TILE_QUICKMEMO;
 import static com.android.internal.util.cm.QSConstants.TILE_QUIETHOURS;
 import static com.android.internal.util.cm.QSConstants.TILE_RINGER;
 import static com.android.internal.util.cm.QSConstants.TILE_SCREENTIMEOUT;
@@ -80,6 +81,7 @@ import com.android.systemui.quicksettings.NfcTile;
 import com.android.systemui.quicksettings.PreferencesTile;
 import com.android.systemui.quicksettings.ProfileTile;
 import com.android.systemui.quicksettings.QuickSettingsTile;
+import com.android.systemui.quicksettings.QuickMemoTile;
 import com.android.systemui.quicksettings.QuietHoursTile;
 import com.android.systemui.quicksettings.RingerModeTile;
 import com.android.systemui.quicksettings.ScreenTimeoutTile;
@@ -189,6 +191,8 @@ public class QuickSettingsController {
                 qs = new BatteryTile(mContext, this, mStatusBarService.mBatteryController);
             } else if (tile.equals(TILE_SETTINGS)) {
                 qs = new PreferencesTile(mContext, this);
+            } else if (tile.equals(TILE_QUICKMEMO)) {
+                qs = new QuickMemoTile(mContext, this);
             } else if (tile.equals(TILE_WIFI)) {
                 qs = new WiFiTile(mContext, this, mStatusBarService.mNetworkController);
             } else if (tile.equals(TILE_GPS)) {
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsModel.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsModel.java
index 348dc8d..6a51e42 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsModel.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/QuickSettingsModel.java
@@ -260,6 +260,10 @@ class QuickSettingsModel implements BluetoothStateChangeCallback,
     private RefreshCallback mSettingsCallback;
     private State mSettingsState = new State();
 
+    private QuickSettingsTileView mQuickMemoTile;
+    private RefreshCallback mQuickMemoCallback;
+    private State mQuickMemoState = new State();
+
     public QuickSettingsModel(Context context) {
         mContext = context;
         mHandler = new Handler();
@@ -309,6 +313,18 @@ class QuickSettingsModel implements BluetoothStateChangeCallback,
         mSettingsCallback.refreshView(mSettingsTile, mSettingsState);
     }
 
+    // QuickMemo
+    void addQuickMemoTile(QuickSettingsTileView view, RefreshCallback cb) {
+        mQuickMemoTile = view;
+        mQuickMemoCallback = cb;
+        refreshQuickMemoTile();
+    }
+    void refreshQuickMemoTile() {
+        Resources r = mContext.getResources();
+        mQuickMemoState.label = r.getString(R.string.quick_settings_quickmemo_label);
+        mQuickMemoCallback.refreshView(mQuickMemoTile, mQuickMemoState);
+    }
+
     // User
     void addUserTile(QuickSettingsTileView view, RefreshCallback cb) {
         mUserTile = view;
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java
index f3f6a80..0615ca8 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/Ticker.java
@@ -49,6 +49,16 @@ public abstract class Ticker {
     private ImageSwitcher mIconSwitcher;
     private TextSwitcher mTextSwitcher;
     private float mIconScale;
+    private TickerCallback mEvent;
+
+    public interface TickerCallback  
+    {  
+        public void updateTicker(StatusBarNotification notification, String text);
+    }  
+
+    public void setUpdateEvent(TickerCallback event) {
+        mEvent = event;
+    }
 
     public static boolean isGraphicOrEmoji(char c) {
         int gc = Character.getType(c);
@@ -60,21 +70,21 @@ public abstract class Ticker {
                 && gc != Character.SPACE_SEPARATOR;
     }
 
-    private final class Segment {
-        StatusBarNotification notification;
-        Drawable icon;
-        CharSequence text;
-        int current;
-        int next;
-        boolean first;
+    public final class Segment {
+        public StatusBarNotification notification;
+        public Drawable icon;
+        public CharSequence text;
+        public int current;
+        public int next;
+        public boolean first;
 
-        StaticLayout getLayout(CharSequence substr) {
+        public StaticLayout getLayout(CharSequence substr) {
             int w = mTextSwitcher.getWidth() - mTextSwitcher.getPaddingLeft()
                     - mTextSwitcher.getPaddingRight();
             return new StaticLayout(substr, mPaint, w, Alignment.ALIGN_NORMAL, 1, 0, true);
         }
 
-        CharSequence rtrim(CharSequence substr, int start, int end) {
+        public CharSequence rtrim(CharSequence substr, int start, int end) {
             while (end > start && !isGraphicOrEmoji(substr.charAt(end-1))) {
                 end--;
             }
@@ -85,7 +95,7 @@ public abstract class Ticker {
         }
 
         /** returns null if there is no more text */
-        CharSequence getText() {
+        public CharSequence getText() {
             if (this.current > this.text.length()) {
                 return null;
             }
@@ -104,7 +114,7 @@ public abstract class Ticker {
         }
 
         /** returns null if there is no more text */
-        CharSequence advance() {
+        public CharSequence advance() {
             this.first = false;
             int index = this.next;
             final int len = this.text.length();
@@ -137,7 +147,7 @@ public abstract class Ticker {
             return null;
         }
 
-        Segment(StatusBarNotification n, Drawable icon, CharSequence text) {
+        public Segment(StatusBarNotification n, Drawable icon, CharSequence text) {
             this.notification = n;
             this.icon = icon;
             this.text = text;
@@ -214,19 +224,24 @@ public abstract class Ticker {
         }
 
         mSegments.add(newSegment);
-
+        if (mEvent != null) {
+            if (newSegment != null) {
+                mEvent.updateTicker(newSegment.notification, text.toString());
+            }
+        }
+        
         if (initialCount == 0 && mSegments.size() > 0) {
             Segment seg = mSegments.get(0);
             seg.first = false;
-            
+
             mIconSwitcher.setAnimateFirstView(false);
             mIconSwitcher.reset();
             mIconSwitcher.setImageDrawable(seg.icon);
-            
+
             mTextSwitcher.setAnimateFirstView(false);
             mTextSwitcher.reset();
             mTextSwitcher.setText(seg.getText());
-            
+
             tickerStarting();
             scheduleAdvance();
         }
diff --git a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
index 9a2245c..7c179a8 100644
--- a/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
+++ b/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java
@@ -887,21 +887,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
     private final Runnable mRingerChordLongPress = new Runnable() {
         public void run() {
-            // Do the switch
-            final AudioManager am = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
-            final int ringerMode = am.getRingerMode();
-            final VolumePanel volumePanel = new VolumePanel(ThemeUtils.createUiContext(mContext),
-                                                              (AudioService) getAudioService());
-            if (ringerMode == AudioManager.RINGER_MODE_NORMAL) {
-                boolean vibrateSetting = Settings.System.getIntForUser(mContext.getContentResolver(),
-                        Settings.System.VIBRATE_WHEN_RINGING, 0, UserHandle.USER_CURRENT) != 0;
-                am.setRingerMode(vibrateSetting ? AudioManager.RINGER_MODE_VIBRATE :
-                                   AudioManager.RINGER_MODE_SILENT);
-            } else {
-                am.setRingerMode(AudioManager.RINGER_MODE_NORMAL);
-            }
-            volumePanel.postVolumeChanged(AudioManager.STREAM_RING,AudioManager.FLAG_SHOW_UI
-                                          | AudioManager.FLAG_VIBRATE);
+            mContext.sendBroadcast(new Intent("com.lge.QuickClip.action.START_QUICKCLIP"));
         }
     };
 
@@ -2279,8 +2265,7 @@ public class PhoneWindowManager implements WindowManagerPolicy {
 
         if (DEBUG_INPUT) {
             Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount="
-                    + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed
-                    + " canceled=" + canceled);
+                    + repeatCount + " keyguardOn=" + keyguardOn + " canceled=" + canceled);
         }
 
         // If we think we might have a volume down & power/volume-up key chord on the way
@@ -5727,7 +5712,6 @@ public class PhoneWindowManager implements WindowManagerPolicy {
                 pw.println(mForceStatusBarFromKeyguard);
         pw.print(prefix); pw.print("mDismissKeyguard="); pw.print(mDismissKeyguard);
                 pw.print(" mWinDismissingKeyguard="); pw.print(mWinDismissingKeyguard);
-                pw.print(" mHomePressed="); pw.println(mHomePressed);
         pw.print(prefix); pw.print("mAllowLockscreenWhenOn="); pw.print(mAllowLockscreenWhenOn);
                 pw.print(" mLockScreenTimeout="); pw.print(mLockScreenTimeout);
                 pw.print(" mLockScreenTimerActive="); pw.println(mLockScreenTimerActive);
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java
index 46dfc34..ee8f851 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardAbsKeyInputView.java
@@ -94,6 +94,7 @@ public abstract class KeyguardAbsKeyInputView extends LinearLayout
 
     protected abstract int getPasswordTextViewId();
     protected abstract void resetState();
+    protected abstract boolean getQuickUnlockAllowed();
 
     @Override
     protected void onFinishInflate() {
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java
index fa80352..82cb9b5 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPINView.java
@@ -56,6 +56,11 @@ public class KeyguardPINView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return true;
+    }
+
+    @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
 
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java
index d52c993..1dd129a 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardPasswordView.java
@@ -69,6 +69,11 @@ public class KeyguardPasswordView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return true;
+    }
+
+    @Override
     public boolean needsInput() {
         return true;
     }
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java
index ab364ee..fe10516 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPinView.java
@@ -63,6 +63,11 @@ public class KeyguardSimPinView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return false;
+    }
+
+    @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
 
diff --git a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java
index e5b4b73..8ef6451 100644
--- a/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java
+++ b/policy/src/com/android/internal/policy/impl/keyguard/KeyguardSimPukView.java
@@ -114,6 +114,11 @@ public class KeyguardSimPukView extends KeyguardAbsKeyInputView
     }
 
     @Override
+    protected boolean getQuickUnlockAllowed() {
+        return false;
+    }
+
+    @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
 
diff --git a/preloaded-classes b/preloaded-classes
index 8e426c5..e77dd2e 100644
--- a/preloaded-classes
+++ b/preloaded-classes
@@ -2,6 +2,19 @@
 # Automatically generated by frameworks/base/tools/preload/WritePreloadedClassFile.java.
 # MIN_LOAD_TIME_MICROS=1250
 # MIN_PROCESSES=10
+# BEGIN PRIVACY
+android.privacy.PrivacySettingsManagerService
+android.privacy.PrivacySettingsManager
+android.privacy.PrivacySettings
+android.privacy.PrivacyPersistenceAdapter
+android.privacy.IPrivacySettingsManager
+android.privacy.surrogate.PrivacyActivityManagerService
+android.privacy.surrogate.PrivacyCDMALTEPhone
+android.privacy.surrogate.PrivacyCDMAPhone
+android.privacy.surrogate.PrivacyGSMPhone
+android.privacy.surrogate.PrivacyPhoneProxy
+android.privacy.surrogate.PrivacySipPhone
+# END PRIVACY
 android.R$styleable
 android.accounts.Account
 android.accounts.Account$1
diff --git a/privacy/java/android/privacy/IPrivacySettingsManager.aidl b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
new file mode 100644
index 0000000..de375c6
--- /dev/null
+++ b/privacy/java/android/privacy/IPrivacySettingsManager.aidl
@@ -0,0 +1,29 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+import android.privacy.PrivacySettings;
+
+/** {@hide} */
+interface IPrivacySettingsManager
+{
+    PrivacySettings getSettings(String packageName);
+    boolean saveSettings(in PrivacySettings settings);
+    boolean deleteSettings(String packageName);
+    void notification(String packageName, byte accessMode, String dataType, String output);
+    void registerObservers();
+    void addObserver(String packageName);
+    boolean purgeSettings();
+    boolean setEnabled(boolean enable);
+    boolean setNotificationsEnabled(boolean enable);
+    void setBootCompleted();
+}
diff --git a/privacy/java/android/privacy/PrivacyFileObserver.java b/privacy/java/android/privacy/PrivacyFileObserver.java
new file mode 100644
index 0000000..c02947c
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyFileObserver.java
@@ -0,0 +1,125 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.os.FileObserver;
+import android.util.Log;
+
+import java.io.File;
+import java.util.HashMap;
+import java.util.StringTokenizer;
+
+/** {@hide} */
+public final class PrivacyFileObserver extends FileObserver {
+
+	public static final String TAG = "PrivacyFileObserver";
+	public static final int PACKAGE_PATH_INDEX = 3;
+	public static final int SETTINGS_TYPE_INDEX = PACKAGE_PATH_INDEX + 1;
+
+	public String absolutePath;
+	private PrivacySettingsManagerService pSetManServ;
+
+	public HashMap<String, PrivacyFileObserver> children;
+
+	public PrivacyFileObserver(String path,
+			PrivacySettingsManagerService pSetManServ) {
+		super(path, FileObserver.ALL_EVENTS);
+		this.absolutePath = path;
+		this.pSetManServ = pSetManServ;
+
+		this.children = new HashMap<String, PrivacyFileObserver>();
+		File thisFile = new File(absolutePath);
+		if (thisFile.isDirectory()) {
+			File[] subfiles = thisFile.listFiles();
+			for (File file : subfiles) {
+				String observePath = file.getAbsolutePath();
+				PrivacyFileObserver child = new PrivacyFileObserver(
+						observePath, pSetManServ);
+				children.put(observePath, child);
+				// don't watch directories, only the settings files
+				if (file.isFile())
+					child.startWatching();
+			}
+		}
+
+	}
+
+	@Override
+	public void onEvent(int event, String path) {
+		if ((FileObserver.ACCESS & event) != 0) { // data was read from a file
+		// Log.d(TAG, "onEvent - file accessed: " + absolutePath);
+			StringTokenizer tokenizer = new StringTokenizer(absolutePath, "/");
+			for (int i = 0; i < PACKAGE_PATH_INDEX
+					&& tokenizer.hasMoreElements(); i++) {
+				tokenizer.nextToken();
+			}
+
+			// get the package and UID of accessing application
+			String packageName = tokenizer.nextToken();
+			String settingsType = null;
+			if (tokenizer.hasMoreElements())
+				settingsType = tokenizer.nextToken();
+			// int uid = 0;
+			// try {
+			// uid = Integer.parseInt(tokenizer.nextToken());
+			// } catch (NumberFormatException e) {
+			// Log.e(TAG,
+			// "onEvent - could not get the UID of accessing application", e);
+			// // we still can continue, UID is optional here
+			// }
+
+			// read the setting
+			try {
+				if (settingsType != null
+						&& settingsType.equals("ipTableProtectSetting")) {
+					PrivacySettings pSet = pSetManServ.getSettings(packageName);
+					pSetManServ.notification(packageName,
+							pSet.getIpTableProtectSetting(),
+							PrivacySettings.DATA_IP_TABLES, null);
+				} else {
+					PrivacySettings pSet = pSetManServ.getSettings(packageName);
+					pSetManServ.notification(packageName,
+							pSet.getSystemLogsSetting(),
+							PrivacySettings.DATA_SYSTEM_LOGS, null);
+				}
+			} catch (Exception e) {
+				// nothing here
+			}
+		}
+
+	}
+
+	public void addObserver(String relativePath) {
+		String observePath = absolutePath + "/" + relativePath;
+		// remove existing observer(s) if any
+		children.remove(observePath); // child observers should be destroyed at
+										// next GC
+		// create new observer(s)
+		PrivacyFileObserver child = new PrivacyFileObserver(observePath,
+				pSetManServ);
+		children.put(observePath, child);
+	}
+
+	@Override
+	public void startWatching() {
+		// Log.d("PrivacyFileObserver",
+		// "PrivacyFileObserver - observing directory: " + absolutePath);
+		super.startWatching();
+	}
+
+	// public void verifyObserver() {
+	// Log.d(TAG, "verifyObservers - observer path: " + absolutePath);
+	// for (PrivacyFileObserver obs : children.values()) obs.verifyObserver();
+	// }
+
+}
diff --git a/privacy/java/android/privacy/PrivacyPersistenceAdapter.java b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
new file mode 100644
index 0000000..6ca722a
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacyPersistenceAdapter.java
@@ -0,0 +1,1112 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteException;
+import android.os.FileUtils;
+import android.util.Log;
+import android.util.LruCache;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * Responsible for persisting privacy settings to built-in memory
+ * 
+ * @author Svyatoslav Hresyk {@hide}
+ */
+public final class PrivacyPersistenceAdapter {
+
+    private static final String TAG = "PrivacyPersistenceAdapter";
+    private static final int RETRY_QUERY_COUNT = 5;
+    private static final String DATABASE_FILE = "/data/system/privacy.db";
+    private static final int DATABASE_VERSION = 4;
+    private static final boolean LOG_LOCKING = false;
+    private static final boolean LOG_OPEN_AND_CLOSE = false;
+    private static final boolean LOG_CACHE = false;
+    public static final int DUMMY_UID = -1;
+
+    /**
+     * Number of threads currently reading the database Could probably be
+     * improved by using 'AtomicInteger'
+     */
+    public static volatile Integer sDbAccessThreads = 0;
+    public static volatile int sDbVersion;
+
+    private static final boolean useCache = true;
+    private static final boolean autoCloseDb = false;
+
+        // Used to lock the database during multi-statement operations to prevent
+    // internally inconsistent data reads.
+    // Multiple locks could be used to improve efficiency (i.e. for different tables)
+    private static ReadWriteLock sDbLock = new ReentrantReadWriteLock();
+
+    /**
+     * Used to save settings for access from core libraries
+     */
+    public static final String SETTINGS_DIRECTORY = "/data/system/privacy";
+
+    
+    // The default cache size is somewhat arbitrary at the moment
+    // It may be valuable to run some analyses to check the average time between something being dropped from cache
+    // and being needed again. A recency-weighted LRU would be even better.
+    private static final int MINIMUM_CACHE_ENTRIES = 0;
+    private static final int DEFAULT_CACHE_ENTRIES = 20; 
+    //Because having privacy settings of 'null' has meaning
+    private static LruCache<String, PrivacySettingsStub> settingsCache = new LruCache<String, PrivacySettingsStub>(DEFAULT_CACHE_ENTRIES);
+
+    private static final String TABLE_SETTINGS = "settings";
+    private static final String TABLE_MAP = "map";
+    private static final String TABLE_ALLOWED_CONTACTS = "allowed_contacts";
+    private static final String TABLE_VERSION = "version";
+
+    private static final String CREATE_TABLE_SETTINGS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_SETTINGS + " ( " + 
+        " _id INTEGER PRIMARY KEY AUTOINCREMENT, " + 
+        " packageName TEXT, " + 
+        " uid INTEGER, " + 
+        " deviceIdSetting INTEGER, " + 
+        " deviceId TEXT, " + 
+        " line1NumberSetting INTEGER, " + 
+        " line1Number TEXT, " + 
+        " locationGpsSetting INTEGER, " + 
+        " locationGpsLat TEXT, " + 
+        " locationGpsLon TEXT, " + 
+        " locationNetworkSetting INTEGER, " + 
+        " locationNetworkLat TEXT, " + 
+        " locationNetworkLon TEXT, " + 
+        " networkInfoSetting INTEGER, " + 
+        " simInfoSetting INTEGER, " + 
+        " simSerialNumberSetting INTEGER, " + 
+        " simSerialNumber TEXT, " + 
+        " subscriberIdSetting INTEGER, " + 
+        " subscriberId TEXT, " + 
+        " accountsSetting INTEGER, " + 
+        " accountsAuthTokensSetting INTEGER, " + 
+        " outgoingCallsSetting INTEGER, " + 
+        " incomingCallsSetting INTEGER, " + 
+        " contactsSetting INTEGER, " + 
+        " calendarSetting INTEGER, " + 
+        " mmsSetting INTEGER, " + 
+        " smsSetting INTEGER, " + 
+        " callLogSetting INTEGER, " + 
+        " bookmarksSetting INTEGER, " + 
+        " systemLogsSetting INTEGER, " + 
+        " externalStorageSetting INTEGER, " + 
+        " cameraSetting INTEGER, " + 
+        " recordAudioSetting INTEGER, " + 
+        " notificationSetting INTEGER, " + 
+        " intentBootCompletedSetting INTEGER," + 
+        " smsSendSetting INTEGER," + 
+        " phoneCallSetting INTEGER," +
+        " ipTableProtectSetting INTEGER," +
+        " iccAccessSetting INTEGER," +
+        " addOnManagementSetting INTEGER," + //this setting indicate if app is managed by addon or not
+        " androidIdSetting INTEGER," +
+        " androidId TEXT," +
+        " wifiInfoSetting INTEGER," +
+        " switchConnectivitySetting INTEGER," +
+        " sendMmsSetting INTEGER," +
+        " forceOnlineState INTEGER," + 
+        " switchWifiStateSetting INTEGER" +
+        ");";
+    
+
+    private static final String CREATE_TABLE_MAP = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_MAP + " ( name TEXT PRIMARY KEY, value TEXT );";
+    
+    private static final String CREATE_TABLE_ALLOWED_CONTACTS = 
+        "CREATE TABLE IF NOT EXISTS " + TABLE_ALLOWED_CONTACTS + " ( settings_id, contact_id, PRIMARY KEY(settings_id, contact_id) );";
+
+    private static final String INSERT_VERSION = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"db_version\", " + DATABASE_VERSION + ");";
+
+    private static final String INSERT_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"enabled\", \"1\");";
+
+    private static final String INSERT_NOTIFICATIONS_ENABLED = 
+        "INSERT OR REPLACE INTO " + TABLE_MAP + " (name, value) " + "VALUES (\"notifications_enabled\", \"1\");";
+
+    private static final String[] DATABASE_FIELDS = new String[] { "_id", "packageName", "uid",
+            "deviceIdSetting", "deviceId", "line1NumberSetting", "line1Number",
+            "locationGpsSetting", "locationGpsLat", "locationGpsLon", "locationNetworkSetting",
+            "locationNetworkLat", "locationNetworkLon", "networkInfoSetting", "simInfoSetting",
+            "simSerialNumberSetting", "simSerialNumber", "subscriberIdSetting", "subscriberId",
+            "accountsSetting", "accountsAuthTokensSetting", "outgoingCallsSetting",
+            "incomingCallsSetting", "contactsSetting", "calendarSetting", "mmsSetting",
+            "smsSetting", "callLogSetting", "bookmarksSetting", "systemLogsSetting",
+            "externalStorageSetting", "cameraSetting", "recordAudioSetting", "notificationSetting",
+            "intentBootCompletedSetting", "smsSendSetting", "phoneCallSetting",
+            "ipTableProtectSetting", "iccAccessSetting", "addOnManagementSetting",
+            "androidIdSetting", "androidId", "wifiInfoSetting", "switchConnectivitySetting",
+            "sendMmsSetting", "forceOnlineState", "switchWifiStateSetting" };
+
+    public static final String SETTING_ENABLED = "enabled";
+    public static final String SETTING_NOTIFICATIONS_ENABLED = "notifications_enabled";
+    public static final String SETTING_DB_VERSION = "db_version";
+    public static final String VALUE_TRUE = "1";
+    public static final String VALUE_FALSE = "0";
+
+    private SQLiteDatabase mDb;
+
+    private Context mContext;
+
+    
+    
+    
+    public PrivacyPersistenceAdapter(Context context) {
+        this.mContext = context;
+
+        // create the database and settings directory if we have write
+        // permission and they do not exist
+        if (new File("/data/system/").canWrite()) { 
+            if (!(new File(DATABASE_FILE).exists() && new File(SETTINGS_DIRECTORY).exists())) {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (pre)lock");
+                sDbLock.writeLock().lock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (post)lock");
+                try {
+                    if (!new File(DATABASE_FILE).exists()) {
+                        createDatabase();
+                    }
+                    if (!new File(SETTINGS_DIRECTORY).exists()) {
+                        createSettingsDir();
+                    }
+                } finally {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (pre)unlock");
+                    sDbLock.writeLock().unlock();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:constructor: WriteLock: (post)unlock");
+                }
+            }
+
+
+            // upgrade if needed
+            sDbVersion = getDbVersion();
+            
+            if (sDbVersion < DATABASE_VERSION) {
+                upgradeDatabase();
+            }
+        }
+    }
+
+
+    private void upgradeDatabase() {
+        if (sDbVersion < DATABASE_VERSION) {
+            Log.i(TAG, "PrivacyPersistenceAdapter:upgradeDatabase - upgrading DB from version " + sDbVersion + " to "
+                    + DATABASE_VERSION);
+
+            SQLiteDatabase db = null;
+            
+            switch (sDbVersion) {
+            case 1:
+            case 2:
+            case 3:
+                try {
+                    synchronized (sDbAccessThreads) {
+                        sDbAccessThreads++;
+                    }
+                    if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+
+                    db = getDatabase();
+                    if (db != null && db.isOpen()) {
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (pre)lock");
+                        sDbLock.writeLock().lock();
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (post)lock");
+                        
+                        try {
+                            // check the db version again to make sure that another thread has not already done the upgrade
+                            // in the meantime
+                            if (sDbVersion < DATABASE_VERSION) {                                
+                                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (pre)begin");
+                                db.beginTransaction();
+                                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (post)begin");
+
+                                try {
+                                    db.execSQL("DROP TABLE IF EXISTS " + TABLE_VERSION + ";");
+                                    db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+                                    db.execSQL(CREATE_TABLE_MAP);
+                                    db.execSQL(INSERT_VERSION);
+                                    db.execSQL(INSERT_ENABLED);
+                                    db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+
+                                    purgeSettings();
+                                    
+                                    // remove uid dirs from the settings directory
+                                    // TODO: improve handling so that if an exception happens while
+                                    //      this process is in progress, it doesn't leave the filesystem
+                                    //      entries in an invalid state
+                                    File settingsDir = new File(SETTINGS_DIRECTORY);
+                                    for (File packageDir : settingsDir.listFiles()) {
+                                        for (File uidDir : packageDir.listFiles()) {
+                                            if (uidDir.isDirectory()) {
+                                                File[] settingsFiles = uidDir.listFiles();
+                                                // copy the first found (most likely
+                                                // the only one) one level up
+                                                if (settingsFiles[0] != null) {
+                                                    File newPath = new File(packageDir + "/"
+                                                            + settingsFiles[0].getName());
+                                                    newPath.delete();
+                                                    settingsFiles[0].renameTo(newPath);
+                                                    deleteRecursive(uidDir);
+                                                }
+                                            }
+                                        }
+                                    }
+    
+                                    db.setTransactionSuccessful();
+                                    sDbVersion = DATABASE_VERSION;
+                                } finally {                                
+                                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (pre)end");
+                                    db.endTransaction();
+                                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Transaction: (post)end");
+                                }
+                            } else {
+                                // The database has been upgraded elsewhere; end the db transaction
+                                // and don't make any further changes
+                            }
+                                
+                        } finally {
+                            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (pre)unlock");
+                            sDbLock.writeLock().unlock();
+                            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: WriteLock: (post)unlock");
+                        }
+                    }
+                } catch (SQLException e) {
+                    Log.e(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: SQLException occurred performing database upgrade", e);
+                } finally {
+                    closeIdleDatabase();
+                }
+                break;
+
+            case 4:
+                // most current version, do nothing
+                Log.i(TAG, "PrivacyPersistenceAdapter:upgradeDatabase: Database is already at the most recent version");
+                break;
+            }
+        }
+    }
+
+    
+    private int getDbVersion() {
+        String versionString = getValue(SETTING_DB_VERSION);
+        if (versionString == null) {
+            Log.e(TAG, "PrivacyPersistenceAdapter:getDbVersion: getValue returned null; assuming version = 1");
+            return 1;
+        } else {
+            try {
+                return Integer.parseInt(versionString);
+            } catch (Exception e) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:getDbVersion: failed to parse database version; returning 1");
+                return 1;
+            }
+        }
+    }
+
+    
+    public String getValue(String name) {
+        SQLiteDatabase db;
+        Cursor c;
+        String output = null;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+            db = getDatabase();
+            if (db == null || !db.isOpen()) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:getValue: Database not obtained while getting value for name: " + name);
+                return null;
+            }
+
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: ReadLock: (pre)lock");
+            sDbLock.readLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: ReadLock: (post)lock");
+            try {
+
+                c = query(db, TABLE_MAP, new String[] { "value" }, "name=?", new String[] { name },
+                        null, null, null, null);
+                if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                    output = c.getString(c.getColumnIndex("value"));
+                    c.close();
+                } else {
+                    Log.w(TAG, "PrivacyPersistenceAdapter:getValue: Could not get value for name: " + name);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:getValue: Exception occurred while getting value for name: " + name, e);
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: ReadLock: (pre)unlock");
+                sDbLock.readLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getValue: ReadLock: (post)unlock");
+            }
+
+        } finally {
+            closeIdleDatabase();
+        }
+        return output;
+    }
+    
+    public boolean setValue(String name, String value) {
+        Log.e(TAG, "setValue - name " + name + " value " + value);
+        ContentValues values = new ContentValues();
+        values.put("name", name);
+        values.put("value", value);
+
+        boolean success = false;
+
+        SQLiteDatabase db;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+            db = getDatabase();
+            if (db == null || !db.isOpen()) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:setValue: Database not obtained while setting value for name: " + name);
+                return false;
+            }
+            
+            // updating the version is atomic, but we need to use a lock
+            // to make sure we don't try to get/update the version while the DB is being created or upgraded
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (pre)lock");
+            sDbLock.writeLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (post)lock");
+            try {
+                success = db.replace(TABLE_MAP, null, values) != -1;
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (pre)unlock");
+                sDbLock.writeLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:setValue: WriteLock: (post)unlock");
+            }
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return success;
+    }
+    
+    /**
+     * Retrieve privacy settings for a single package
+     * 
+     * @param packageName
+     *            package for which to retrieve settings
+     * @return privacy settings for the package, or null if no settings exist
+     *         for it
+     */
+    public PrivacySettings getSettings(String packageName) {
+        PrivacySettings privacySettings = null;
+
+        if (packageName == null) {
+            throw new InvalidParameterException(
+                    "PrivacyPersistenceAdapter:getSettings:insufficient application identifier - package name is required");
+        }
+
+        if (useCache) {
+            PrivacySettingsStub cacheResult = settingsCache.get(packageName);
+            if (cacheResult != null) {
+                if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: Cache hit for " + packageName);
+                //if the cached object is a stub, then it means that there is no privacy settings for that package, and null should be returned
+                if (cacheResult instanceof PrivacySettings) {
+                    if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:Cached result is not a stub:" + packageName);
+                    return (PrivacySettings)cacheResult;
+                } else {
+                    if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:Cached result is a stub, return null:" + packageName);
+                    return null;
+                }
+            } else {
+                if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: Cache miss for " + packageName);
+            }
+        }
+        
+        SQLiteDatabase db;
+        try {
+            // indicate that the DB is being read to prevent closing by other threads
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+            db = getDatabase();
+        } catch (SQLiteException e) {
+            Log.e(TAG, "getSettings - database could not be opened", e);
+            closeIdleDatabase();
+            throw e;
+        }
+
+        Cursor cursor = null;
+
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (pre)lock");
+        sDbLock.readLock().lock();
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (post)lock");
+        try {
+            cursor = query(db, TABLE_SETTINGS, DATABASE_FIELDS, "packageName=?",
+                    new String[] { packageName }, null, null, null, null);
+
+            if (cursor != null) {
+                if (cursor.getCount() == 0) {
+                    // No settings are present: log that and do nothing
+                    Log.d(TAG, "PrivacyPersistenceAdapter:getSettingsfound for package " + packageName);
+                } else {
+                    if (cursor.getCount() > 1) {
+                        Log.w(TAG, "Multiple privacy settings found for package " + packageName);
+                    }
+    
+                    if (cursor.moveToFirst()) {
+                        privacySettings = new PrivacySettings(cursor.getInt(0), cursor.getString(1),
+                                cursor.getInt(2), (byte) cursor.getShort(3), cursor.getString(4),
+                                (byte) cursor.getShort(5), cursor.getString(6),
+                                (byte) cursor.getShort(7), cursor.getString(8), cursor.getString(9),
+                                (byte) cursor.getShort(10), cursor.getString(11), cursor.getString(12),
+                                (byte) cursor.getShort(13), (byte) cursor.getShort(14),
+                                (byte) cursor.getShort(15), cursor.getString(16),
+                                (byte) cursor.getShort(17), cursor.getString(18),
+                                (byte) cursor.getShort(19), (byte) cursor.getShort(20),
+                                (byte) cursor.getShort(21), (byte) cursor.getShort(22),
+                                (byte) cursor.getShort(23), (byte) cursor.getShort(24),
+                                (byte) cursor.getShort(25), (byte) cursor.getShort(26),
+                                (byte) cursor.getShort(27), (byte) cursor.getShort(28),
+                                (byte) cursor.getShort(29), (byte) cursor.getShort(30),
+                                (byte) cursor.getShort(31), (byte) cursor.getShort(32),
+                                (byte) cursor.getShort(33), (byte) cursor.getShort(34), null,
+                                (byte) cursor.getShort(35), (byte) cursor.getShort(36),
+                                (byte) cursor.getShort(37), (byte) cursor.getShort(38),
+                                (byte) cursor.getShort(39), (byte) cursor.getShort(40),
+                                cursor.getString(41), (byte) cursor.getShort(42),
+                                (byte) cursor.getShort(43), (byte) cursor.getShort(44),
+                                (byte) cursor.getShort(45), (byte) cursor.getShort(46));
+    
+                        // get allowed contacts IDs if necessary
+                        cursor = query(db, TABLE_ALLOWED_CONTACTS, new String[] { "contact_id" },
+                                "settings_id=?",
+                                new String[] { Integer.toString(privacySettings.get_id()) }, null,
+                                null, null, null);
+    
+                        if (cursor != null && cursor.getCount() > 0) {
+                            int[] allowedContacts = new int[cursor.getCount()];
+                            while (cursor.moveToNext())
+                                allowedContacts[cursor.getPosition()] = cursor.getInt(0);
+                            privacySettings.setAllowedContacts(allowedContacts);
+                        }
+                    }
+                }
+            }
+            
+            if (useCache) {
+                if (privacySettings != null) {
+                    settingsCache.put(packageName, privacySettings);
+                    if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: Cache put for" + packageName);
+                } else {
+                    settingsCache.put(packageName, new PrivacySettingsStub());
+                    if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: Cache stub put for" + packageName);
+                }
+            }
+            
+        } catch (Exception e) {
+            Log.e(TAG, "getSettings - failed to get settings for package: " + packageName, e);
+        } finally {
+            if (cursor != null)
+                cursor.close();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (pre)unlock");
+            sDbLock.readLock().unlock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:getSettings: ReadLock: (post)unlock");
+            closeIdleDatabase();
+        }
+        
+        return privacySettings;
+    }
+
+    /**
+     * Saves the settings object fields into DB and into plain text files where
+     * applicable. The DB changes will not be made persistent if saving settings
+     * to plain text files fails.
+     * 
+     * @param s
+     *            settings object
+     * @return true if settings were saved successfully, false otherwise
+     */
+    public boolean saveSettings(PrivacySettings s) {
+        boolean result = false;
+
+        String packageName = s.getPackageName();
+
+        if (packageName == null || packageName.isEmpty()) {
+            Log.e(TAG, "saveSettings - either package name is missing");
+            return false;
+        }
+
+        ContentValues values = new ContentValues();
+        values.put("packageName", packageName);
+        // values.put("uid", uid);
+        values.put("uid", DUMMY_UID);
+
+        values.put("deviceIdSetting", s.getDeviceIdSetting());
+        values.put("deviceId", s.getDeviceId());
+
+        values.put("line1NumberSetting", s.getLine1NumberSetting());
+        values.put("line1Number", s.getLine1Number());
+
+        values.put("locationGpsSetting", s.getLocationGpsSetting());
+        values.put("locationGpsLat", s.getLocationGpsLat());
+        values.put("locationGpsLon", s.getLocationGpsLon());
+
+        values.put("locationNetworkSetting", s.getLocationNetworkSetting());
+        values.put("locationNetworkLat", s.getLocationNetworkLat());
+        values.put("locationNetworkLon", s.getLocationNetworkLon());
+
+        values.put("networkInfoSetting", s.getNetworkInfoSetting());
+        values.put("simInfoSetting", s.getSimInfoSetting());
+
+        values.put("simSerialNumberSetting", s.getSimSerialNumberSetting());
+        values.put("simSerialNumber", s.getSimSerialNumber());
+        values.put("subscriberIdSetting", s.getSubscriberIdSetting());
+        values.put("subscriberId", s.getSubscriberId());
+
+        values.put("accountsSetting", s.getAccountsSetting());
+        values.put("accountsAuthTokensSetting", s.getAccountsAuthTokensSetting());
+        values.put("outgoingCallsSetting", s.getOutgoingCallsSetting());
+        values.put("incomingCallsSetting", s.getIncomingCallsSetting());
+
+        values.put("contactsSetting", s.getContactsSetting());
+        values.put("calendarSetting", s.getCalendarSetting());
+        values.put("mmsSetting", s.getMmsSetting());
+        values.put("smsSetting", s.getSmsSetting());
+        values.put("callLogSetting", s.getCallLogSetting());
+        values.put("bookmarksSetting", s.getBookmarksSetting());
+        values.put("systemLogsSetting", s.getSystemLogsSetting());
+        values.put("notificationSetting", s.getNotificationSetting());
+        values.put("intentBootCompletedSetting", s.getIntentBootCompletedSetting());
+        // values.put("externalStorageSetting", s.getExternalStorageSetting());
+        values.put("cameraSetting", s.getCameraSetting());
+        values.put("recordAudioSetting", s.getRecordAudioSetting());
+        values.put("smsSendSetting", s.getSmsSendSetting());
+        values.put("phoneCallSetting", s.getPhoneCallSetting());
+        values.put("ipTableProtectSetting", s.getIpTableProtectSetting());
+        values.put("iccAccessSetting", s.getIccAccessSetting());
+        values.put("addOnManagementSetting", s.getAddOnManagementSetting());
+        values.put("androidIdSetting", s.getAndroidIdSetting());
+        values.put("androidId", s.getAndroidID());
+        values.put("wifiInfoSetting", s.getWifiInfoSetting());
+        values.put("switchConnectivitySetting", s.getSwitchConnectivitySetting());
+        values.put("sendMmsSetting", s.getSendMmsSetting());
+        values.put("forceOnlineState", s.getForceOnlineState());
+        values.put("switchWifiStateSetting", s.getSwitchWifiStateSetting());
+
+        SQLiteDatabase db = null;
+        Cursor cursor = null;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+            db = getDatabase();
+
+            if (db != null && db.isOpen()) {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (pre)lock");
+                sDbLock.writeLock().lock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (post)lock");
+                try {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (pre)begin");
+                    db.beginTransaction();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (post)begin");
+                    try {
+
+                        // save settings to the DB
+                        Integer id = s.get_id();
+
+                        if (id != null) { // existing entry -> update
+                            if (db.update(TABLE_SETTINGS, values, "_id=?", new String[] { id.toString() }) < 1) {
+                                throw new Exception("saveSettings - failed to update database entry");
+                            }
+
+                            db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?", new String[] { id.toString() });
+                            int[] allowedContacts = s.getAllowedContacts();
+                            if (allowedContacts != null) {
+                                ContentValues contactsValues = new ContentValues();
+                                for (int i = 0; i < allowedContacts.length; i++) {
+                                    contactsValues.put("settings_id", id);
+                                    contactsValues.put("contact_id", allowedContacts[i]);
+                                    if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                        throw new Exception(
+                                                "PrivacyPersistenceAdapter:saveSettings: failed to update database entry (contacts)");
+                                }
+                            }
+
+                        } else { // new entry -> insert if no duplicates exist
+                            // Log.d(TAG,
+                            // "saveSettings - new entry; verifying if duplicates exist");
+                            cursor = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?",
+                                    new String[] { s.getPackageName() }, null, null, null);
+
+                            if (cursor != null) {
+                                if (cursor.getCount() == 1) { // exactly one entry
+                                    // exists -> update
+                                    // Log.d(TAG, "saveSettings - updating existing entry");
+                                    if (db.update(TABLE_SETTINGS, values, "packageName=?",
+                                            new String[] { s.getPackageName() }) < 1) {
+                                        throw new Exception("saveSettings - failed to update database entry");
+                                    }
+
+                                    if (cursor.moveToFirst()) {
+                                        Integer idAlt = cursor.getInt(0); // id of the found
+                                        // duplicate entry
+                                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?",
+                                                new String[] { idAlt.toString() });
+                                        int[] allowedContacts = s.getAllowedContacts();
+                                        if (allowedContacts != null) {
+                                            ContentValues contactsValues = new ContentValues();
+                                            for (int i = 0; i < allowedContacts.length; i++) {
+                                                contactsValues.put("settings_id", idAlt);
+                                                contactsValues.put("contact_id", allowedContacts[i]);
+                                                if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                                    throw new Exception(
+                                                            "saveSettings - failed to update database entry (contacts)");
+                                            }
+                                        }
+                                    }
+                                } else if (cursor.getCount() == 0) { // no entries -> insert
+                                    // Log.d(TAG, "saveSettings - inserting new entry");
+                                    long rowId = db.insert(TABLE_SETTINGS, null, values);
+                                    if (rowId == -1) {
+                                        throw new Exception(
+                                                "PrivacyPersistenceAdapter:saveSettings - failed to insert new record into DB");
+                                    }
+
+                                    db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?",
+                                            new String[] { Long.toString(rowId) });
+                                    int[] allowedContacts = s.getAllowedContacts();
+                                    if (allowedContacts != null) {
+                                        ContentValues contactsValues = new ContentValues();
+                                        for (int i = 0; i < allowedContacts.length; i++) {
+                                            contactsValues.put("settings_id", rowId);
+                                            contactsValues.put("contact_id", allowedContacts[i]);
+                                            if (db.insert(TABLE_ALLOWED_CONTACTS, null, contactsValues) == -1)
+                                                throw new Exception(
+                                                        "PrivacyPersistenceAdapter:saveSettings:failed to update database entry (contacts)");
+                                        }
+                                    }
+                                } else {
+                                    // something went totally wrong and there are
+                                    // multiple entries for same identifier
+                                    throw new Exception("PrivacyPersistenceAdapter:saveSettings:duplicate entries in the privacy.db");
+                                }
+                            } else {
+                                // jump to catch block to avoid marking transaction as
+                                // successful
+                                throw new Exception("PrivacyPersistenceAdapter:saveSettings:cursor is null, database access failed");
+                            }
+                        }
+
+                        // save settings to plain text file (for access from core libraries)
+                        if (!writeExternalSettings("systemLogsSetting", packageName, s)) {
+                            throw new Exception("PrivacyPersistenceAdapter:saveSettings:failed to write systemLogsSettings file");
+                        }
+                        if (!writeExternalSettings("ipTableProtectSetting", packageName, s)) {
+                            throw new Exception("PrivacyPersistenceAdapter:saveSettings:failed to write ipTableProtectSetting file");
+                        }
+
+                        // mark DB transaction successful (commit the changes)
+                        db.setTransactionSuccessful();
+                        
+                        if (useCache) {
+                            //TODO: determine where this should actually go (i.e. should we delete from cache even if we fail to save the settings?)
+                            settingsCache.remove(packageName);
+                            if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Cache remove for" + packageName);
+                        }
+                    } finally {
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (pre)end");
+                        db.endTransaction(); // we want to transition from set transaction successful to end as fast as possible to avoid errors (see the Android docs)
+                        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: Transaction: (post)end");
+                        
+                        if (cursor != null) {
+                            cursor.close();
+                        }
+                    }
+                } finally {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (pre)unlock");
+                    sDbLock.writeLock().unlock();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:saveSettings: WriteLock: (post)unlock");
+                }
+                result = true;
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "PrivacyPersistenceAdapter:saveSettings: saving for " + packageName + " failed", e);
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return result;
+    }
+
+    /**
+     * This method creates external settings files for access from core libraries
+     * 
+     * @param settingsName
+     *            field name from database
+     * @param packageName
+     *            name of package
+     * @param s
+     *            settings from package
+     * @return true if file was successful written
+     * @throws Exception
+     *             if we cannot write settings to directory
+     */
+    private boolean writeExternalSettings(String settingsName, String packageName, PrivacySettings s)
+            throws Exception {
+        // save settings to plain text file (for access from core libraries)
+        File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+        File systemLogsSettingFile = new File("/data/system/privacy/" + packageName + "/" + "/"
+                + settingsName);
+        boolean result = false;
+        
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (pre)lock");
+        sDbLock.writeLock().lock();
+        if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (post)lock");
+        try {
+            settingsPackageDir.mkdirs();
+            settingsPackageDir.setReadable(true, false);
+            settingsPackageDir.setExecutable(true, false);
+            // create the setting files and make them readable
+            systemLogsSettingFile.createNewFile();
+            systemLogsSettingFile.setReadable(true, false);
+            // write settings to files
+            // Log.d(TAG, "saveSettings - writing to file");
+            OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(
+                    systemLogsSettingFile));
+            // now decide which feature of setting we have to save
+            if (settingsName.equals("systemLogsSetting"))
+                writer.append(s.getSystemLogsSetting() + "");
+            else if (settingsName.equals("ipTableProtectSetting"))
+                writer.append(s.getIpTableProtectSetting() + "");
+            writer.flush();
+            writer.close();
+            result = true;
+        } catch (IOException e) {
+            // jump to catch block to avoid marking transaction as successful
+            throw new Exception("saveSettings - could not write settings to file", e);
+        } finally {
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (pre)unlock");
+            sDbLock.writeLock().unlock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:writeExternalSettings: WriteLock: (post)unlock");
+        }
+        
+        return true;
+    }
+
+    /**
+     * Deletes a settings entry from the DB
+     * 
+     * @return true if settings were deleted successfully, false otherwise
+     */
+    public boolean deleteSettings(String packageName) {
+        boolean result = true;
+
+        SQLiteDatabase db = null;
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+            db = getDatabase();
+
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (pre)lock");
+            sDbLock.writeLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (post)lock");
+            try {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (pre)begin");
+                db.beginTransaction();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (post)begin");
+                // make sure this ends up in a consistent state
+                try {
+                    // try deleting contacts allowed entries; do not fail if deletion
+                    // not possible
+                    // TODO: restructure this into a more efficient query (ideally a
+                    // single query without a cursor)
+                    Cursor c = db.query(TABLE_SETTINGS, new String[] { "_id" }, "packageName=?",
+                            new String[] { packageName }, null, null, null);
+
+
+                    if (c != null && c.getCount() > 0 && c.moveToFirst()) {
+                        int id = c.getInt(0);
+                        db.delete(TABLE_ALLOWED_CONTACTS, "settings_id=?",
+                                new String[] { Integer.toString(id) });
+                        c.close();
+                    } else {
+                        Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                    }
+
+                    if (db.delete(TABLE_SETTINGS, "packageName=?", new String[] { packageName }) == 0) {
+                        Log.e(TAG, "deleteSettings - database entry for " + packageName + " not found");
+                    }
+
+                    // delete settings from plain text file (for access from core
+                    // libraries)
+                    File settingsPackageDir = new File("/data/system/privacy/" + packageName + "/");
+                    File systemLogsSettingFile = new File("/data/system/privacy/" + packageName
+                            + "/systemLogsSetting");
+
+                    // delete the setting files
+                    systemLogsSettingFile.delete();
+                    // delete the parent directories
+                    if (settingsPackageDir.list() == null || settingsPackageDir.list().length == 0)
+                        settingsPackageDir.delete();
+
+                    db.setTransactionSuccessful();
+
+                    if (useCache) {
+                        //TODO: determine where this should actually go (i.e. should we delete from cache even if we fail to delete the settings?)
+                        settingsCache.remove(packageName);
+                        if (LOG_CACHE) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Cache remove for" + packageName);
+                    }
+                } finally {
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (pre)end");
+                    db.endTransaction();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: Transaction: (post)end");
+                }
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (pre)unlock");
+                sDbLock.writeLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:deleteSettings: WriteLock: (post)unlock");
+            }
+        } catch (SQLiteException e) {
+            result = false;
+            Log.e(TAG, "PrivacyPersistenceAdapter:deleteSettings: failed to open the database, or open a transaction", e);
+        } catch (Exception e) {
+            result = false;
+            Log.e(TAG, "PrivacyPersistenceAdapter:deleteSettings - could not delete settings", e);
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return result;
+    }
+
+    private Cursor query(SQLiteDatabase db, String table, String[] columns, String selection,
+            String[] selectionArgs, String groupBy, String having, String orderBy, String limit)
+            throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of
+        // IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null)
+                    c.close();
+                c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy,
+                        limit);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen())
+                    db.close();
+                db = getDatabase();
+            }
+        }
+        if (success == false)
+            throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+
+    private Cursor rawQuery(SQLiteDatabase db, String sql) throws Exception {
+        Cursor c = null;
+        // make sure getting settings does not fail because of
+        // IllegalStateException (db already closed)
+        boolean success = false;
+        for (int i = 0; success == false && i < RETRY_QUERY_COUNT; i++) {
+            try {
+                if (c != null)
+                    c.close();
+                c = db.rawQuery(sql, null);
+                success = true;
+            } catch (IllegalStateException e) {
+                success = false;
+                if (db != null && db.isOpen())
+                    db.close();
+                db = getDatabase();
+            }
+        }
+        if (success == false)
+            throw new Exception("query - failed to execute query on the DB");
+        return c;
+    }
+
+    /**
+     * Removes obsolete entries from the DB and file system. Should not be used
+     * in methods, which rely on the DB being open after this method has
+     * finished. It will close the DB if no other threads has increased the
+     * readingThread count.
+     * 
+     * @return true if purge was successful, false otherwise.
+     */
+    public boolean purgeSettings() {
+        boolean result = true;
+
+        // get installed apps
+        Set<String> apps = new HashSet<String>();
+        PackageManager pMan = mContext.getPackageManager();
+        List<ApplicationInfo> installedApps = pMan.getInstalledApplications(0);
+        for (ApplicationInfo appInfo : installedApps) {
+            apps.add(appInfo.packageName);
+        }
+
+        SQLiteDatabase db = null;
+
+        try {
+            synchronized (sDbAccessThreads) {
+                sDbAccessThreads++;
+            }
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Increment DB access threads: now " + Integer.toString(sDbAccessThreads));
+            
+            // delete obsolete entries from DB and update outdated entries
+            db = getDatabase();
+            if (db == null) {
+                Log.e(TAG, "PrivacyPersistenceAdapter:purgeSettings: db could not be obtained");
+                return false;
+            }
+
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (pre)lock");
+            sDbLock.writeLock().lock();
+            if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (post)lock");
+            try {
+                Cursor cursor = null;
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (pre)begin");
+                db.beginTransaction();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (post)begin");
+                try {
+                    cursor = query(db, TABLE_SETTINGS, new String[] { "packageName" }, null, null, null, null,
+                            null, null);
+                    if (cursor != null && cursor.getCount() > 0 && cursor.moveToFirst()) {
+                        do {
+                            String packageName = cursor.getString(0);
+                            if (!apps.contains(packageName)) {
+                                db.delete(TABLE_SETTINGS, "packageName = ?", new String [] { packageName });
+                            }
+                        } while (cursor.moveToNext());
+                    }
+
+                    // delete obsolete settings directories
+                    File settingsDir = new File(SETTINGS_DIRECTORY);
+                    for (File packageDir : settingsDir.listFiles()) {
+                        String packageName = packageDir.getName();
+                        if (!apps.contains(packageName)) { // remove package dir if no such
+                            // app installed
+                            deleteRecursive(packageDir);
+                        }
+                    }
+
+                    db.setTransactionSuccessful();
+                } finally {
+                    if (cursor != null) {
+                        cursor.close();
+                    }
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (pre)end");
+                    db.endTransaction();
+                    if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: Transaction: (post)end");
+                }
+            } finally {
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (pre)unlock");
+                sDbLock.writeLock().unlock();
+                if (LOG_LOCKING) Log.d(TAG, "PrivacyPersistenceAdapter:purgeSettings: WriteLock: (post)unlock");
+            }
+        } catch (Exception e) {
+            Log.e(TAG, "PrivacyPersistenceAdapter:purgeSettings - purging DB failed", e);
+            result = false;
+        } finally {
+            closeIdleDatabase();
+        }
+
+        return result;
+    }
+    
+
+    private void deleteRecursive(File fileOrDirectory) {
+        if (fileOrDirectory.isDirectory()) {
+            for (File child : fileOrDirectory.listFiles())
+                deleteRecursive(child);
+        }
+        fileOrDirectory.delete();
+    }
+
+    private void createDatabase() {
+        Log.i(TAG, "createDatabase - creating privacy database file");
+        try {
+            SQLiteDatabase db = SQLiteDatabase.openDatabase(DATABASE_FILE, null,
+                    SQLiteDatabase.OPEN_READWRITE | SQLiteDatabase.CREATE_IF_NECESSARY);
+            Log.i(TAG, "createDatabase - creating privacy database");
+            db.execSQL(CREATE_TABLE_SETTINGS);
+            db.execSQL(CREATE_TABLE_ALLOWED_CONTACTS);
+            db.execSQL(CREATE_TABLE_MAP);
+            db.execSQL(INSERT_VERSION);
+            db.execSQL(INSERT_ENABLED);
+            db.execSQL(INSERT_NOTIFICATIONS_ENABLED);
+            // Log.d(TAG, "createDatabase - closing connection to privacy.db");
+            if (db != null && db.isOpen())
+                db.close();
+        } catch (SQLException e) {
+            Log.e(TAG, "createDatabase - failed to create privacy database", e);
+        }
+    }
+
+    private void createSettingsDir() {
+        // create settings directory (for settings accessed from core libraries)
+        File settingsDir = new File("/data/system/privacy/");
+        settingsDir.mkdirs();
+        // make it readable for everybody
+        settingsDir.setReadable(true, false);
+        settingsDir.setExecutable(true, false);
+    }
+
+    private synchronized SQLiteDatabase getDatabase() {
+        if (mDb == null || !mDb.isOpen() || mDb.isReadOnly()) {
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:closeIdleDatabase: Opening privacy database");
+            mDb = SQLiteDatabase.openDatabase(DATABASE_FILE, null, SQLiteDatabase.OPEN_READWRITE);
+        }   
+        return mDb;
+    }
+
+    /**
+     * If there are no more threads reading the database, close it. Otherwise,
+     * reduce the number of reading threads by one
+     */
+    private void closeIdleDatabase() {
+        synchronized (sDbAccessThreads) {
+            sDbAccessThreads--;
+            if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:closeIdleDatabase: Decrement DB access threads: now " + Integer.toString(sDbAccessThreads));
+            // only close DB if no other threads are reading
+            if (sDbAccessThreads == 0 && mDb != null && mDb.isOpen()) {
+                if (autoCloseDb) { 
+                    if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:closeIdleDatabase: Closing the PDroid database");
+                    mDb.close();
+                } else {
+                    if (LOG_OPEN_AND_CLOSE) Log.d(TAG, "PrivacyPersistenceAdapter:closeIdleDatabase: Open and close DB disabled: not closing");
+                }
+            }
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettings.aidl b/privacy/java/android/privacy/PrivacySettings.aidl
new file mode 100644
index 0000000..c114960
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.aidl
@@ -0,0 +1,16 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+/** {@hide} */
+parcelable PrivacySettings;
diff --git a/privacy/java/android/privacy/PrivacySettings.java b/privacy/java/android/privacy/PrivacySettings.java
new file mode 100644
index 0000000..554703c
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettings.java
@@ -0,0 +1,1027 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.util.Log;
+
+import java.math.BigDecimal;
+import java.util.List;
+import java.util.Random;
+
+/**
+ * Holds privacy settings for access to all private data types for a single application
+ * @author Svyatoslav Hresyk 
+ * {@hide} 
+ */
+public final class PrivacySettings extends PrivacySettingsStub implements Parcelable {
+
+        /**
+     * Real value, provided by the unmodified Android framework.
+     */
+    public static final byte REAL = 0;
+    
+    /**
+     * Empty or unavailable, depending on setting type. For String settings, it is
+     * setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain an empty String.
+     */
+    public static final byte EMPTY = 1;
+    
+    /**
+     * Custom specified output, appropriate for relevant setting. For String settings, 
+     * it is setter method caller's responsibility to make sure that the corresponding 
+     * setting field will contain a custom String.
+     */
+    public static final byte CUSTOM = 2;
+    
+    /**
+     * Random output, appropriate for relevant setting. When this option is set, the
+     * corresponding getter methods will generate appropriate random values automatically.
+     * 
+     * Device ID: a random string consisting of 15 numeric digits preceded by a "+"
+     * Line1Number: a random string consisting of 13 numeric digits
+     */
+    public static final byte RANDOM = 3;
+    
+    public static final byte SETTING_NOTIFY_OFF = 0;
+    public static final byte SETTING_NOTIFY_ON = 1;
+    
+    /** used to create random android ID*/
+    public static final String[] ID_PATTERN = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};
+    
+    // constants for identification of data types transmitted in the notification intent
+    public static final String DATA_DEVICE_ID = "deviceID";
+    public static final String DATA_LINE_1_NUMBER = "line1Number";
+    public static final String DATA_LOCATION_GPS = "locationGPS";
+    public static final String DATA_LOCATION_NETWORK = "locationNetwork";
+    public static final String DATA_NETWORK_INFO_CURRENT = "networkInfoCurrent";
+    public static final String DATA_NETWORK_INFO_SIM = "networkInfoSIM";
+    public static final String DATA_SIM_SERIAL = "simSerial";
+    public static final String DATA_SUBSCRIBER_ID = "subscriberID";
+    public static final String DATA_ACCOUNTS_LIST = "accountsList";
+    public static final String DATA_AUTH_TOKENS = "authTokens";
+    public static final String DATA_OUTGOING_CALL = "outgoingCall";
+    public static final String DATA_INCOMING_CALL = "incomingCall";
+    public static final String DATA_CONTACTS = "contacts";
+    public static final String DATA_CALENDAR = "calendar";
+    public static final String DATA_MMS = "mms";
+    public static final String DATA_SMS = "sms";
+    public static final String DATA_MMS_SMS = "mmsSms";
+    public static final String DATA_CALL_LOG = "callLog";
+    public static final String DATA_BOOKMARKS = "bookmarks";
+    public static final String DATA_SYSTEM_LOGS = "systemLogs";
+    public static final String DATA_INTENT_BOOT_COMPLETED = "intentBootCompleted";
+//    public static final String DATA_EXTERNAL_STORAGE = "externalStorage";
+    public static final String DATA_CAMERA = "camera";
+    public static final String DATA_RECORD_AUDIO = "recordAudio";
+    public static final String DATA_SMS_SEND = "SmsSend";
+    public static final String DATA_PHONE_CALL = "phoneCall";
+    public static final String DATA_ANDROID_ID = "android_id";
+    public static final String DATA_ICC_ACCESS = "iccAccess";
+    public static final String DATA_WIFI_INFO = "wifiInfo";
+    public static final String DATA_IP_TABLES = "iptables";
+    public static final String DATA_SWITCH_CONNECTIVITY = "switchconnectivity";
+    public static final String DATA_SEND_MMS = "sendMms";
+    public static final String DATA_SWITCH_WIFI_STATE = "switchWifiState";
+    
+    // Database entry ID
+    private final Integer _id;
+    
+    // Application identifiers
+    private String packageName;
+    private int uid;
+    
+    //
+    // Privacy settings
+    //
+    
+    private byte deviceIdSetting;
+    private String deviceId;
+    
+    // Phone and Voice Mailbox Number
+    private byte line1NumberSetting; 
+    private String line1Number;
+    
+    private byte locationGpsSetting;
+    private String locationGpsLat;
+    private String locationGpsLon;
+    private byte locationNetworkSetting;
+    private String locationNetworkLat;
+    private String locationNetworkLon;
+    
+    // CountryIso, Operator Code, Operator Name
+    private byte networkInfoSetting;
+    private byte simInfoSetting;
+    
+    private byte simSerialNumberSetting;
+    private String simSerialNumber;
+    private byte subscriberIdSetting;
+    private String subscriberId;
+    
+    private byte accountsSetting;
+    private byte accountsAuthTokensSetting;
+    private byte outgoingCallsSetting;
+    private byte incomingCallsSetting;
+    
+    private byte contactsSetting;
+    private byte calendarSetting;
+    private byte mmsSetting;
+    private byte smsSetting;
+    private byte callLogSetting;
+    private byte bookmarksSetting; // browser bookmarks and history
+    
+    private byte systemLogsSetting;
+    
+    private byte notificationSetting;
+    
+    private byte intentBootCompletedSetting;
+//    private byte externalStorageSetting;
+    private byte cameraSetting;
+    private byte recordAudioSetting;
+    private byte smsSendSetting;
+    private byte phoneCallSetting;
+
+    private byte ipTableProtectSetting;
+    private byte iccAccessSetting;
+    private byte addOnManagementSetting;
+    
+    private byte androidIdSetting;
+    private String androidID;
+    
+    private byte wifiInfoSetting;
+    
+    private byte switchConnectivitySetting;
+    
+    private byte sendMmsSetting;
+    
+    private byte forceOnlineState; //used to fake online state
+    
+    private byte switchWifiStateSetting;
+   
+
+	private int[] allowedContacts;
+	
+	/**
+	 * Constructor to set all Values REAL
+	 * @param _id id in database
+	 * @param packageName	packagename of the app
+	 * @param uid uid of application
+	 * {@hide}
+	 */
+    public PrivacySettings(Integer _id, String packageName, int uid) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = REAL;
+        this.deviceId = null;
+        this.line1NumberSetting = REAL;
+        this.line1Number = null;
+        this.locationGpsSetting = REAL;
+        this.locationGpsLat = null;
+        this.locationGpsLon = null;
+        this.locationNetworkSetting = REAL;
+        this.locationNetworkLat = null;
+        this.locationNetworkLon = null;
+        this.networkInfoSetting = REAL;
+        this.simInfoSetting = REAL;
+        this.simSerialNumberSetting = REAL;
+        this.simSerialNumber = null;
+        this.subscriberIdSetting = REAL;
+        this.subscriberId = null;
+        this.accountsSetting = REAL;
+        this.accountsAuthTokensSetting = REAL;
+        this.outgoingCallsSetting = REAL;
+        this.incomingCallsSetting = REAL;
+        this.contactsSetting = REAL;
+        this.calendarSetting = REAL;
+        this.mmsSetting = REAL;
+        this.smsSetting = REAL;
+        this.callLogSetting = REAL;
+        this.bookmarksSetting = REAL;
+        this.systemLogsSetting = REAL;
+        this.notificationSetting = SETTING_NOTIFY_OFF;
+        this.intentBootCompletedSetting = REAL;
+//        this.externalStorageSetting = REAL;
+        this.cameraSetting = REAL; 
+        this.recordAudioSetting = REAL;
+        this.allowedContacts = null;
+        this.smsSendSetting = REAL;
+        this.phoneCallSetting = REAL;
+        this.ipTableProtectSetting = REAL;
+        this.iccAccessSetting = REAL;
+        this.addOnManagementSetting = EMPTY;
+        this.androidIdSetting = REAL;
+        this.androidID = null;
+        this.wifiInfoSetting = REAL;
+        this.switchConnectivitySetting = REAL;
+        this.sendMmsSetting = REAL;
+        this.forceOnlineState = EMPTY;
+        this.switchWifiStateSetting = REAL;
+    }
+    
+    /**
+     * Constructor for two possibilities:<br>
+     * 1. pass allEmpty = true for set all values to empty
+     * 2. pass allEmpty = false for set all possible values to RANDOM 
+     * @param _id id in database
+     * @param packageName packagename of application
+     * @param uid the uid of application
+     * @param allEmpty see description above
+     * {@hide}
+     */
+    public PrivacySettings(Integer _id, String packageName, int uid, boolean allEmpty) {
+        this._id = _id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        if(allEmpty){
+        	this.deviceIdSetting = EMPTY;
+	        this.deviceId = null;
+	        this.line1NumberSetting = EMPTY;
+	        this.line1Number = null;
+	        this.locationGpsSetting = EMPTY;
+	        this.locationGpsLat = null;
+	        this.locationGpsLon = null;
+	        this.locationNetworkSetting = EMPTY;
+	        this.locationNetworkLat = null;
+	        this.locationNetworkLon = null;
+	        this.networkInfoSetting = EMPTY;
+	        this.simInfoSetting = EMPTY;
+	        this.simSerialNumberSetting = EMPTY;
+	        this.simSerialNumber = null;
+	        this.subscriberIdSetting = EMPTY;
+	        this.subscriberId = null;
+	        this.accountsSetting = EMPTY;
+	        this.accountsAuthTokensSetting = EMPTY;
+	        this.outgoingCallsSetting = EMPTY;
+	        this.incomingCallsSetting = EMPTY;
+	        this.contactsSetting = EMPTY;
+	        this.calendarSetting = EMPTY;
+	        this.mmsSetting = EMPTY;
+	        this.smsSetting = EMPTY;
+	        this.callLogSetting = EMPTY;
+	        this.bookmarksSetting = EMPTY;
+	        this.systemLogsSetting = EMPTY;
+	        this.notificationSetting = SETTING_NOTIFY_OFF;
+	        this.intentBootCompletedSetting = EMPTY;
+	//        this.externalStorageSetting = REAL;
+	        this.cameraSetting = EMPTY;
+	        this.recordAudioSetting = EMPTY;
+	        this.allowedContacts = null;
+	        this.smsSendSetting = EMPTY;
+	        this.phoneCallSetting = EMPTY;
+	        this.ipTableProtectSetting = EMPTY;
+	        this.iccAccessSetting = EMPTY;
+	        this.addOnManagementSetting = EMPTY;
+	        this.androidIdSetting = EMPTY;
+	        this.androidID = null;
+	        this.wifiInfoSetting = EMPTY;
+	        this.switchConnectivitySetting = EMPTY;
+	        this.sendMmsSetting = EMPTY;
+	        this.forceOnlineState = REAL;
+	        this.switchWifiStateSetting = EMPTY;
+        } else {
+        	this.deviceIdSetting = RANDOM;
+	        this.deviceId = null;
+	        this.line1NumberSetting = RANDOM;
+	        this.line1Number = null;
+	        this.locationGpsSetting = RANDOM;
+	        this.locationGpsLat = null;
+	        this.locationGpsLon = null;
+	        this.locationNetworkSetting = RANDOM;
+	        this.locationNetworkLat = null;
+	        this.locationNetworkLon = null;
+	        this.networkInfoSetting = EMPTY;
+	        this.simInfoSetting = EMPTY;
+	        this.simSerialNumberSetting = RANDOM;
+	        this.simSerialNumber = null;
+	        this.subscriberIdSetting = RANDOM;
+	        this.subscriberId = null;
+	        this.accountsSetting = EMPTY;
+	        this.accountsAuthTokensSetting = EMPTY;
+	        this.outgoingCallsSetting = EMPTY;
+	        this.incomingCallsSetting = EMPTY;
+	        this.contactsSetting = EMPTY;
+	        this.calendarSetting = EMPTY;
+	        this.mmsSetting = EMPTY;
+	        this.smsSetting = EMPTY;
+	        this.callLogSetting = EMPTY;
+	        this.bookmarksSetting = EMPTY;
+	        this.systemLogsSetting = EMPTY;
+	        this.notificationSetting = SETTING_NOTIFY_OFF;
+	        this.intentBootCompletedSetting = EMPTY;
+	//        this.externalStorageSetting = REAL;
+	        this.cameraSetting = EMPTY;
+	        this.recordAudioSetting = EMPTY;
+	        this.allowedContacts = null;
+	        this.smsSendSetting = EMPTY;
+	        this.phoneCallSetting = EMPTY;
+	        this.ipTableProtectSetting = EMPTY;
+	        this.iccAccessSetting = EMPTY;
+	        this.addOnManagementSetting = EMPTY;
+	        this.androidIdSetting = RANDOM;
+	        this.androidID = null;
+	        this.wifiInfoSetting = EMPTY;
+	        this.switchConnectivitySetting = EMPTY;
+	        this.sendMmsSetting = EMPTY;
+	        this.forceOnlineState = REAL;
+	        this.switchWifiStateSetting = EMPTY;
+        }
+    }
+    
+    
+    public PrivacySettings(Integer id, String packageName, int uid, byte deviceIdSetting, String deviceId,
+            byte line1NumberSetting, String line1Number, byte locationGpsSetting, String locationGpsLat,
+            String locationGpsLon, byte locationNetworkSetting, String locationNetworkLat, 
+            String locationNetworkLon, byte networkInfoSetting, byte simInfoSetting, byte simSerialNumberSetting,
+            String simSerialNumber, byte subscriberIdSetting, String subscriberId, byte accountsSetting, 
+            byte accountsAuthTokensSetting, byte outgoingCallsSetting, byte incomingCallsSetting, byte contactsSetting,
+            byte calendarSetting, byte mmsSetting, byte smsSetting, byte callLogSetting, byte bookmarksSetting, 
+            byte systemLogsSetting, byte externalStorageSetting, byte cameraSetting, byte recordAudioSetting, 
+            byte notificationSetting, byte intentBootCompletedSetting, int[] allowedContacts, byte smsSendSetting, byte phoneCallSetting, byte ipTableProtectSetting,
+            byte iccAccessSetting, byte addOnManagementSetting, byte androidIdSetting, String androidID, byte wifiInfoSetting, byte switchConnectivitySetting, byte sendMmsSetting,
+            byte forceOnlineState, byte switchWifiStateSetting) {
+        this._id = id;
+        
+        this.packageName = packageName;
+        this.uid = uid;
+        
+        this.deviceIdSetting = deviceIdSetting;
+        this.deviceId = deviceId;
+        this.line1NumberSetting = line1NumberSetting;
+        this.line1Number = line1Number;
+        this.locationGpsSetting = locationGpsSetting;
+        this.locationGpsLat = locationGpsLat;
+        this.locationGpsLon = locationGpsLon;
+        this.locationNetworkSetting = locationNetworkSetting;
+        this.locationNetworkLat = locationNetworkLat;
+        this.locationNetworkLon = locationNetworkLon;
+        this.networkInfoSetting = networkInfoSetting;
+        this.simInfoSetting = simInfoSetting;
+        this.simSerialNumberSetting = simSerialNumberSetting;
+        this.simSerialNumber = simSerialNumber;
+        this.subscriberIdSetting = subscriberIdSetting;
+        this.subscriberId = subscriberId;
+        this.accountsSetting = accountsSetting;
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+        this.outgoingCallsSetting = outgoingCallsSetting;
+        this.incomingCallsSetting = incomingCallsSetting;
+        this.contactsSetting = contactsSetting;
+        this.calendarSetting = calendarSetting;
+        this.mmsSetting = mmsSetting;
+        this.smsSetting = smsSetting;
+        this.callLogSetting = callLogSetting;
+        this.bookmarksSetting = bookmarksSetting;
+        this.systemLogsSetting = systemLogsSetting;
+        this.notificationSetting = notificationSetting;
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+//        this.externalStorageSetting = externalStorageSetting;
+        this.cameraSetting = cameraSetting;
+        this.recordAudioSetting = recordAudioSetting;
+        this.allowedContacts = allowedContacts;
+        this.smsSendSetting = smsSendSetting;
+        this.phoneCallSetting = phoneCallSetting;
+        this.ipTableProtectSetting = ipTableProtectSetting;
+        this.iccAccessSetting = iccAccessSetting;
+        this.addOnManagementSetting = addOnManagementSetting;
+        this.androidIdSetting = androidIdSetting;
+        this.androidID = androidID;
+        this.wifiInfoSetting = wifiInfoSetting;
+        this.switchConnectivitySetting = switchConnectivitySetting;
+        this.sendMmsSetting = sendMmsSetting;
+        this.forceOnlineState = forceOnlineState;
+        this.switchWifiStateSetting = switchWifiStateSetting;
+    }
+    
+    public byte getSwitchWifiStateSetting() {
+		return switchWifiStateSetting;
+	}
+
+	public void setSwitchWifiStateSetting(byte switchWifiStateSetting) {
+		this.switchWifiStateSetting = switchWifiStateSetting;
+	}
+    
+    public byte getForceOnlineState() {
+		return forceOnlineState;
+	}
+
+	public void setForceOnlineState(byte forceOnlineState) {
+		this.forceOnlineState = forceOnlineState;
+	}
+
+	public byte getSendMmsSetting() {
+		return sendMmsSetting;
+	}
+
+	public void setSendMmsSetting(byte sendMmsSetting) {
+		this.sendMmsSetting = sendMmsSetting;
+	}
+
+	public byte getSwitchConnectivitySetting() {
+		return switchConnectivitySetting;
+	}
+
+	public void setSwitchConnectivitySetting(byte switchConnectivitySetting) {
+		this.switchConnectivitySetting = switchConnectivitySetting;
+	}
+    
+    public byte getAndroidIdSetting() {
+		return androidIdSetting;
+	}
+
+	public void setAndroidIdSetting(byte androidIdSetting) {
+		this.androidIdSetting = androidIdSetting;
+	}
+	
+	/**
+	 * @return random ID, constant fake id or null
+	 */
+	public String getAndroidID() {
+		if(androidIdSetting == EMPTY) return "q4a5w896ay21dr46"; //we can not pull out empty android id, because we get bootlops then
+		if(androidIdSetting == RANDOM) {
+			Random value = new Random();
+			StringBuilder localBuilder = new StringBuilder();
+			for(int i = 0; i < ID_PATTERN.length; i++)
+				localBuilder.append(ID_PATTERN[value.nextInt(ID_PATTERN.length-1)]);
+			return localBuilder.toString();
+		}
+		return androidID;
+	}
+	
+	public byte getWifiInfoSetting() {
+		return wifiInfoSetting;
+	}
+
+	public void setWifiInfoSetting(byte wifiInfoSetting) {
+		this.wifiInfoSetting = wifiInfoSetting;
+	}
+
+	public void setAndroidID(String androidID) {
+		this.androidID = androidID;
+	}
+    
+    public byte getIpTableProtectSetting() {
+		return ipTableProtectSetting;
+	}
+
+	public void setIpTableProtectSetting(byte ipTableProtectSetting) {
+		this.ipTableProtectSetting = ipTableProtectSetting;
+	}
+
+	public byte getIccAccessSetting() {
+		return iccAccessSetting;
+	}
+
+	public void setIccAccessSetting(byte iccAccessSetting) {
+		this.iccAccessSetting = iccAccessSetting;
+	}
+
+	public byte getAddOnManagementSetting() {
+		return addOnManagementSetting;
+	}
+
+	public void setAddOnManagementSetting(byte addOnManagementSetting) {
+		this.addOnManagementSetting = addOnManagementSetting;
+	}
+    public byte getSmsSendSetting(){
+	return smsSendSetting;
+    }
+
+    public void setSmsSendSetting(byte smsSendSetting){
+	this.smsSendSetting = smsSendSetting;
+    }
+
+    public byte getPhoneCallSetting(){
+	return phoneCallSetting;
+    }
+
+    public void setPhoneCallSetting(byte phoneCallSetting){
+	this.phoneCallSetting = phoneCallSetting;
+    }
+
+    public byte getRecordAudioSetting(){
+	return recordAudioSetting;
+    }
+
+    public void setRecordAudioSetting(byte recordAudioSetting){
+	this.recordAudioSetting = recordAudioSetting;
+    }
+
+    public byte getCameraSetting(){
+	return cameraSetting;
+    }
+
+    public void setCameraSetting(byte cameraSetting){
+	this.cameraSetting = cameraSetting;
+    }
+
+    public Integer get_id() {
+        return _id;
+    }
+
+    public String getPackageName() {
+        return packageName;
+    }
+    
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    public int getUid() {
+        return uid;
+    }
+
+    public void setUid(int uid) {
+        this.uid = uid;
+    }
+
+    public byte getDeviceIdSetting() {
+        return deviceIdSetting;
+    }
+
+    public void setDeviceIdSetting(byte deviceIdSetting) {
+        this.deviceIdSetting = deviceIdSetting;
+    }
+
+    public String getDeviceId() {
+        if (deviceIdSetting == EMPTY) return "";
+        if (deviceIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 15)
+            	return rndId.substring(0, 15);
+	    else{
+		for(int i = rndId.length(); i <= 16; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 15);
+	    }
+            //return rndId.substring(0, 15);
+        }
+        return deviceId;
+    }
+
+    public void setDeviceId(String deviceId) {
+        this.deviceId = deviceId;
+    }
+
+    public byte getLine1NumberSetting() {
+        return line1NumberSetting;
+    }
+
+    public void setLine1NumberSetting(byte line1NumberSetting) {
+        this.line1NumberSetting = line1NumberSetting;
+    }
+
+    public String getLine1Number() {
+        if (line1NumberSetting == EMPTY) return "";
+        if (line1NumberSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = "+" + Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 13)
+            	return rndId.substring(0, 13);
+	    else{
+		for(int i = rndId.length(); i <= 14; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 13);
+	    }
+            //return rndId.substring(0, 13);
+        }
+        return line1Number;
+    }
+
+    public void setLine1Number(String line1Number) {
+        this.line1Number = line1Number;
+    }
+
+    public byte getLocationGpsSetting() {
+        return locationGpsSetting;
+    }
+
+    public void setLocationGpsSetting(byte locationGpsSetting) {
+        this.locationGpsSetting = locationGpsSetting;
+    }
+    
+    public String getLocationGpsLat() {
+        if (locationGpsSetting == EMPTY) return "";
+        if (locationGpsSetting == RANDOM) return getRandomLat();
+        return locationGpsLat;
+    }
+
+    public void setLocationGpsLat(String locationGpsLat) {
+        this.locationGpsLat = locationGpsLat;
+    }
+
+    public String getLocationGpsLon() {
+        if (locationGpsSetting == EMPTY) return "";        
+        if (locationGpsSetting == RANDOM) return getRandomLon();
+        return locationGpsLon;
+    }
+
+    public void setLocationGpsLon(String locationGpsLon) {
+        this.locationGpsLon = locationGpsLon;
+    }
+
+    public byte getLocationNetworkSetting() {
+        return locationNetworkSetting;
+    }
+
+    public void setLocationNetworkSetting(byte locationNetworkSetting) {
+        this.locationNetworkSetting = locationNetworkSetting;
+    }
+
+    public String getLocationNetworkLat() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLat();  
+        return locationNetworkLat;
+    }
+
+    public void setLocationNetworkLat(String locationNetworkLat) {
+        this.locationNetworkLat = locationNetworkLat;
+    }
+
+    public String getLocationNetworkLon() {
+        if (locationNetworkSetting == EMPTY) return "";
+        if (locationNetworkSetting == RANDOM) return getRandomLon();
+        return locationNetworkLon;
+    }
+
+    public void setLocationNetworkLon(String locationNetworkLon) {
+        this.locationNetworkLon = locationNetworkLon;
+    }
+
+    public byte getNetworkInfoSetting() {
+        return networkInfoSetting;
+    }
+
+    public void setNetworkInfoSetting(byte networkInfoSetting) {
+        this.networkInfoSetting = networkInfoSetting;
+    }
+
+    public byte getSimInfoSetting() {
+        return simInfoSetting;
+    }
+
+    public void setSimInfoSetting(byte simInfoSetting) {
+        this.simInfoSetting = simInfoSetting;
+    }
+
+    public byte getSimSerialNumberSetting() {
+        return simSerialNumberSetting;
+    }
+
+    public void setSimSerialNumberSetting(byte simSerialNumberSetting) {
+        this.simSerialNumberSetting = simSerialNumberSetting;
+    }
+
+    public String getSimSerialNumber() {
+        if (simSerialNumberSetting == EMPTY) return "";
+        if (simSerialNumberSetting == RANDOM) {
+            Random rnd = new Random();
+            return Math.abs(rnd.nextLong()) + "";
+        }
+        return simSerialNumber;
+    }
+
+    public void setSimSerialNumber(String simSerialNumber) {
+        this.simSerialNumber = simSerialNumber;
+    }
+
+    public byte getSubscriberIdSetting() {
+        return subscriberIdSetting;
+    }
+
+    public void setSubscriberIdSetting(byte subscriberIdSetting) {
+        this.subscriberIdSetting = subscriberIdSetting;
+    }
+
+    public String getSubscriberId() {
+        if (subscriberIdSetting == EMPTY) return "";
+        if (subscriberIdSetting == RANDOM) {
+            Random rnd = new Random();
+            String rndId = Math.abs(rnd.nextLong()) + "";
+	    if(rndId.length() > 15)
+            	return rndId.substring(0, 15);
+	    else{
+		for(int i = rndId.length(); i <= 16; i++)
+			rndId += rnd.nextInt(9);
+		return rndId.substring(0, 15);
+	    }
+        }
+        return subscriberId;
+    }
+
+    public void setSubscriberId(String subscriberId) {
+        this.subscriberId = subscriberId;
+    }
+
+    public byte getAccountsSetting() {
+        return accountsSetting;
+    }
+
+    public void setAccountsSetting(byte accountsSetting) {
+        this.accountsSetting = accountsSetting;
+    }
+
+    public byte getAccountsAuthTokensSetting() {
+        return accountsAuthTokensSetting;
+    }
+
+    public void setAccountsAuthTokensSetting(byte accountsAuthTokensSetting) {
+        this.accountsAuthTokensSetting = accountsAuthTokensSetting;
+    }
+
+    public byte getOutgoingCallsSetting() {
+        return outgoingCallsSetting;
+    }
+
+    public void setOutgoingCallsSetting(byte outgoingCallsSetting) {
+        this.outgoingCallsSetting = outgoingCallsSetting;
+    }
+    
+    public byte getIncomingCallsSetting() {
+        return incomingCallsSetting;
+    }
+    
+    public void setIncomingCallsSetting(byte incomingCallsSetting) {
+        this.incomingCallsSetting = incomingCallsSetting;
+    }
+
+    public byte getContactsSetting() {
+        return contactsSetting;
+    }
+
+    public void setContactsSetting(byte contactsSetting) {
+        this.contactsSetting = contactsSetting;
+    }
+
+    public byte getCalendarSetting() {
+        return calendarSetting;
+    }
+
+    public void setCalendarSetting(byte calendarSetting) {
+        this.calendarSetting = calendarSetting;
+    }
+
+    public byte getMmsSetting() {
+        return mmsSetting;
+    }
+
+    public void setMmsSetting(byte mmsSetting) {
+        this.mmsSetting = mmsSetting;
+    }
+
+    public byte getSmsSetting() {
+        return smsSetting;
+    }
+
+    public void setSmsSetting(byte smsSetting) {
+        this.smsSetting = smsSetting;
+    }
+
+    public byte getCallLogSetting() {
+        return callLogSetting;
+    }
+
+    public void setCallLogSetting(byte callLogSetting) {
+        this.callLogSetting = callLogSetting;
+    }
+
+    public byte getBookmarksSetting() {
+        return bookmarksSetting;
+    }
+
+    public void setBookmarksSetting(byte bookmarksSetting) {
+        this.bookmarksSetting = bookmarksSetting;
+    }
+
+    public byte getSystemLogsSetting() {
+        return systemLogsSetting;
+    }
+
+    public void setSystemLogsSetting(byte systemLogsSetting) {
+        this.systemLogsSetting = systemLogsSetting;
+    }
+
+    public byte getIntentBootCompletedSetting() {
+        return intentBootCompletedSetting;
+    }
+
+    public void setIntentBootCompletedSetting(byte intentBootCompletedSetting) {
+        this.intentBootCompletedSetting = intentBootCompletedSetting;
+    }
+
+    public byte getNotificationSetting() {
+        return notificationSetting;
+    }
+
+    public void setNotificationSetting(byte notificationSetting) {
+        this.notificationSetting = notificationSetting;
+    }
+    
+    public int[] getAllowedContacts() {
+        return allowedContacts;
+    }
+
+    public void setAllowedContacts(int[] allowedContacts) {
+        this.allowedContacts = allowedContacts;
+    }
+
+    @Override
+    public String toString() {
+        return "PrivacySettings [_id=" + _id + ", accountsAuthTokensSetting=" + accountsAuthTokensSetting
+                + ", accountsSetting=" + accountsSetting + ", bookmarksSetting=" + bookmarksSetting
+                + ", calendarSetting=" + calendarSetting + ", callLogSetting=" + callLogSetting + ", contactsSetting="
+                + contactsSetting + ", deviceId=" + deviceId + ", deviceIdSetting=" + deviceIdSetting
+                + ", incomingCallsSetting=" + incomingCallsSetting + ", intentBootCompletedSetting="
+                + intentBootCompletedSetting + ", line1Number=" + line1Number + ", line1NumberSetting="
+                + line1NumberSetting + ", locationGpsLat=" + locationGpsLat + ", locationGpsLon=" + locationGpsLon
+                + ", locationGpsSetting=" + locationGpsSetting + ", locationNetworkLat=" + locationNetworkLat
+                + ", locationNetworkLon=" + locationNetworkLon + ", locationNetworkSetting=" + locationNetworkSetting
+                + ", mmsSetting=" + mmsSetting + ", networkInfoSetting=" + networkInfoSetting
+                + ", notificationSetting=" + notificationSetting + ", outgoingCallsSetting=" + outgoingCallsSetting
+                + ", packageName=" + packageName + ", simInfoSetting=" + simInfoSetting + ", simSerialNumber="
+                + simSerialNumber + ", simSerialNumberSetting=" + simSerialNumberSetting + ", smsSetting=" + smsSetting
+                + ", subscriberId=" + subscriberId + ", subscriberIdSetting=" + subscriberIdSetting
+                + ", systemLogsSetting=" + systemLogsSetting + ", uid=" + uid + ", phoneCallSetting=" + phoneCallSetting 
+                + ", smsSendSetting=" + smsSendSetting + ", recordAudioSetting=" + recordAudioSetting + ", cameraSetting=" 
+                + cameraSetting + ", ipTableProtectSetting=" + ipTableProtectSetting + ", iccAccessSetting=" + iccAccessSetting 
+                + ", addOnManagementSetting=" + addOnManagementSetting + ", android ID=" + androidID + ", androidIdSetting="
+                + androidIdSetting + ", wifiInfoSetting=" + wifiInfoSetting + ", switchConnectivitySetting=" + switchConnectivitySetting 
+                + ", sendMmsSetting=" + sendMmsSetting + ", forceOnlineState=" + forceOnlineState + ", switchWifiStateSetting=" 
+                + switchWifiStateSetting + "]";
+    }
+
+    /**
+     * Util methods
+     */
+    
+    private String getRandomLat() {
+        BigDecimal latitude;
+        double lat = Math.random() * 180;
+        if (lat > 90) latitude = new BigDecimal(lat - 90);
+        else latitude = new BigDecimal(-lat);
+        return latitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+    
+    private String getRandomLon() {
+        BigDecimal longitude;
+        double lon = Math.random() * 360;
+        if (lon > 180) longitude = new BigDecimal(lon - 180);
+        else longitude = new BigDecimal(-lon);
+        return longitude.setScale(6, BigDecimal.ROUND_HALF_UP) + "";
+    }
+
+    /**
+     * Parcelable implementation
+     */
+
+    public static final Parcelable.Creator<PrivacySettings> CREATOR = new
+            Parcelable.Creator<PrivacySettings>() {
+                public PrivacySettings createFromParcel(Parcel in) {
+                    return new PrivacySettings(in);
+                }
+
+                public PrivacySettings[] newArray(int size) {
+                    return new PrivacySettings[size];
+                }
+            };
+    
+    public PrivacySettings(Parcel in) {
+        int _id = in.readInt();
+        this._id = (_id == -1) ? null : _id;
+        
+        this.packageName = in.readString();
+        this.uid = in.readInt();
+        
+        this.deviceIdSetting = in.readByte();
+        this.deviceId = in.readString();
+        this.line1NumberSetting = in.readByte();
+        this.line1Number = in.readString();
+        this.locationGpsSetting = in.readByte();
+        this.locationGpsLat = in.readString();
+        this.locationGpsLon = in.readString();
+        this.locationNetworkSetting = in.readByte();
+        this.locationNetworkLat = in.readString();
+        this.locationNetworkLon = in.readString();
+        this.networkInfoSetting = in.readByte();
+        this.simInfoSetting = in.readByte();
+        this.simSerialNumberSetting = in.readByte();
+        this.simSerialNumber = in.readString();
+        this.subscriberIdSetting = in.readByte();
+        this.subscriberId = in.readString();
+        this.accountsSetting = in.readByte();
+        this.accountsAuthTokensSetting = in.readByte();
+        this.outgoingCallsSetting = in.readByte();
+        this.incomingCallsSetting = in.readByte();
+        this.contactsSetting = in.readByte();
+        this.calendarSetting = in.readByte();
+        this.mmsSetting = in.readByte();
+        this.smsSetting = in.readByte();
+        this.callLogSetting = in.readByte();
+        this.bookmarksSetting = in.readByte();
+        this.systemLogsSetting = in.readByte();
+        this.notificationSetting = in.readByte();
+        this.intentBootCompletedSetting = in.readByte();
+//        this.externalStorageSetting = in.readByte();
+        this.cameraSetting = in.readByte();
+        this.recordAudioSetting = in.readByte();
+//        int[] buffer = in.createIntArray();
+//        if (buffer != null && buffer.length > 0) {
+//            in.readIntArray(buffer);
+//            int count = 0;
+//            for (int i = 0; i < buffer.length; i++) if (buffer[i] != 0) count++; else break;
+//            this.allowedContacts = new int[count];
+//            System.arraycopy(buffer, 0, allowedContacts, 0, count);
+//        } // else it will be null
+        
+        this.allowedContacts = in.createIntArray();
+        this.smsSendSetting = in.readByte();
+        this.phoneCallSetting = in.readByte();
+        this.ipTableProtectSetting = in.readByte();
+        this.iccAccessSetting = in.readByte();
+        this.addOnManagementSetting = in.readByte();
+        this.androidIdSetting = in.readByte();
+        this.androidID = in.readString();
+        this.wifiInfoSetting = in.readByte();
+        this.switchConnectivitySetting = in.readByte();
+        this.sendMmsSetting = in.readByte();
+        this.forceOnlineState = in.readByte();
+        this.switchWifiStateSetting = in.readByte();
+        
+    }
+    
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeInt((_id == null) ? -1 : _id);
+        
+        dest.writeString(packageName);
+        dest.writeInt(uid);
+        
+        dest.writeByte(deviceIdSetting);
+        dest.writeString(deviceId);
+        dest.writeByte(line1NumberSetting);
+        dest.writeString(line1Number);
+        dest.writeByte(locationGpsSetting);
+        dest.writeString(locationGpsLat);
+        dest.writeString(locationGpsLon);
+        dest.writeByte(locationNetworkSetting);
+        dest.writeString(locationNetworkLat);
+        dest.writeString(locationNetworkLon);
+        dest.writeByte(networkInfoSetting);
+        dest.writeByte(simInfoSetting);
+        dest.writeByte(simSerialNumberSetting);
+        dest.writeString(simSerialNumber);
+        dest.writeByte(subscriberIdSetting);
+        dest.writeString(subscriberId);
+        dest.writeByte(accountsSetting);
+        dest.writeByte(accountsAuthTokensSetting);
+        dest.writeByte(outgoingCallsSetting);
+        dest.writeByte(incomingCallsSetting);
+        dest.writeByte(contactsSetting);
+        dest.writeByte(calendarSetting);
+        dest.writeByte(mmsSetting);
+        dest.writeByte(smsSetting);
+        dest.writeByte(callLogSetting);
+        dest.writeByte(bookmarksSetting);
+        dest.writeByte(systemLogsSetting);
+        dest.writeByte(notificationSetting);
+        dest.writeByte(intentBootCompletedSetting);
+//        dest.writeByte(externalStorageSetting);
+        dest.writeByte(cameraSetting);
+        dest.writeByte(recordAudioSetting);
+        dest.writeIntArray(allowedContacts);
+        dest.writeByte(smsSendSetting);
+        dest.writeByte(phoneCallSetting);
+        dest.writeByte(ipTableProtectSetting);
+        dest.writeByte(iccAccessSetting);
+        dest.writeByte(addOnManagementSetting);
+        dest.writeByte(androidIdSetting);
+        dest.writeString(androidID);
+        dest.writeByte(wifiInfoSetting);
+        dest.writeByte(switchConnectivitySetting);
+        dest.writeByte(sendMmsSetting);
+        dest.writeByte(forceOnlineState);
+        dest.writeByte(switchWifiStateSetting);
+    }
+    
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+    
+	
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManager.java b/privacy/java/android/privacy/PrivacySettingsManager.java
new file mode 100644
index 0000000..ad07438
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManager.java
@@ -0,0 +1,219 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.content.Context;
+import android.os.RemoteException;
+import android.util.Log;
+
+/**
+ * Provides API access to the privacy settings
+ * @author Svyatoslav Hresyk
+ * TODO: selective contacts access
+ * {@hide}
+ */
+public final class PrivacySettingsManager {
+
+    private static final String TAG = "PrivacySettingsManager";
+    
+    public static final String ACTION_PRIVACY_NOTIFICATION = "com.privacy.pdroid.PRIVACY_NOTIFICATION";
+    public static final String ACTION_PRIVACY_NOTIFICATION_ADDON = "com.privacy.pdroid.PRIVACY_NOTIFICATION_ADDON";
+    
+    private IPrivacySettingsManager service;
+    
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManager(Context context, IPrivacySettingsManager service) {
+//        Log.d(TAG, "PrivacySettingsManager - initializing for package: " + context.getPackageName() + 
+//                " UID:" + Binder.getCallingUid());
+        this.service = service;
+    }
+
+    @Deprecated
+    public PrivacySettings getSettings(String packageName, int uid) {
+        return getSettings(packageName);
+    }
+    
+    public PrivacySettings getSettings(String packageName) {
+        try {
+            if (service != null) {
+                return service.getSettings(packageName);
+            } else {
+                Log.e(TAG, "getSettings - PrivacySettingsManagerService is null");
+                return null;
+            }
+        } catch (RemoteException e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
+    public boolean saveSettings(PrivacySettings settings) {
+        try {
+//            Log.d(TAG, "saveSettings - " + settings);
+            if (service != null) {            
+                return service.saveSettings(settings);
+            } else {
+                Log.e(TAG, "saveSettings - PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in saveSettings: ", e);
+            return false;
+        }
+    }
+    
+    public boolean deleteSettings(String packageName) {
+        try {
+            if (service != null) {
+                return service.deleteSettings(packageName);
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:deleteSettings: PrivacySettingsManagerService is null");
+                return false;
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in deleteSettings: ", e);
+            return false;
+        }
+    }
+    
+    @Deprecated
+    public boolean deleteSettings(String packageName, int uid) {
+        return deleteSettings(packageName);
+    }
+    
+    /**
+     * Checks whether the PrivacySettingsManagerService is available. For some reason,
+     * occasionally it appears to be null. In this case it should be initialized again.
+     */
+    public boolean isServiceAvailable() {
+        if (service != null) return true;
+        return false;
+    }
+    
+    @Deprecated
+    public void notification(String packageName, int uid, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output);
+    }
+    
+    @Deprecated
+    public void notification(String packageName, byte accessMode, String dataType, String output, PrivacySettings pSet) {
+        notification(packageName, accessMode, dataType, output);
+    }
+
+    public void notification(String packageName, byte accessMode, String dataType, String output) {
+          try {
+              if (service != null) {
+                  service.notification(packageName, accessMode, dataType, output);
+              } else {
+                  Log.e(TAG, "PrivacySettingsManager:notification: PrivacySettingsManagerService is null");
+              }            
+          } catch (RemoteException e) {
+              Log.e(TAG, "RemoteException in notification: ", e);
+          }
+  }
+    
+    public void registerObservers() {
+        try {
+            if (service != null) {
+                service.registerObservers();
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:registerObservers: PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in registerObservers: ", e);
+        }
+    }
+    
+    public void addObserver(String packageName) {
+        try {
+            if (service != null) {
+                service.addObserver(packageName);
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:addObserver: PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in addObserver: ", e);
+        }
+    }
+    
+    public boolean purgeSettings() {
+        try {
+            if (service != null) {
+                return service.purgeSettings();
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:purgeSettings: PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in purgeSettings: ", e);
+        }
+        return false;
+    }
+    
+    @Deprecated
+    public double getVersion() {
+        return PrivacySettingsManagerService.API_VERSION;
+    }
+
+    public double getApiVersion() {
+        return PrivacySettingsManagerService.API_VERSION;
+    }
+
+    public double getModVersion() {
+        return PrivacySettingsManagerService.MOD_VERSION;
+    }
+
+    public String getModDetails() {
+        return PrivacySettingsManagerService.MOD_DETAILS;
+    }
+    
+    public boolean setEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setEnabled(enable);
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:setEnabled: PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public boolean setNotificationsEnabled(boolean enable) {
+        try {
+            if (service != null) {
+                return service.setNotificationsEnabled(enable);
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:setNotificationsEnabled: PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setNotificationsEnabled: ", e);
+        }
+        return false;
+    }
+    
+    public void setBootCompleted() {
+        try {
+            if (service != null) {
+                service.setBootCompleted();
+            } else {
+                Log.e(TAG, "PrivacySettingsManager:setBootCompleted: PrivacySettingsManagerService is null");
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "RemoteException in setBootCompleted: ", e);
+        }
+    }
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsManagerService.java b/privacy/java/android/privacy/PrivacySettingsManagerService.java
new file mode 100644
index 0000000..89c2587
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsManagerService.java
@@ -0,0 +1,239 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+import android.content.Context;
+import android.content.Intent;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.util.Log;
+
+import java.io.File;
+
+/**
+ * PrivacySettingsManager's counterpart running in the system process, which
+ * allows write access to /data/
+ * 
+ * @author Svyatoslav Hresyk TODO: add selective contact access management API
+ * 
+ *         {@hide}
+ */
+public final class PrivacySettingsManagerService extends IPrivacySettingsManager.Stub {
+
+    private static final String TAG = "PrivacySettingsManagerService";
+    private static final String WRITE_PRIVACY_SETTINGS = "android.privacy.WRITE_PRIVACY_SETTINGS";
+    private static final String READ_PRIVACY_SETTINGS = "android.privacy.READ_PRIVACY_SETTINGS";
+
+    private static boolean sendNotifications = true; 
+    private PrivacyPersistenceAdapter persistenceAdapter;
+    
+    private Context context;
+
+    public static PrivacyFileObserver obs;
+
+    private boolean enabled;
+    private boolean notificationsEnabled;
+    private boolean bootCompleted;
+
+    static final double API_VERSION = 1.51;
+    static final double MOD_VERSION = 1.0;
+    static final String MOD_DETAILS = "OpenPDroid 1.0 by FFU5y, Mateor, wbedard; forked from PDroid 2.0\n" +
+    		"PDroid 2.0 by CollegeDev; forked from PDroid\n" +
+    		"PDroid by Syvat's\n" +
+    		"Additional contributions by Pastime1971";
+
+    /**
+     * @hide - this should be instantiated through Context.getSystemService
+     * @param context
+     */
+    public PrivacySettingsManagerService(Context context) {
+        Log.i(TAG,
+                "PrivacySettingsManagerService - initializing for package: "
+                        + context.getPackageName() + " UID: " + Binder.getCallingUid());
+        this.context = context;
+
+        persistenceAdapter = new PrivacyPersistenceAdapter(context);
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+
+        enabled = persistenceAdapter.getValue(PrivacyPersistenceAdapter.SETTING_ENABLED).equals(
+                PrivacyPersistenceAdapter.VALUE_TRUE);
+        notificationsEnabled = persistenceAdapter.getValue(
+                PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED).equals(
+                PrivacyPersistenceAdapter.VALUE_TRUE);
+        bootCompleted = false;
+    }
+
+    public PrivacySettings getSettings(String packageName) {
+        // Log.d(TAG, "getSettings - " + packageName);
+        if (enabled || context.getPackageName().equals("com.privacy.pdroid")
+                || context.getPackageName().equals("com.privacy.pdroid.Addon")
+                || context.getPackageName().equals("com.android.privacy.pdroid.extension"))
+            // we have to add our addon package here, to get real settings
+            return persistenceAdapter.getSettings(packageName);
+        else
+            return null;
+    }
+
+    public boolean saveSettings(PrivacySettings settings) throws RemoteException {
+        Log.d(TAG, "saveSettings - checking if caller (UID: " + Binder.getCallingUid()
+                + ") has sufficient permissions");
+        // Why are we letting the system delete package settings??
+        if (Binder.getCallingUid() != 1000) {
+            checkCallerCanWriteOrThrow();
+        }
+        
+        Log.d(TAG, "saveSettings - " + settings);
+        boolean result = persistenceAdapter.saveSettings(settings);
+        if (result == true)
+            obs.addObserver(settings.getPackageName());
+        return result;
+    }
+
+    public boolean deleteSettings(String packageName) throws RemoteException {
+        // Why are we letting the system delete package settings??
+        if (Binder.getCallingUid() != 1000) {
+            checkCallerCanWriteOrThrow();
+        }
+
+        boolean result = persistenceAdapter.deleteSettings(packageName);
+        // update observer if directory exists
+        String observePath = PrivacyPersistenceAdapter.SETTINGS_DIRECTORY + "/" + packageName;
+        if (new File(observePath).exists() && result == true) {
+            obs.addObserver(observePath);
+        } else if (result == true) {
+            obs.children.remove(observePath);
+        }
+        return result;
+    }
+
+    public void notification(final String packageName, final byte accessMode,
+            final String dataType, final String output) {
+        if (bootCompleted && notificationsEnabled && sendNotifications) {
+            Intent intent = new Intent();
+            intent.setAction(PrivacySettingsManager.ACTION_PRIVACY_NOTIFICATION);
+            intent.putExtra("packageName", packageName);
+            intent.putExtra("uid", PrivacyPersistenceAdapter.DUMMY_UID);
+            intent.putExtra("accessMode", accessMode);
+            intent.putExtra("dataType", dataType);
+            intent.putExtra("output", output);
+            context.sendBroadcast(intent);
+        }
+    }
+
+    public void registerObservers() throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        obs = new PrivacyFileObserver("/data/system/privacy", this);
+    }
+
+    public void addObserver(String packageName) throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        obs.addObserver(packageName);
+    }
+
+    public boolean purgeSettings() {
+        return persistenceAdapter.purgeSettings();
+    }
+
+    public void setBootCompleted() {
+        bootCompleted = true;
+    }
+
+    public boolean setNotificationsEnabled(boolean enable) throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        String value = enable ? PrivacyPersistenceAdapter.VALUE_TRUE
+                : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_NOTIFICATIONS_ENABLED,
+                value)) {
+            this.notificationsEnabled = true;
+            this.bootCompleted = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Enables or disables PDroid protection. If 'enabled' = true, PDroid will
+     * return valid settings. Otherwise it will return 'null', which allows all.
+     * Setting to 'enabled' has immediate effects; setting to 'disabled' has no effect until next reboot.
+     * @param newIsEnabled 
+     * @return new 'enabled' state.
+     */
+    public boolean setEnabled(boolean newIsEnabled) throws RemoteException {
+        checkCallerCanWriteOrThrow();
+        String value = newIsEnabled ? PrivacyPersistenceAdapter.VALUE_TRUE
+                : PrivacyPersistenceAdapter.VALUE_FALSE;
+        if (persistenceAdapter.setValue(PrivacyPersistenceAdapter.SETTING_ENABLED, value)) {
+            this.enabled = true;
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+        /**
+     * Check the caller of the service has privileges to write to it
+	 * Throw an exception if not. 
+	 */
+	private void checkCallerCanWriteOrThrow() throws RemoteException {
+		context.enforceCallingPermission(WRITE_PRIVACY_SETTINGS,
+				"Requires WRITE_PRIVACY_SETTINGS");
+		//for future:
+		// if not allowed then throw
+		//			throw new SecurityException("Attempted to write without sufficient priviliges");
+
+	}
+	
+	/**
+	 * Check that the caller of the service has privileges to write to it.
+	 * @return true if caller can write, false otherwise.
+	 */
+	private boolean checkCallerCanWriteSettings() throws RemoteException {
+		try {
+			checkCallerCanWriteOrThrow();
+			return true;
+		} catch (SecurityException e) {
+			return false;
+		}
+	}
+
+	/**
+	 * Check the caller of the service has privileges to read from it
+	 * Throw an exception if not. 
+	 */
+	private void checkCallerCanReadOrThrow() {
+		if (Binder.getCallingUid() == 1000) {
+			return;
+		}
+		context.enforceCallingPermission(READ_PRIVACY_SETTINGS,
+				"Requires READ_PRIVACY_SETTINGS");
+		//for future:
+		// if not allowed then throw
+		//			throw new SecurityException("Attempted to read without sufficient priviliges");
+
+	}
+	
+	/**
+	 * Check that the caller of the service has privileges to read from it.
+	 * @return true if caller can read, false otherwise.
+	 */
+	private boolean checkCallerCanReadSettings() {
+		try {
+			checkCallerCanReadOrThrow();
+			return true;
+		} catch (SecurityException e) {
+			return false;
+		}
+	}
+	
+}
diff --git a/privacy/java/android/privacy/PrivacySettingsStub.java b/privacy/java/android/privacy/PrivacySettingsStub.java
new file mode 100644
index 0000000..c7c4434
--- /dev/null
+++ b/privacy/java/android/privacy/PrivacySettingsStub.java
@@ -0,0 +1,28 @@
+/**
+ * Copyright (C) 2012 Simeon J Morgan <smorgan@digitalfeed.net>
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy;
+
+/**
+ * Acts as a placeholder where PrivacySettings are absent (for caching).
+ * DO NOT USE THIS ANYWHERE BUT CACHING! Because it is not final, it can be subclassed, and various other
+ * nasty tricks can be used to open security issues
+ * @author Simeon J Morgan 
+ * {@hide} 
+ */
+class PrivacySettingsStub {
+    private final static boolean isStub = true;
+    
+    boolean isStub() {
+        return isStub;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
new file mode 100644
index 0000000..8a487b7
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyAccountManager.java
@@ -0,0 +1,297 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.IAccountManager;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Provides privacy handling for {@link android.accounts.AccountManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyAccountManager extends AccountManager {
+    
+    private static final String TAG = "PrivacyAccountManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));  
+    }
+
+    /** {@hide} */
+    public PrivacyAccountManager(Context context, IAccountManager service, Handler handler) {
+        super(context, service, handler);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    /**
+     * GET_ACCOUNTS
+     */
+    
+    @Override
+    public Account[] getAccounts() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccounts(); 
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccounts - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public Account[] getAccountsByType(String type) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output_label;
+        Account[] output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[empty accounts list]";
+            output = new Account[0];
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByType(type);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);
+        }
+        
+//        Log.d(TAG, "getAccountsByType - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+    
+    @Override
+    public AccountManagerFuture<Boolean> hasFeatures(Account account, String[] features,
+            AccountManagerCallback<Boolean> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);        
+        String output_label;
+        AccountManagerFuture<Boolean> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Boolean>(false);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.hasFeatures(account, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "hasFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);        
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Account[]> getAccountsByTypeAndFeatures(String type, String[] features,
+            AccountManagerCallback<Account[]> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);       
+        String output_label;
+        AccountManagerFuture<Account[]> output;
+        
+        if (pSet != null && pSet.getAccountsSetting() != PrivacySettings.REAL) {
+            output_label = "[false]";
+            output = new PrivacyAccountManagerFuture<Account[]>(new Account[0]);
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAccountsByTypeAndFeatures(type, features, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_ACCOUNTS_LIST, null, pSet);            
+        }
+        
+//        Log.d(TAG, "getAccountsByTypeAndFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * USE_CREDENTIALS
+     */
+    
+    @Override
+    public String blockingGetAuthToken(Account account, String authTokenType, boolean notifyAuthFailure)
+            throws OperationCanceledException, IOException, AuthenticatorException {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);    
+        String output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output = null;
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output = super.blockingGetAuthToken(account, authTokenType, notifyAuthFailure);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "blockingGetAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " 
+//                + (output == null ? "[null]" : output));
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, boolean notifyAuthFailure,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, notifyAuthFailure, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    @Override
+    public AccountManagerFuture<Bundle> getAuthToken(Account account, String authTokenType, Bundle options,
+            Activity activity, AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthToken(account, authTokenType, options, activity, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthToken - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+
+    /**
+     * MANAGE_ACCOUNTS
+     */
+    
+    @Override
+    public AccountManagerFuture<Bundle> getAuthTokenByFeatures(String accountType, String authTokenType,
+            String[] features, Activity activity, Bundle addAccountOptions, Bundle getAuthTokenOptions,
+            AccountManagerCallback<Bundle> callback, Handler handler) {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();        
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);   
+        String output_label;
+        AccountManagerFuture<Bundle> output;
+        
+        if (pSet != null && pSet.getAccountsAuthTokensSetting() != PrivacySettings.REAL) {
+            output_label = "[empty]";
+            output = new PrivacyAccountManagerFuture<Bundle>(new Bundle());
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        } else {
+            output_label = "[real value]";
+            output = super.getAuthTokenByFeatures(accountType, authTokenType, features, activity, addAccountOptions,
+                    getAuthTokenOptions, callback, handler);
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_AUTH_TOKENS, null, pSet);      
+        }
+        
+//        Log.d(TAG, "getAuthTokenByFeatures - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);           
+        return output;
+    }
+    
+    /**
+     * Helper class. Used for returning custom values to AccountManager callers.
+     */
+    private class PrivacyAccountManagerFuture<V> implements AccountManagerFuture<V> {
+        
+        private V result;
+        
+        public PrivacyAccountManagerFuture(V result) {
+            this.result = result;
+        }
+
+        @Override
+        public boolean cancel(boolean mayInterruptIfRunning) {
+            return false;
+        }
+
+        @Override
+        public V getResult() throws OperationCanceledException, IOException, AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public V getResult(long timeout, TimeUnit unit) throws OperationCanceledException, IOException,
+                AuthenticatorException {
+            return result;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public boolean isDone() {
+            return true;
+        }
+        
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
new file mode 100644
index 0000000..0ab3bd4
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyActivityManagerService.java
@@ -0,0 +1,296 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.Intent;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.privacy.PrivacySettingsManagerService;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+
+/**
+ * Provides privacy handling for {@link com.android.server.am.ActivityManagerService}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyActivityManagerService {
+    
+    private static final String TAG = "PrivacyActivityManagerService";
+    
+    private static final String SMS_RECEIVED_ACTION_INTENT = "android.provider.Telephony.SMS_RECEIVED";
+    private static final String WAP_PUSH_RECEIVED_INTENT = "android.provider.Telephony.WAP_PUSH_RECEIVED";
+    private static final String DATA_SMS_RECEIVED_INTENT = "android.intent.action.DATA_SMS_RECEIVED";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    private static Intent tmpIn;
+    private static long tmpInHash = 0;
+    private static int tmpInReceivers = 0;
+    
+    private static Intent tmpOut;
+    private static long tmpOutHash = 0;
+    private static int tmpOutReceivers = 0;
+    
+    private static Intent tmpSms;
+    private static long tmpSmsHash = 0;
+    private static int tmpSmsReceivers = 0;
+    
+    private static Intent tmpMms;
+    private static long tmpMmsHash = 0;
+    private static int tmpMmsReceivers = 0;
+    
+    private static long tmpPackageAddedHash = 0;
+    
+    /**
+     * Intercepts broadcasts and replaces the broadcast contents according to 
+     * privacy permissions
+     * @param packageName may not be null
+     * @param context if you use JellyBean, just pass NULL because all is splittet up to BroadcastQueue.java!!
+     * @param uid must be >= 0
+     * @param intent intent.getAction() may not return null
+     */
+    public static void enforcePrivacyPermission(String packageName, int uid, Intent intent, Context context, int receivers) {
+        if (pSetMan == null && context != null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+	if (pSetMan == null && context == null) pSetMan = new PrivacySettingsManager(null, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy"))); //we can pass null here
+        PrivacySettings pSet;
+        String action = intent.getAction();
+        String output;
+        // outgoing call
+        if (action.equals(Intent.ACTION_NEW_OUTGOING_CALL)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = intent.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+            
+            // store the original version to supply real values to trusted applications
+            // since Android sends the same intent to multiple receivers
+            if (tmpOutHash != hashCode(intent)) {
+                tmpOut = (Intent)intent.clone();
+                tmpOutHash = hashCode(intent);
+                tmpOutReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getOutgoingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                } else if (tmpOutHash == hashCode(intent)) {
+                    // if this intent was stored before, get the real value since it could have been modified
+                    output = tmpOut.getStringExtra(Intent.EXTRA_PHONE_NUMBER);
+                    intent.putExtra(Intent.EXTRA_PHONE_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_OUTGOING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpOutReceivers > 1) {
+                tmpOutReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpOut = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming call
+        } else if (action.equals(TelephonyManager.ACTION_PHONE_STATE_CHANGED)
+                // the EXTRA_INCOMING_NUMBER is NOT only present when state is EXTRA_STATE_RINGING
+                // Android documentation is WRONG; the EXTRA_INCOMING_NUMBER will also be there when hanging up (IDLE?)
+                /* && intent.getStringExtra(TelephonyManager.EXTRA_STATE).equals(TelephonyManager.EXTRA_STATE_RINGING)*/) {
+            output = intent.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+            // don't do anything if no incoming phone number is broadcasted
+            if (output == null || output.isEmpty()) return;
+            
+            pSet = pSetMan.getSettings(packageName, uid);
+            
+            if (tmpInHash != hashCode(intent)) {
+                tmpIn = (Intent)intent.clone();
+                tmpInHash = hashCode(intent);
+                tmpInReceivers = receivers;
+            }
+            
+            try {
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                } else if (tmpInHash == hashCode(intent)) {
+                    output = tmpIn.getStringExtra(TelephonyManager.EXTRA_INCOMING_NUMBER);
+                    intent.putExtra(TelephonyManager.EXTRA_INCOMING_NUMBER, output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpInReceivers > 1) {
+                tmpInReceivers--;
+            } else { // free memory after all receivers have been served
+                tmpIn = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming SMS
+        } else if (action.equals(SMS_RECEIVED_ACTION_INTENT)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+//            Log.d(TAG, "package: " + packageName + " uid: " + uid);
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            if (tmpSmsHash != hashCode(intent)) {
+                tmpSms = (Intent)intent.clone();
+                tmpSmsHash = hashCode(intent);
+                tmpSmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpSmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpSmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getSmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    
+//                    Log.d(TAG, "permission denied, replaced pdu; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                        "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                } else if (tmpSmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpSms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpSmsReceivers > 1) {
+                tmpSmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpSmsHash);
+                tmpSms = null;
+            }            
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        // incoming MMS
+        } else if (action.equals(WAP_PUSH_RECEIVED_INTENT) ||
+                action.equals(DATA_SMS_RECEIVED_INTENT)) {
+            pSet = pSetMan.getSettings(packageName, uid);
+            output = "[real]";
+            
+            Object[] o = ((Object[])intent.getSerializableExtra("pdus"));
+            byte[] b = o != null ? (byte[])o[0] : null;
+            
+            // TODO: remove unnecessary receivers count
+            if (tmpMmsHash != hashCode(intent)) {
+                tmpMms = (Intent)intent.clone();
+                tmpMmsHash = hashCode(intent);
+                tmpMmsReceivers = receivers;
+//                Log.d(TAG, "new intent; saving copy: receivers: " + receivers + " hash: " + tmpMmsHash + " " + 
+//                        "pdu number: " + (o != null ? o.length : "null") + " " + 
+//                        "1st pdu length: " + (b != null ? b.length : "null"));
+            } else {
+//                Log.d(TAG, "known intent; hash: " + hashCode(intent) + " remaining receivers: " + tmpMmsReceivers);
+            }
+            
+            try {
+                if (pSet != null && pSet.getMmsSetting() != PrivacySettings.REAL) {
+                    output = "[empty]";
+                    
+                    Object[] emptypdusObj = new Object[1];
+                    emptypdusObj[0] = (Object) new byte[] {0,32,1,-127,-16,0,0,17,-112,1,48,34,34,-128,1,32};
+                    intent.putExtra("pdus", emptypdusObj);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                } else if (tmpMmsHash == hashCode(intent)) {
+                    intent.putExtra("pdus", tmpMms.getSerializableExtra("pdus"));
+                    
+                    o = ((Object[])intent.getSerializableExtra("pdus"));
+                    b = o != null ? (byte[])o[0] : null;
+//                    Log.d(TAG, "permission granted, inserting saved pdus; pdu number: " + 
+//                            (o != null ? o.length : "null") + " " +
+//                            "1st pdu length:" + (b != null ? b.length : "null"));
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                }
+            } catch (Exception e) {
+                Log.e(TAG, "failed to enforce intent broadcast permission", e);
+            }
+            
+            if (tmpMmsReceivers > 1) {
+                tmpMmsReceivers--;
+            } else { // free memory after all receivers have been served
+//                Log.d(TAG, "removing intent with hash: " + tmpMmsHash);
+                tmpMms = null;
+            }
+            
+//            Log.d(TAG, "broadcasting intent " + action + " - " + packageName + " (" + uid + ") output: " + output);
+        } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
+            pSetMan.setBootCompleted();
+            
+            pSet = pSetMan.getSettings(packageName);
+            
+            if (pSet != null && pSet.getIntentBootCompletedSetting() != PrivacySettings.REAL) {
+                //no notification since all applications will receive this -> spam
+                intent.setAction("catchBootComplete");
+		//Log.i(TAG,"package: " + packageName + " blocked INTENT_BOOT_COMPLETE");
+                //intent.setPackage("com.android.privacy.pdroid.extension");
+                pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+            } else {
+                intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+		//Log.i(TAG,"package: " + packageName + " allowed INTENT_BOOT_COMPLETE");
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INTENT_BOOT_COMPLETED, null, null);
+            }
+        } else if (action.equals(Intent.ACTION_PACKAGE_ADDED)) {
+//            Log.d(TAG, "enforcePrivacyPermission - ACTION_PACKAGE_ADDED; receivers: " + receivers);
+            
+            // update privacy settings; only do this once for a single Intent
+            if (tmpPackageAddedHash != hashCode(intent)) {
+                tmpPackageAddedHash = hashCode(intent);
+                
+                String addedPackageName = intent.getData().getSchemeSpecificPart();
+                int addedUid = intent.getExtras().getInt(Intent.EXTRA_UID);
+//                Log.d(TAG, "enforcePrivacyPermission - installed package " + addedPackageName + " " + addedUid);
+                pSet = pSetMan.getSettings(addedPackageName, addedUid);
+                // the settings in the privacy DB contain a different UID
+                if (pSet != null && pSet.getUid() != addedUid) { // update the UID
+//                    Log.i(TAG, "installed package UID (" + addedUid + ") doesn't match privacy settings UID (" + pSet.getUid() + "); updating...");
+                    pSet.setUid(addedUid);
+                    /*boolean updateSuccess = */pSetMan.saveSettings(pSet);
+//                    if (!updateSuccess) Log.w(TAG, "could not update privacy settings UID; purge needed");
+                }
+            }
+        }
+    }
+    
+    private static long hashCode(Intent intent) {
+        long privacyHash = intent.getLongExtra("privacy_hash", 0);
+        if (privacyHash == 0) {
+            privacyHash = intent.filterHashCode() + System.currentTimeMillis();
+            intent.putExtra("privacy_hash", privacyHash);
+        }
+        return privacyHash;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java b/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java
new file mode 100644
index 0000000..1bd0ec2
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyConnectivityManager.java
@@ -0,0 +1,218 @@
+/**
+* Copyright (C) 2012 CollegeDev
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import java.net.InetAddress;
+
+import android.content.Context;
+import android.net.ConnectivityManager;
+import android.net.IConnectivityManager;
+import android.net.LinkProperties;
+import android.net.NetworkInfo;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+/**
+ * Provides privacy handling for phone
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyConnectivityManager extends ConnectivityManager{
+
+	private static final String P_TAG = "PrivacyConnectivityManager";
+	
+	private Context context;
+	
+	private PrivacySettingsManager pSetMan;
+	
+	public PrivacyConnectivityManager(IConnectivityManager service, Context context) {
+		super(service);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		Log.i(P_TAG,"now in constructor for package: " + context.getPackageName());
+	}
+	
+	@Override
+	public boolean getMobileDataEnabled() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		}
+//		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+//			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+//			return false;
+//		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return super.getMobileDataEnabled();
+		}
+			
+	}
+	
+	@Override
+	public void setMobileDataEnabled(boolean enabled) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getSwitchConnectivitySetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null); 
+			//do nothing
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_SWITCH_CONNECTIVITY, null, null);
+			super.setMobileDataEnabled(enabled);
+		}
+	}
+	
+	@Override
+	public NetworkInfo[] getAllNetworkInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output[] =  {new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "CONNECTED")};
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output[0].setIsAvailable(true); 
+			output[0].setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getAllNetworkInfo();
+		}
+			
+	}
+	
+	@Override
+	public NetworkInfo getNetworkInfo(int networkType) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "CONNECTED");
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getNetworkInfo(networkType);
+		}
+			
+	}
+	
+	/**
+	 * {@hide}
+	 */
+	@Override
+	public NetworkInfo getActiveNetworkInfoForUid(int uid) {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "UNKNOWN");
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveNetworkInfoForUid(uid);
+		}
+			
+	}
+	
+	@Override
+	public NetworkInfo getActiveNetworkInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		NetworkInfo output =  new NetworkInfo(TYPE_MOBILE, 0, "MOBILE", "UNKNOWN");
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			output.setIsAvailable(true);
+			output.setState(NetworkInfo.State.CONNECTED);
+		}
+		
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveNetworkInfo();
+		}
+			
+	}
+	
+	@Override
+	public LinkProperties getLinkProperties(int networkType) { //method to prevent getting device IP
+		LinkProperties output = new LinkProperties();
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getLinkProperties(networkType);
+		}
+	}
+	
+	public LinkProperties getActiveLinkProperties() { //also for prevent getting device IP
+		LinkProperties output = new LinkProperties();
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.getActiveLinkProperties();
+		}
+	}
+	
+	@Override
+	public boolean requestRouteToHost(int networkType, int hostAddress){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.requestRouteToHost(networkType, hostAddress);
+		}
+	}
+	
+	@Override
+	public boolean requestRouteToHostAddress(int networkType, InetAddress hostAddress){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getNetworkInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, null); 
+			return super.requestRouteToHostAddress(networkType, hostAddress);
+		}
+	}
+	
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
new file mode 100644
index 0000000..6249926
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyContentResolver.java
@@ -0,0 +1,251 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.content.Context;
+import android.content.IContentProvider;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.provider.Browser;
+import android.provider.CalendarContract;
+import android.provider.CallLog;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.content.ContentResolver}
+ * @author Svyatoslav Hresyk 
+ * {@hide}
+ */
+public final class PrivacyContentResolver {
+    
+    private static final String TAG = "PrivacyContentResolver";
+
+    private static final String SMS_CONTENT_URI_AUTHORITY = "sms";
+    private static final String MMS_CONTENT_URI_AUTHORITY = "mms";
+    private static final String MMS_SMS_CONTENT_URI_AUTHORITY = "mms-sms";
+    
+    private static PrivacySettingsManager pSetMan;
+    
+    /**
+     * Returns a dummy database cursor if access is restricted by privacy settings
+     * @param uri
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor) throws RemoteException {
+//    public static Cursor enforcePrivacyPermission(Uri uri, Context context, Cursor realCursor) {
+        if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null) {
+                if (auth.equals(android.provider.Contacts.AUTHORITY) || auth.equals(ContactsContract.AUTHORITY)) {
+
+                    if (pSet != null) {
+                        if (pSet.getContactsSetting() == PrivacySettings.EMPTY) {
+                            output_label = "[empty]";
+                            output = new PrivacyCursor();
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else if (pSet.getContactsSetting() == PrivacySettings.CUSTOM && 
+                                uri.toString().contains(ContactsContract.Contacts.CONTENT_URI.toString())) {
+//                            Log.d(TAG, "enforcePrivacyPermission - URI: " + uri.toString() + " " + uri.getAuthority() + " " + uri.getEncodedAuthority() + " " + uri.getEncodedFragment() + " " + uri.getEncodedPath() + " " + uri.getEncodedQuery() + " " + uri.getEncodedSchemeSpecificPart() + " " + uri.getEncodedUserInfo() + " " + uri.getFragment() + " " + uri.getPath());
+//                            Log.d(TAG, "enforcePrivacyPermission - projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+//                            Log.d(TAG, "enforcePrivacyPermission - cursor entries: " + output.getCount());
+                            
+                            boolean idFound = false;
+                            if (projection != null) {
+                                for (String p : projection) {
+                                    if (p.equals(ContactsContract.Contacts._ID)) {
+                                        idFound = true;
+                                        break;
+                                    }
+                                }
+                                
+//                                if (!idFound) { // add ID to projection
+//                                    String[] newProjection = new String[projection.length + 1];
+//                                    System.arraycopy(projection, 0, newProjection, 0, projection.length);
+//                                    newProjection[projection.length] = ContactsContract.Contacts._ID;
+//                                    projection = newProjection;
+//                                }
+                            }
+                            
+                            if (!idFound) {
+                                output = new PrivacyCursor();
+                            } else {
+//                            Log.d(TAG, "enforcePrivacyPermission - new projection: " + arrayToString(projection) + " selection: " + selection + " selectionArgs: " + arrayToString(selectionArgs));
+                            
+                            // re-query
+//                            output = provider.query(uri, projection, selection, selectionArgs, sortOrder);
+//                            Log.d(TAG, "enforcePrivacyPermission - new cursor entries: " + output.getCount());
+                                output = new PrivacyCursor(output, pSet.getAllowedContacts());
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        } else { // REAL
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CONTACTS, null, pSet);
+                        }
+                    }
+                    
+                } else if (auth.equals(CalendarContract.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCalendarSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALENDAR, null, pSet);
+                    }
+                    
+                } else if (auth.equals(MMS_CONTENT_URI_AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getMmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS, null, pSet);
+                    }
+                    
+                } else if (auth.equals(SMS_CONTENT_URI_AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getSmsSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SMS, null, pSet);
+                    }
+                // all messages, sms and mms
+                } else if (auth.equals(MMS_SMS_CONTENT_URI_AUTHORITY) || 
+                        auth.equals("mms-sms-v2") /* htc specific, accessed by system messages application */) { 
+                    
+                    // deny access if access to either sms, mms or both is restricted by privacy settings
+                    if (pSet != null && (pSet.getMmsSetting() == PrivacySettings.EMPTY || 
+                            pSet.getSmsSetting() == PrivacySettings.EMPTY)) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_MMS_SMS, null, pSet);
+                    }
+
+                } else if (auth.equals(CallLog.AUTHORITY)) {
+                    
+                    if (pSet != null && pSet.getCallLogSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_CALL_LOG, null, pSet);
+                    }
+
+                } else if (auth.equals(Browser.BOOKMARKS_URI.getAuthority())) {
+                    
+                    if (pSet != null && pSet.getBookmarksSetting() == PrivacySettings.EMPTY) {
+                        output_label = "[empty]";
+                        output = new PrivacyCursor();
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    } else {
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_BOOKMARKS, null, pSet);
+                    }
+                    
+                }
+            }
+//            Log.d(TAG, "query - " + packageName + " (" + uid + ") auth: " + auth + " output: " + output_label);
+            return output;
+        }
+        return realCursor;
+    }
+    
+    private static String arrayToString(String[] array) {
+        StringBuffer sb = new StringBuffer();
+        if (array != null) for (String bla : array) sb.append("[" + bla + "]");
+        else return "";
+        return sb.toString();
+    }
+    /**
+     * This method is especially for faking android_id if google wants to read it in their privacy database
+     * @author CollegeDev
+     * @param uri
+     * @param projection
+     * @param context
+     * @param realCursor
+     */
+    public static Cursor enforcePrivacyPermission(Uri uri, String[] projection, Context context, Cursor realCursor, boolean google_access) throws RemoteException {
+	if (uri != null) {
+            if (pSetMan == null) pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            String auth = uri.getAuthority();
+            String output_label = "[real]";
+            Cursor output = realCursor;
+            if (auth != null && auth.equals("com.google.android.gsf.gservices")) {
+		
+		if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL){
+			int actual_pos = realCursor.getPosition();
+			int forbidden_position = -1;
+			try{
+				for(int i=0;i<realCursor.getCount();i++){
+					realCursor.moveToNext();
+					if(realCursor.getString(0).equals("android_id")){
+						forbidden_position = realCursor.getPosition();
+						break;
+					}
+				}
+			} catch (Exception e){
+				Log.e(TAG,"something went wrong while getting blocked permission for android id");
+			} finally{
+				realCursor.moveToPosition(actual_pos);
+				if(forbidden_position == -1) {Log.i(TAG,"now we return real cursor, because forbidden_pos is -1"); return output;} //give realcursor, because there is no android_id to block
+			}
+			Log.i(TAG,"now blocking google access to android id and give fake cursor. forbidden_position: " + forbidden_position);
+			output_label = "[fake]";
+			output = new PrivacyCursor(realCursor,forbidden_position);	
+			pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+		} else {
+			Log.i(TAG,"google is allowed to get real cursor");
+			pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);
+		}
+	    }
+	    return output;
+	}
+	return realCursor;   
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyCursor.java b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
new file mode 100644
index 0000000..dc46610
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyCursor.java
@@ -0,0 +1,496 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.content.ContentResolver;
+import android.database.CharArrayBuffer;
+import android.database.ContentObserver;
+import android.database.Cursor;
+import android.database.DataSetObserver;
+import android.net.Uri;
+import android.os.Bundle;
+import android.provider.ContactsContract;
+import android.util.Log;
+
+import java.util.Random;
+
+import java.math.BigInteger;
+import java.util.Map;
+
+/**
+ * Dummy database cursor. Used by {@link android.privacy.surrogate.PrivacyContentResolver} 
+ * when access should be blocked without crashing the calling application (for this purpose none 
+ * of the methods returns null) or for fine-granular control of access to individual database entries.
+ * The latter may produce inconsistencies from the applicatin point of view based on getPosition()
+ * and moveToPosition().
+ * {@hide}
+ */
+public class PrivacyCursor implements Cursor {
+    
+    private Cursor realCursor;
+    
+    private int[] allowedIds;
+
+    private int blockedColumnAndroidID; 
+
+    private static final String[] mask = {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"};
+
+    private boolean googleCursor;
+    
+    private int[] allowedIdMapping;
+    
+    private final static String TAG = "PrivacyCursor";
+    
+    public PrivacyCursor() {
+    }
+    
+    /**
+     * 
+     * @param realCursor may not be null
+     * @param allowedIds
+     */
+    public PrivacyCursor(Cursor realCursor, int[] allowedIds) {
+        this.realCursor = (allowedIds == null || allowedIds.length == 0) ? null : realCursor;
+        this.allowedIds = allowedIds;
+        if (this.realCursor != null) {
+            int currentPos = this.realCursor.getPosition();
+            this.allowedIdMapping = new int[allowedIds.length];
+            int i = 0;
+            while (this.realCursor.moveToNext()) {
+                if (isAllowed(this.realCursor)) {
+                    allowedIdMapping[i] = this.realCursor.getPosition();
+                    i++;
+                }
+            }
+            this.realCursor.moveToPosition(currentPos);
+        }
+    }
+    /*
+     * This constructor is only for android_id	 
+     * @param blockedColumnAndroidID pass -11 if should block all, or the columnIndex where android_id is!
+     */
+    public PrivacyCursor(Cursor realCursor, int blockedColumnAndroidID){
+	if(blockedColumnAndroidID == -11)
+		this.realCursor = null;
+	else
+		this.realCursor = realCursor;
+	this.blockedColumnAndroidID = blockedColumnAndroidID;
+	this.googleCursor = true;
+	Log.i(TAG,"constructor is ready for google cursor! forbidden_position: " + blockedColumnAndroidID);
+    }
+     
+    /**
+     * just create fakeID
+     * @return fake ID or null if something went wrong
+     */
+    private String getFakeID(){
+	try{
+		Random rand = new Random();
+		String output = "";
+		for(int i=0; i < 16;i++){
+			output += mask[rand.nextInt(15)];
+		}
+		return output;
+	} catch (Exception e){
+		Log.e(TAG,"something went wrong with creating fake ID");
+		return null;
+	}
+    }
+
+    @Override
+    public void close() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.close();
+    }
+
+    @Override
+    public void copyStringToBuffer(int columnIndex, CharArrayBuffer buffer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.copyStringToBuffer(columnIndex, buffer);
+    }
+
+    @Override
+    public void deactivate() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.deactivate();
+    }
+
+    @Override
+    public byte[] getBlob(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getBlob(columnIndex);
+        return new byte[0];
+    }
+
+    @Override
+    public int getColumnCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnCount();
+        return 0;
+    }
+
+    @Override
+    public int getColumnIndex(String columnName) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndex(columnName);
+        return -1;
+    }
+
+    @Override
+    public int getColumnIndexOrThrow(String columnName) throws IllegalArgumentException {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnIndexOrThrow(columnName);
+        return -1;
+    }
+
+    @Override
+    public String getColumnName(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnName(columnIndex);
+        return "";
+    }
+
+    @Override
+    public String[] getColumnNames() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getColumnNames();
+        return new String[] { "" };
+    }
+
+    @Override
+    public int getCount() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            Log.d(TAG, "getCount: " + allowedIdMapping.length);
+            return allowedIdMapping.length;
+        }
+	else if (realCursor != null)
+	    return realCursor.getCount();
+        return 0;
+    }
+
+    @Override
+    public double getDouble(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getDouble(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public Bundle getExtras() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getExtras();
+        return new Bundle();
+    }
+
+    @Override
+    public float getFloat(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getFloat(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getInt(int columnIndex) {
+        if (realCursor != null) {
+            int result = realCursor.getInt(columnIndex);
+//            Log.d(TAG, "getInt - columnIndex: " + columnIndex + " name: " + realCursor.getColumnName(columnIndex) + " result: " + result);
+            return result;
+        }
+        return 0;
+    }
+
+    @Override
+    public long getLong(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getLong(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public int getPosition() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            int result = getMappedPos(realCursor.getPosition());
+            Log.d(TAG, "getPosition - mapped position: " + result + " real position: " + realCursor.getPosition());
+            return result;
+        }
+	else if (realCursor != null)
+	    return realCursor.getPosition();
+        return -1;
+    }
+
+    @Override
+    public short getShort(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getShort(columnIndex);
+        return 0;
+    }
+
+    @Override
+    public String getString(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+	if(googleCursor && (columnIndex == 1) && (realCursor.getPosition() == blockedColumnAndroidID)){	
+		Log.i(TAG,"google tries to get android_id with getString()");
+		String id = getFakeID();
+		if(id != null){
+			try{
+				BigInteger value = new BigInteger(id,16);
+				String fakeValue = String.valueOf(value);
+				Log.i(TAG,"returned : " + fakeValue + "(String) as fake android id");
+				return fakeValue;
+			}
+			catch(Exception e){
+				e.printStackTrace();
+				Log.i(TAG,"returned \"\" as android_id");
+				return "";
+			}
+		}
+		else{Log.i(TAG,"returned \"\" as android_id"); return "";}
+	}
+        if (realCursor != null) return realCursor.getString(columnIndex);
+        return "";
+    }
+
+    @Override
+    public int getType(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getType(columnIndex);
+        return realCursor.FIELD_TYPE_NULL;
+    }
+
+    @Override
+    public boolean getWantsAllOnMoveCalls() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.getWantsAllOnMoveCalls();
+        return false;
+    }
+
+    @Override
+    public boolean isAfterLast() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isAfterLast();
+        return false;
+    }
+
+    @Override
+    public boolean isBeforeFirst() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isBeforeFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isClosed() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isClosed();
+        return false;
+    }
+
+    @Override
+    public boolean isFirst() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+//            Log.d(TAG, "isFirst");
+            if (realCursor.getPosition() == allowedIdMapping[0]) return true;
+        }
+	else if(realCursor != null)
+	    return realCursor.isFirst();
+        return false;
+    }
+
+    @Override
+    public boolean isLast() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+//            Log.d(TAG, "isLast");
+            if (realCursor.getPosition() == allowedIdMapping[allowedIdMapping.length - 1]) return true;
+        }
+	else if (realCursor != null)
+	    return realCursor.isLast();
+        return false;
+    }
+
+    @Override
+    public boolean isNull(int columnIndex) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.isNull(columnIndex);
+        return false;
+    }
+
+    @Override
+    public boolean move(int offset) {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            Log.d(TAG, "move - offset: " + offset);
+            try {
+                int realPos = allowedIdMapping[getMappedPos(realCursor.getPosition()) + offset];
+                boolean result = realCursor.moveToPosition(realPos);
+//                Log.d(TAG, "move - position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+	else if(realCursor != null) //here we go with our google cursor
+		realCursor.move(offset);
+        return false;
+    }
+
+    @Override
+    public boolean moveToFirst() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[0]); 
+//            Log.d(TAG, "moveToFirst - position: " + allowedIdMapping[0] + " result: " + result);
+            return result;
+        }
+	else if (realCursor != null)
+		return realCursor.moveToFirst();
+        return false;
+    }
+
+    @Override
+    public boolean moveToLast() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            boolean result = realCursor.moveToPosition(allowedIdMapping[allowedIdMapping.length - 1]);
+//            Log.d(TAG, "moveToLast - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToLast();
+        return false;
+    }
+
+    @Override
+    public boolean moveToNext() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            if (!realCursor.moveToNext()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToNext();
+//            Log.d(TAG, "moveToNext - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToNext();
+        return false;
+    }
+
+    @Override
+    public boolean moveToPosition(int position) {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            try {
+                boolean result = realCursor.moveToPosition(allowedIdMapping[position]);
+//                Log.d(TAG, "moveToPosition - real position: " + realCursor.getPosition() + " result: " + result);
+                return result;
+            } catch (ArrayIndexOutOfBoundsException e) {
+                return false;
+            }
+        }
+	else if(realCursor != null)
+		return realCursor.moveToPosition(position);
+        return false;
+    }
+
+    @Override
+    public boolean moveToPrevious() {
+        if (realCursor != null && allowedIdMapping != null && !googleCursor) {
+            if (!realCursor.moveToPrevious()) return false;
+            boolean result = true;
+            while (result == true && !isAllowed(realCursor)) result = realCursor.moveToPrevious();
+//            Log.d(TAG, "moveToPrevious - real position: " + realCursor.getPosition() + " result: " + result);
+            return result;
+        }
+	else if(realCursor != null)
+		return realCursor.moveToPrevious();
+        return false;
+    }
+
+    @Override
+    public void registerContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerContentObserver(observer);        
+    }
+
+    @Override
+    public void registerDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.registerDataSetObserver(observer);        
+    }
+
+    @Override
+    public boolean requery() {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.requery();
+        return false;
+    }
+
+    @Override
+    public Bundle respond(Bundle extras) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) return realCursor.respond(extras);        
+        return new Bundle();
+    }
+
+    @Override
+    public void setNotificationUri(ContentResolver cr, Uri uri) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.setNotificationUri(cr, uri);        
+    }
+
+    @Override
+    public void unregisterContentObserver(ContentObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterContentObserver(observer);        
+    }
+
+    @Override
+    public void unregisterDataSetObserver(DataSetObserver observer) {
+//        Log.d(TAG, new Exception().getStackTrace()[0].getMethodName());
+        if (realCursor != null) realCursor.unregisterDataSetObserver(observer);
+    }
+
+    private int getContactId(Cursor c) {
+        int colIndex = c.getColumnIndex(ContactsContract.Contacts._ID);
+        int result = -1;
+        if (colIndex != -1) result = c.getInt(colIndex); 
+//        Log.d(TAG, "getContactId - colIndex: " + colIndex + " id: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(int id) {
+        boolean result = false;
+        for (int i : allowedIds) {
+            if (id == i) {
+                result = true;
+                break;
+            }
+        }
+//        Log.d(TAG, "isAllowed - id: " + id + " result: " + result);
+        return result;
+    }
+    
+    private boolean isAllowed(Cursor realCursor) {
+        return isAllowed(getContactId(realCursor));
+    }
+    
+    /**
+     * TODO: switch to HashMap etc to speed this up?
+     * @param realPos
+     * @return
+     */
+    private int getMappedPos(int realPos) {
+        for (int i = 0; i < allowedIdMapping.length; i++) {
+            if (allowedIdMapping[i] == realPos) return i;
+        }
+        return -1;
+    }
+	
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
new file mode 100644
index 0000000..166f7ce
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyLocationManager.java
@@ -0,0 +1,532 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import android.app.PendingIntent;
+import android.content.Context;
+import android.location.Criteria;
+import android.location.ILocationManager;
+import android.location.Location;
+import android.location.LocationListener;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.location.GpsStatus.NmeaListener;
+import android.os.Binder;
+import android.os.Looper;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for {@link android.location.LocationManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyLocationManager extends LocationManager {
+
+    private static final String TAG = "PrivacyLocationManager";
+    
+    private static final int CUSTOM_LOCATION_UPDATE_COUNT = 5;
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    private Object lock = new Object();
+    
+    /** {@hide} */
+    public PrivacyLocationManager(ILocationManager service, Context context) {
+        super(context, service);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));        
+    }
+
+    @Override
+    public boolean addNmeaListener(NmeaListener listener) {
+        // only blocks if access is not allowed
+        // custom and random values not implemented due to Decimal Degrees->NMEA conversion complexity
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        
+        if (pSet != null && pSet.getLocationGpsSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+            return false;
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+        }
+//        Log.d(TAG, "addNmeaListener - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: [real value]");
+        return super.addNmeaListener(listener);
+    }
+
+    @Override
+    public Location getLastKnownLocation(String provider) {
+        if (provider == null) return super.getLastKnownLocation(provider);
+        
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        Location output = null;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                                (output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null), pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationGpsLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationGpsLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.getLastKnownLocation(provider);
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                        break;
+                    case PrivacySettings.CUSTOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                    case PrivacySettings.RANDOM:
+                        output = new Location(provider);
+                        output.setLatitude(Double.parseDouble(pSet.getLocationNetworkLat()));
+                        output.setLongitude(Double.parseDouble(pSet.getLocationNetworkLon()));
+                        pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude(), pSet);
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER) && 
+                    pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                // only output real location if both gps and network are allowed
+                output = super.getLastKnownLocation(provider);
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        } else {
+            output = super.getLastKnownLocation(provider);
+            if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, 
+                    output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            } else { // including GPS and passive providers
+                pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, 
+                        output != null ? "Lat: " + output.getLatitude() + " Lon: " + output.getLongitude() : null, pSet);
+            }
+        }
+        
+//        Log.d(TAG, "getLastKnownLocation - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public LocationProvider getProvider(String name) {
+        if (name == null) return super.getProvider(name);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        LocationProvider output = null;
+        
+        if (pSet != null) {
+            if (name.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = super.getProvider(name);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                }
+            } else if (name.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.getProvider(name);
+                }
+            }
+        } else {
+            output = super.getProvider(name);
+        }
+            
+//        Log.d(TAG, "getProvider - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + 
+//                (output != null ? "[real value]" : "[null]"));
+        return output;
+    }
+
+    @Override
+    public boolean isProviderEnabled(String provider) {
+        if (provider == null) return super.isProviderEnabled(provider);
+        
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        boolean output = false;
+        
+        if (pSet != null) {
+            if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                switch (pSet.getLocationGpsSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                switch (pSet.getLocationNetworkSetting()) {
+                    case PrivacySettings.REAL:
+                        output = super.isProviderEnabled(provider);
+                        break;
+                    case PrivacySettings.EMPTY:
+                        break;
+                    case PrivacySettings.CUSTOM:
+                    case PrivacySettings.RANDOM:
+                        output = true;
+                        break;
+                }
+            } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                if (pSet.getLocationGpsSetting() == PrivacySettings.REAL || 
+                        pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                    output = super.isProviderEnabled(provider);
+                } else {
+                    output = false;
+                }
+            }
+        } else { // if querying unknown provider
+            output = super.isProviderEnabled(provider);
+        }
+        
+//        Log.d(TAG, "isProviderEnabled - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") provider: " 
+//                + provider + "output: " + output);
+        return output;
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, LocationListener listener,
+            Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(long minTime, float minDistance, Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestLocationUpdates(minTime, minDistance, criteria, intent);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener,
+            Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener, looper);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, LocationListener listener) {
+        if (provider == null || listener == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, listener);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, listener);
+    }
+
+    @Override
+    public void requestLocationUpdates(String provider, long minTime, float minDistance, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestLocationUpdates(provider, minTime, minDistance, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestLocationUpdates(provider, minTime, minDistance, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, LocationListener listener, Looper looper) {
+        if (criteria == null || listener == null) {
+            super.requestSingleUpdate(criteria, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(criteria, listener, null)) return;
+        super.requestSingleUpdate(criteria, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(Criteria criteria, PendingIntent intent) {
+        if (criteria == null || intent == null) {
+            super.requestSingleUpdate(criteria, intent);
+            return;
+        }
+        if (requestLocationUpdates(criteria, null, intent)) return;
+        super.requestSingleUpdate(criteria, intent);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, LocationListener listener, Looper looper) {
+        if (provider == null || listener == null) {
+            super.requestSingleUpdate(provider, listener, looper);
+            return;
+        }
+        if (requestLocationUpdates(provider, listener, null)) return;
+        super.requestSingleUpdate(provider, listener, looper);
+    }
+
+    @Override
+    public void requestSingleUpdate(String provider, PendingIntent intent) {
+        if (provider == null || intent == null) {
+            super.requestSingleUpdate(provider, intent);
+            return;
+        }
+        if (requestLocationUpdates(provider, null, intent)) return;
+        super.requestSingleUpdate(provider, intent);
+    }
+    
+    /**
+     * Monitoring purposes only
+     */
+//    @Override
+//    public boolean sendExtraCommand(String provider, String command, Bundle extras) {
+//        Log.d(TAG, "sendExtraCommand - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        return super.sendExtraCommand(provider, command, extras);
+//    }
+
+    /**
+     * Handles calls to requestLocationUpdates and requestSingleUpdate methods
+     * @return true, if action has been taken
+     *         false, if the processing needs to be passed to the default method
+     */
+    private boolean requestLocationUpdates(String provider, LocationListener listener, PendingIntent intent) {
+        synchronized (lock) { // custom listener should only return a value after this method has returned
+
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            boolean output = false;
+            
+            if (pSet != null) {
+                if (provider.equals(LocationManager.GPS_PROVIDER)) {
+                    switch (pSet.getLocationGpsSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationGpsLat()), 
+                                        Double.parseDouble(pSet.getLocationGpsLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_GPS, 
+                                    "Lat: " + pSet.getLocationGpsLat() + " Lon: " + pSet.getLocationGpsLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    switch (pSet.getLocationNetworkSetting()) {
+                        case PrivacySettings.REAL:
+                            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.EMPTY:
+                            if (intent != null) intent.cancel();
+                            output = true;
+                            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);                            
+                            break;
+                        case PrivacySettings.CUSTOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.CUSTOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                        case PrivacySettings.RANDOM:
+                            try {
+                                new PrivacyLocationUpdater(provider, listener, intent, 
+                                        Double.parseDouble(pSet.getLocationNetworkLat()), 
+                                        Double.parseDouble(pSet.getLocationNetworkLon())).start();
+                                output = true;
+                            } catch (NumberFormatException e) {
+                                Log.e(TAG, "requestLocationUpdates: invalid coordinates");
+                                output = true;
+                            }
+                            pSetMan.notification(packageName, uid, PrivacySettings.RANDOM, PrivacySettings.DATA_LOCATION_NETWORK, 
+                                    "Lat: " + pSet.getLocationNetworkLat() + " Lon: " + pSet.getLocationNetworkLon(), pSet);
+                            break;
+                    }
+                } else if (provider.equals(LocationManager.PASSIVE_PROVIDER)) { // could get location from any of above
+                    if (pSet.getLocationGpsSetting() == PrivacySettings.REAL && 
+                            pSet.getLocationNetworkSetting() == PrivacySettings.REAL) {
+                        output = false;
+                        pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    } else {
+                        output = true;
+                        pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                    }
+                }
+            } else {
+                if (provider.equals(LocationManager.NETWORK_PROVIDER)) {
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+                } else { // including GPS and passive providers
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_GPS, null, pSet);
+                }
+            }
+            
+//            Log.d(TAG, "requestLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + 
+//                    ") output: " + (output == true ? "[custom location]" : "[real value]"));
+            return output;
+        }
+    }
+    
+    /**
+     * Helper method for categorizing the different requestLocationUpdates calls by
+     * provider accuracy and handing them off to 
+     * {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     * @param criteria
+     * @param listener
+     * @param intent
+     * @return see {@link android.privacy.surrogate.PrivacyLocationManager#requestLocationUpdates(String, LocationListener, PendingIntent)}
+     */
+    private boolean requestLocationUpdates(Criteria criteria, LocationListener listener, PendingIntent intent) {
+        if (criteria == null) return false;
+            // treat providers with high accuracy as GPS providers
+        else if (criteria.getAccuracy() == Criteria.ACCURACY_FINE || 
+                criteria.getBearingAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getHorizontalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getVerticalAccuracy() == Criteria.ACCURACY_HIGH || 
+                criteria.getSpeedAccuracy() == Criteria.ACCURACY_HIGH) {
+            return requestLocationUpdates(LocationManager.GPS_PROVIDER, listener, intent);
+        } else { // treat all others as network providers
+            return requestLocationUpdates(LocationManager.NETWORK_PROVIDER, listener, intent);
+        }
+    }
+    
+    private class PrivacyLocationUpdater extends Thread {
+        
+        private String provider;
+        
+        private LocationListener listener;
+        
+        private PendingIntent intent;
+        
+        private double latitude;
+        
+        private double longitude;
+
+        public PrivacyLocationUpdater(String provider, LocationListener listener, PendingIntent intent,
+                double latitude, double longitude) {
+            this.provider = provider;
+            this.listener = listener;
+            this.intent = intent;
+            this.latitude = latitude;
+            this.longitude = longitude;
+        }
+
+        @Override
+        public void run() {
+            if (provider != null) {
+                Location location = new Location(provider);
+                location.setLatitude(latitude);
+                location.setLongitude(longitude);
+                for (int i = 0; i < CUSTOM_LOCATION_UPDATE_COUNT; i++) {
+                    if (listener != null) {
+                        listener.onLocationChanged(location);
+                    } else if (intent != null) {
+                        // no custom or random location implemented due to complexity
+                        intent.cancel();
+                    }
+                    try {
+                        sleep((int)(Math.random() * 1000));
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+        }
+        
+    }
+
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
new file mode 100644
index 0000000..5beefe4
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyTelephonyManager.java
@@ -0,0 +1,520 @@
+/**
+ * Copyright (C) 2012 Svyatoslav Hresyk
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License as published by the Free Software
+ * Foundation; either version 3 of the License, or (at your option) any later version.
+ * This program is distributed in the hope that it will be useful, but WITHOUT ANY
+ * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+ * PARTICULAR PURPOSE. See the GNU General Public License for more details.
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, see <http://www.gnu.org/licenses>.
+ */
+
+package android.privacy.surrogate;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.Context;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellLocation;
+import android.telephony.NeighboringCellInfo;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.util.Log;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Random;
+
+import android.telephony.CellInfo;
+
+/**
+ * Provides privacy handling for {@link android.telephony.TelephonyManager}
+ * @author Svyatoslav Hresyk
+ * {@hide}
+ */
+public final class PrivacyTelephonyManager extends TelephonyManager {
+
+    private static final String TAG = "PrivacyTelephonyManager";
+    
+    private Context context;
+    
+    private PrivacySettingsManager pSetMan;
+    
+    /** {@hide} */
+    public PrivacyTelephonyManager(Context context) {
+        super(context);
+        this.context = context;
+//        pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+        // don't call getSystemService to avoid getting java.lang.IllegalStateException: 
+        // System services not available to Activities before onCreate()
+        pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+    }
+    
+    /**
+     * IMEI
+     */
+    @Override
+    public String getDeviceId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getDeviceId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        } else {
+            output = super.getDeviceId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+        }
+//        Log.d(TAG, "getDeviceId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Phone number
+     */
+    @Override
+    public String getLine1Number() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getLine1Number();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getLine1Number - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Will be handled like the Line1Number, since voice mailbox numbers often
+     * are similar to the phone number of the subscriber.
+     */
+    @Override
+    public String getVoiceMailNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getLine1Number(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        } else {
+            output = super.getVoiceMailNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+        }
+//        Log.d(TAG, "getVoiceMailNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Intercept requests for mobile network cell information. This can be used for tracking network
+     * based location.
+     */
+    @Override
+    public List<NeighboringCellInfo> getNeighboringCellInfo() {
+        PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<NeighboringCellInfo> output = null;
+        String output_label = "[null]";
+        
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+                // output = null;
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<NeighboringCellInfo>();
+                output_label = "[empty list of cells]";
+            } else {
+                output = super.getNeighboringCellInfo();
+                String cells = "";
+                for (NeighboringCellInfo i : output) cells += "\t" + i + "\n";
+                output_label = "[real value]:\n" + cells;
+            }
+        }
+        
+//        Log.d(TAG, "getNeighboringCellInfo - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output_label);
+        return output;
+    }
+    
+    @Override
+    public String getNetworkCountryIso() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkCountryIso();
+//        Log.d(TAG, "getNetworkCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperator() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperator();
+//        Log.d(TAG, "getNetworkOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getNetworkOperatorName() {
+        String output = getNetworkInfo();
+        if (output == null) output = super.getNetworkOperatorName();
+//        Log.d(TAG, "getNetworkOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following Network Information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */
+    private String getNetworkInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getNetworkInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_CURRENT, null, pSet);            
+            return null;
+        }        
+    }
+    
+    @Override
+    public String getSimCountryIso() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimCountryIso();
+//        Log.d(TAG, "getSimCountryIso - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperator() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperator();
+//        Log.d(TAG, "getSimOperator - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    @Override
+    public String getSimOperatorName() {
+        String output = getSimInfo();
+        if (output == null) output = super.getSimOperatorName();
+//        Log.d(TAG, "getSimOperatorName - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * Handles following SIM Card information requests: CountryIso, Operator Code, Operator Name
+     * @return value to return if applicable or null if real value should be returned
+     */    
+    private String getSimInfo() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        if (pSet != null && pSet.getSimInfoSetting() != PrivacySettings.REAL) {
+            pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return ""; // can only be empty
+        } else {
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_NETWORK_INFO_SIM, null, pSet);            
+            return null;
+        }                
+    }
+    
+    /**
+     * ICCID
+     */
+    @Override
+    public String getSimSerialNumber() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+        if (pSet != null && pSet.getSimSerialNumberSetting() != PrivacySettings.REAL) {
+            output = pSet.getSimSerialNumber(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSimSerialNumberSetting(), PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        } else {
+            output = super.getSimSerialNumber();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SIM_SERIAL, output, pSet);            
+        }
+//        Log.d(TAG, "getSimSerialNumber - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+    
+    /**
+     * IMSI
+     */
+    @Override
+    public String getSubscriberId() {
+        String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+        String output;
+	Log.i(TAG, "getSubscriberId() - " + context.getPackageName());
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        } else {
+            output = super.getSubscriberId();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output, pSet);            
+        }
+//        Log.d(TAG, "getSubscriberId - " + context.getPackageName() + " (" + Binder.getCallingUid() + ") output: " + output);
+        return output;
+    }
+
+    /**
+     * For monitoring purposes only
+     */    
+//    @Override
+//    public void enableLocationUpdates() {
+////        Log.d(TAG, "enableLocationUpdates - " + context.getPackageName() + " (" + Binder.getCallingUid() + ")");
+//        super.enableLocationUpdates();
+//    }
+
+    @Override
+    public void listen(PhoneStateListener listener, int events) {
+//        Log.d(TAG, "listen - package:" + context.getPackageName() + " uid:" + Binder.getCallingUid() + " events: " + events);
+        if (((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) || ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0)) {
+	    //first check if context exists
+	    String pkgForDebug = context != null ? context.getPackageName() : null;
+	    if(pkgForDebug != null){
+            	listener.setPackageName(pkgForDebug); //we only have to set it if context != null, because if context == null will cause the listener gives no update to app
+		listener.setContext(context);
+            }
+            listener.setUid(Binder.getCallingUid());
+            super.listen(listener, events);
+//            Log.d(TAG, "listen for cell location or call state - " + context.getPackageName() + " (" + 
+//                    Binder.getCallingUid() + ") output: custom listener");
+        } else {
+            super.listen(listener, events);
+        }
+    }
+    //NEW PRIVACY------------------------------------------------------------------------------------------------------------------------------------------
+ 
+   /**
+     * Returns the current location of the device.
+     * Return null if current location is not available.
+     * That method is new -> fix it!
+     * @author CollegeDev
+     */
+    @Override
+    public CellLocation getCellLocation() {
+        try {
+	    String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+            if (pSet != null && ((pSet.getLocationNetworkSetting() != PrivacySettings.REAL) || (pSet.getLocationGpsSetting() != PrivacySettings.REAL))) {
+		pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+		return null;
+	    } else {
+		pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);
+		CellLocation cl = super.getCellLocation();
+		return cl;
+	    }
+        } catch(Exception e) {
+		return null;
+	}
+    }
+    
+   /**
+     * Returns the software version number for the device, for example,
+     * the IMEI/SV for GSM phones. Can control with deviceIdSetting
+     *
+     */
+    @Override
+    public String getDeviceSoftwareVersion() {
+        try {
+	    String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	    String output = "";
+	    if (pSet != null && pSet.getDeviceIdSetting() != PrivacySettings.REAL) {
+            	output = pSet.getDeviceId(); // can be empty, custom or random
+            	pSetMan.notification(packageName, uid, pSet.getDeviceIdSetting(), PrivacySettings.DATA_DEVICE_ID, output, pSet);
+       	    } else {
+            	output = super.getDeviceSoftwareVersion();
+            	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_DEVICE_ID, output, pSet);
+            }
+            return output;
+        } catch (Exception e){
+		return null;
+	}
+    }
+
+    /**
+     * 
+     * @hide
+     */
+    @Override
+    public String getCompleteVoiceMailNumber() {
+        try {
+            String packageName = context.getPackageName();
+            int uid = Binder.getCallingUid();
+            PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	    String output = "";
+	    if (pSet != null && pSet.getLine1NumberSetting() != PrivacySettings.REAL) {
+            	output = pSet.getLine1Number(); // can be empty, custom or random
+            	pSetMan.notification(packageName, uid, pSet.getLine1NumberSetting(), PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+            } else {
+            	output = super.getCompleteVoiceMailNumber();
+           	pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LINE_1_NUMBER, output, pSet);
+       	    }
+            return output;
+        } catch (Exception e){
+		return null;
+	}
+    }
+    //all types for better overview, based on ics 4.0.4
+    private static final int PHONE_TYPES[] = {PHONE_TYPE_NONE, PHONE_TYPE_GSM, PHONE_TYPE_CDMA, PHONE_TYPE_SIP};
+    private static final int NETWORK_TYPES[] = {NETWORK_TYPE_UNKNOWN, NETWORK_TYPE_GPRS, NETWORK_TYPE_EDGE,
+						NETWORK_TYPE_UMTS, NETWORK_TYPE_CDMA, NETWORK_TYPE_EVDO_0,
+						NETWORK_TYPE_EVDO_A, NETWORK_TYPE_1xRTT, NETWORK_TYPE_HSDPA,
+						NETWORK_TYPE_HSUPA, NETWORK_TYPE_HSPA, NETWORK_TYPE_IDEN,
+						NETWORK_TYPE_EVDO_B, NETWORK_TYPE_LTE, NETWORK_TYPE_EHRPD,
+						NETWORK_TYPE_HSPAP};
+
+    /**
+     * Returns a constant indicating the device phone type.  If user block network info, it returns random generated type of phone.
+     *
+     * @see #PHONE_TYPE_NONE
+     * @see #PHONE_TYPE_GSM
+     * @see #PHONE_TYPE_CDMA
+     * @see #PHONE_TYPE_SIP
+     */
+    @Override
+    public int getPhoneType() {
+	String output = getNetworkInfo();
+	//no random support until now in pdroid, change addonApp to support it?
+	//Random x = new Random();
+	int type = PHONE_TYPES[/*x.nextInt(PHONE_TYPES.length-1)*/0];
+	if(output == null) type = super.getPhoneType();
+        return type;
+    }
+
+    /**
+     * Returns a constant indicating the radio technology (network type)
+     * currently in use on the device for data transmission.(If user block network info, it returns random generated type of network.)
+     * @return the network type
+     *
+     * @see #NETWORK_TYPE_UNKNOWN
+     * @see #NETWORK_TYPE_GPRS
+     * @see #NETWORK_TYPE_EDGE
+     * @see #NETWORK_TYPE_UMTS
+     * @see #NETWORK_TYPE_HSDPA
+     * @see #NETWORK_TYPE_HSUPA
+     * @see #NETWORK_TYPE_HSPA
+     * @see #NETWORK_TYPE_CDMA
+     * @see #NETWORK_TYPE_EVDO_0
+     * @see #NETWORK_TYPE_EVDO_A
+     * @see #NETWORK_TYPE_EVDO_B
+     * @see #NETWORK_TYPE_1xRTT
+     * @see #NETWORK_TYPE_IDEN
+     * @see #NETWORK_TYPE_LTE
+     * @see #NETWORK_TYPE_EHRPD
+     * @see #NETWORK_TYPE_HSPAP
+     */
+    @Override
+    public int getNetworkType() {
+        try{
+            String output = getNetworkInfo();
+	    //no random support until now in pdroid, change addonApp to support it?
+	    //Random x = new Random();
+	    int type = NETWORK_TYPES[/*x.nextInt(NETWORK_TYPES.length-1)*/0];
+            if(output == null) type = super.getNetworkType();
+	    return type;
+
+        } catch(Exception e){
+        	return NETWORK_TYPES[0];
+        }
+    }
+    
+    /**
+     * Will be handled like getLine1Number
+     */
+    @Override
+    public String getLine1AlphaTag(){
+    	return getLine1Number();
+    }
+    
+    /**
+     * 15 character long numbers -> handle same as imsi
+     */
+    public String getMsisdn() {
+	Log.i(TAG, "getMsisdn() - " + context.getPackageName());
+    	return getSubscriberId();
+    }
+    
+    /**
+     * It doesn't matter if we give some shit to it, it will work
+     */
+    public String getVoiceMailAlphaTag() {
+    	return getVoiceMailNumber();
+    }
+    
+    /**
+     * @hide
+     * handles like subscriber id
+     */
+    public String getIsimImpi() {
+	Log.i(TAG, "getIsimImpi - " + context.getPackageName());
+    	return getSubscriberId();
+    }
+    
+    /**
+     * @hide
+     * lets play with this function, handled like NetworkOperatorName
+     */
+    public String getIsimDomain() {
+    	return getNetworkOperatorName();
+    }
+    
+    /**
+     * @hide
+     * lets play with this function, handled like subscriberID
+     */
+    public String[] getIsimImpu() {
+    	String packageName = context.getPackageName();
+        int uid = Binder.getCallingUid();
+        PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+	Log.i(TAG, "getIsimImpu() - " + context.getPackageName());
+        String output[] = new String[1];
+        if (pSet != null && pSet.getSubscriberIdSetting() != PrivacySettings.REAL) {
+            output[0] = pSet.getSubscriberId(); // can be empty, custom or random
+            pSetMan.notification(packageName, uid, pSet.getSubscriberIdSetting(), PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet);            
+        } else {
+            output = super.getIsimImpu();
+            pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_SUBSCRIBER_ID, output[0], pSet);            
+        }
+        return output;
+    }
+    /**
+     * @hide
+     * @return
+     */
+    public List<CellInfo> getAllCellInfo() {
+    	PrivacySettings pSet = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+        List<CellInfo> output = null;
+        if (pSet != null) {
+            if (pSet.getLocationNetworkSetting() == PrivacySettings.EMPTY) {
+            	output = new ArrayList<CellInfo>();
+            } else if (pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                output = new ArrayList<CellInfo>();
+            } else {
+                output = super.getAllCellInfo();
+            }
+        }
+        return output;
+    }
+}
diff --git a/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java b/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java
new file mode 100644
index 0000000..39d1d0f
--- /dev/null
+++ b/privacy/java/android/privacy/surrogate/PrivacyWifiManager.java
@@ -0,0 +1,207 @@
+/**
+* Copyright (C) 2012 CollegeDev
+* This program is free software; you can redistribute it and/or modify it under
+* the terms of the GNU General Public License as published by the Free Software
+* Foundation; either version 3 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful, but WITHOUT ANY
+* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+* PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License along with
+* this program; if not, see <http://www.gnu.org/licenses>.
+*/
+
+package android.privacy.surrogate;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import android.content.Context;
+import android.net.DhcpInfo;
+import android.net.wifi.IWifiManager;
+import android.net.wifi.ScanResult;
+import android.net.wifi.WifiConfiguration;
+import android.net.wifi.WifiInfo;
+import android.net.wifi.WifiManager;
+import android.os.Binder;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.util.Log;
+
+/**
+ * Provides privacy handling for WifiManager
+ * @author CollegeDev
+ * {@hide}
+ */
+public class PrivacyWifiManager extends WifiManager{
+
+	private Context context;
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private static final String P_TAG = "PrivacyWifiManager";
+	
+
+	public PrivacyWifiManager(Context context, IWifiManager service){
+		super(context, service);
+		this.context = context;
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+	}
+	
+	@Override
+	public List<WifiConfiguration> getConfiguredNetworks() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		List<WifiConfiguration> output = new ArrayList<WifiConfiguration>(); //create empty list!
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);   
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getConfiguredNetworks();
+		}
+	}
+	
+	@Override
+	public WifiInfo getConnectionInfo() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		//we have to change WifiInfo constructor for faking data -> change WifiInfo in framework!
+		WifiInfo output = new WifiInfo(true);
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getConnectionInfo();
+		}
+	}
+	
+	@Override
+	public List<ScanResult> getScanResults() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		List<ScanResult> output = new ArrayList<ScanResult>(); //create empty list!
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return output;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getScanResults();
+		}
+	}
+	
+	@Override
+	public int getFrequencyBand() {
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return -1;
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getFrequencyBand();
+		}
+	}
+	
+	@Override
+	public DhcpInfo getDhcpInfo(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return new DhcpInfo();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getDhcpInfo();
+		}
+	}
+	
+	/**
+	 * @hide
+	 * @return
+	 */
+	@Override
+	public WifiConfiguration getWifiApConfiguration(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return new WifiConfiguration();
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getWifiApConfiguration();
+		}
+	}
+	
+
+	@Override
+	public String getConfigFile(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return "";
+		}
+		else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.getConfigFile();
+		}
+	}
+	//new
+	@Override
+	public boolean startScan(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null); 
+			return super.startScan();
+		}
+	}
+	
+	
+	@Override
+	public boolean setWifiEnabled(boolean enabled){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getSwitchWifiStateSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_SWITCH_WIFI_STATE, null, null); 
+			return super.setWifiEnabled(enabled);
+		}
+	}
+	
+	@Override
+	public int getWifiState(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return WIFI_STATE_ENABLED;
+		} else if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return WIFI_STATE_UNKNOWN;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return super.getWifiState();
+		}
+	}
+	
+	@Override
+	public boolean isWifiEnabled(){
+		PrivacySettings settings = pSetMan.getSettings(context.getPackageName(), Binder.getCallingUid());
+		if(pSetMan != null && settings != null && settings.getForceOnlineState() == PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return true;
+		} else if(pSetMan != null && settings != null && settings.getWifiInfoSetting() != PrivacySettings.REAL){
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.EMPTY, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return false;
+		} else{
+			pSetMan.notification(context.getPackageName(),-1, PrivacySettings.REAL, PrivacySettings.DATA_WIFI_INFO, null, null);  
+			return super.isWifiEnabled();
+		}
+	}
+}
diff --git a/services/java/com/android/server/LocationManagerService.java b/services/java/com/android/server/LocationManagerService.java
index 3fb5b96..e8d0364 100644
--- a/services/java/com/android/server/LocationManagerService.java
+++ b/services/java/com/android/server/LocationManagerService.java
@@ -59,11 +59,13 @@ import android.os.SystemClock;
 import android.os.UserHandle;
 import android.os.WorkSource;
 import android.provider.Settings;
+import android.text.TextUtils;
 import android.util.Log;
 import android.util.Slog;
 import com.android.internal.content.PackageMonitor;
 import com.android.internal.location.ProviderProperties;
 import com.android.internal.location.ProviderRequest;
+import com.android.server.location.BTGpsLocationProvider;
 import com.android.server.location.GeocoderProxy;
 import com.android.server.location.GeofenceProxy;
 import com.android.server.location.GeofenceManager;
@@ -349,6 +351,17 @@ public class LocationManagerService extends ILocationManager.Stub {
         GpsLocationProvider gpsProvider = new GpsLocationProvider(mContext, this,
                 mLocationHandler.getLooper());
 
+        // Create a gps location provider based on the setting EXTERNAL_GPS_BT_DEVICE
+        String btDevice = Settings.System.getString(mContext.getContentResolver(),
+                Settings.Secure.EXTERNAL_GPS_BT_DEVICE);
+        if (TextUtils.isEmpty(btDevice)) {
+            // default option
+            btDevice = "0";
+            Settings.System.putString(mContext.getContentResolver(),
+                    Settings.Secure.EXTERNAL_GPS_BT_DEVICE, btDevice);
+        }
+        setGPSSource(btDevice);
+
         if (GpsLocationProvider.isSupported()) {
             mGpsStatusProvider = gpsProvider.getGpsStatusProvider();
             mNetInitiatedListener = gpsProvider.getNetInitiatedListener();
@@ -447,6 +460,31 @@ public class LocationManagerService extends ILocationManager.Stub {
 
     }
 
+    public void setGPSSource(String device) {
+        synchronized (mLock) {
+            if (mProvidersByName.containsKey(LocationManager.GPS_PROVIDER)) {
+                LocationProviderInterface mGpsLocationProvider = mProvidersByName.get(LocationManager.GPS_PROVIDER);
+                removeProviderLocked(mGpsLocationProvider);
+                Settings.Secure.setLocationProviderEnabled(mContext.getContentResolver(),
+                        LocationManager.GPS_PROVIDER, false);
+            }
+            Slog.i(TAG, "Setting GPS Source to: " + device);
+            if ("0".equals(device)) {
+                if (!GpsLocationProvider.isSupported())
+                    return;
+                 GpsLocationProvider gpsProvider = new GpsLocationProvider(mContext, this, mLocationHandler.getLooper());
+                 mGpsStatusProvider = gpsProvider.getGpsStatusProvider();
+                 mNetInitiatedListener = gpsProvider.getNetInitiatedListener();
+                 addProviderLocked(gpsProvider);
+            } else {
+                 BTGpsLocationProvider gpsProvider = new BTGpsLocationProvider(mContext, this, mLocationHandler.getLooper());
+                 mGpsStatusProvider = gpsProvider.getGpsStatusProvider();
+                 mNetInitiatedListener = null;
+                 addProviderLocked(gpsProvider);
+            }
+        }
+    }
+
     /**
      * Called when the device's active user changes.
      * @param userId the new active user's UserId
diff --git a/services/java/com/android/server/NotificationManagerService.java b/services/java/com/android/server/NotificationManagerService.java
index c0335ab..9facb48 100644
--- a/services/java/com/android/server/NotificationManagerService.java
+++ b/services/java/com/android/server/NotificationManagerService.java
@@ -77,12 +77,16 @@ import android.view.accessibility.AccessibilityEvent;
 import android.view.accessibility.AccessibilityManager;
 import android.widget.Toast;
 
+import com.android.internal.util.FastXmlSerializer;
+
 import org.xmlpull.v1.XmlPullParser;
 import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
 
 import java.io.File;
 import java.io.FileDescriptor;
 import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintWriter;
@@ -208,14 +212,19 @@ public class NotificationManagerService extends INotificationManager.Stub
     private HashSet<String> mEnabledListenerPackageNames = new HashSet<String>();
 
     // Notification control database. For now just contains disabled packages.
-    private AtomicFile mPolicyFile;
+    private AtomicFile mPolicyFile, mHaloPolicyFile;
     private HashSet<String> mBlockedPackages = new HashSet<String>();
+    private HashSet<String> mHaloBlacklist = new HashSet<String>();
+    private HashSet<String> mHaloWhitelist = new HashSet<String>();
+    private boolean mHaloPolicyisBlack = true;
 
     private static final int DB_VERSION = 1;
 
     private static final String TAG_BODY = "notification-policy";
     private static final String ATTR_VERSION = "version";
+    private static final String ATTR_HALO_POLICY_IS_BLACK = "policy_is_black";
 
+    private static final String TAG_ALLOWED_PKGS = "allowed-packages";
     private static final String TAG_BLOCKED_PKGS = "blocked-packages";
     private static final String TAG_PACKAGE = "package";
     private static final String ATTR_NAME = "name";
@@ -402,45 +411,181 @@ public class NotificationManagerService extends INotificationManager.Stub
                 mPolicyFile = new AtomicFile(new File(dir, "notification_policy.xml"));
 
                 mBlockedPackages.clear();
+                readPolicy(mPolicyFile, TAG_BLOCKED_PKGS, mBlockedPackages);
+            }
+        }
+    }
 
-                FileInputStream infile = null;
-                try {
-                    infile = mPolicyFile.openRead();
-                    final XmlPullParser parser = Xml.newPullParser();
-                    parser.setInput(infile, null);
+    private int readPolicy(AtomicFile file, String lookUpTag, HashSet<String> db) {
+        return readPolicy(file, lookUpTag, db, null, 0);
+    }
 
-                    int type;
-                    String tag;
-                    int version = DB_VERSION;
-                    while ((type = parser.next()) != END_DOCUMENT) {
-                        tag = parser.getName();
-                        if (type == START_TAG) {
-                            if (TAG_BODY.equals(tag)) {
-                                version = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
-                            } else if (TAG_BLOCKED_PKGS.equals(tag)) {
-                                while ((type = parser.next()) != END_DOCUMENT) {
-                                    tag = parser.getName();
-                                    if (TAG_PACKAGE.equals(tag)) {
-                                        mBlockedPackages.add(parser.getAttributeValue(null, ATTR_NAME));
-                                    } else if (TAG_BLOCKED_PKGS.equals(tag) && type == END_TAG) {
-                                        break;
-                                    }
-                                }
+    private int readPolicy(AtomicFile file, String lookUpTag, HashSet<String> db, String resultTag, int defaultResult) {
+        int result = defaultResult;
+        FileInputStream infile = null;
+        try {
+            infile = file.openRead();
+            final XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(infile, null);
+
+            int type;
+            String tag;
+            int version = DB_VERSION;
+            while ((type = parser.next()) != END_DOCUMENT) {
+                tag = parser.getName();
+                if (type == START_TAG) {
+                    if (TAG_BODY.equals(tag)) {
+                        version = Integer.parseInt(parser.getAttributeValue(null, ATTR_VERSION));
+                        if (resultTag != null) {
+                            String attribValue = parser.getAttributeValue(null, resultTag);
+                            result = Integer.parseInt((attribValue != null ? attribValue : "0"));
+                        }
+                    } else if (lookUpTag.equals(tag)) {
+                        while ((type = parser.next()) != END_DOCUMENT) {
+                            tag = parser.getName();
+                            if (TAG_PACKAGE.equals(tag)) {
+                                db.add(parser.getAttributeValue(null, ATTR_NAME));
+                            } else if (lookUpTag.equals(tag) && type == END_TAG) {
+                                break;
                             }
                         }
                     }
-                } catch (FileNotFoundException e) {
-                    // No data yet
-                } catch (IOException e) {
-                    Log.wtf(TAG, "Unable to read blocked notifications database", e);
-                } catch (NumberFormatException e) {
-                    Log.wtf(TAG, "Unable to parse blocked notifications database", e);
-                } catch (XmlPullParserException e) {
-                    Log.wtf(TAG, "Unable to parse blocked notifications database", e);
-                } finally {
-                    IoUtils.closeQuietly(infile);
                 }
             }
+        } catch (Exception e) {
+            // Unable to read
+        } finally {
+            IoUtils.closeQuietly(infile);
+        }
+        return result;
+    }
+
+    private synchronized void loadHaloBlockDb() {
+        if (mHaloPolicyFile == null) {
+            mHaloPolicyFile = new AtomicFile(new File("/data/system", "halo_policy.xml"));
+            mHaloBlacklist.clear();
+            mHaloPolicyisBlack = readPolicy(mHaloPolicyFile, TAG_BLOCKED_PKGS, mHaloBlacklist, ATTR_HALO_POLICY_IS_BLACK, 1) == 1;
+            mHaloWhitelist.clear();
+            readPolicy(mHaloPolicyFile, TAG_ALLOWED_PKGS, mHaloWhitelist);
+        }
+    }
+
+    private void writeBlockDb() {
+        synchronized(mBlockedPackages) {
+            FileOutputStream outfile = null;
+            try {
+                outfile = mPolicyFile.startWrite();
+
+                XmlSerializer out = new FastXmlSerializer();
+                out.setOutput(outfile, "utf-8");
+
+                out.startDocument(null, true);
+
+                out.startTag(null, TAG_BODY); {
+                    out.attribute(null, ATTR_VERSION, String.valueOf(DB_VERSION));
+                    out.startTag(null, TAG_BLOCKED_PKGS); {
+                        // write all known network policies
+                        for (String pkg : mBlockedPackages) {
+                            out.startTag(null, TAG_PACKAGE); {
+                                out.attribute(null, ATTR_NAME, pkg);
+                            } out.endTag(null, TAG_PACKAGE);
+                        }
+                    } out.endTag(null, TAG_BLOCKED_PKGS);
+                } out.endTag(null, TAG_BODY);
+
+                out.endDocument();
+
+                mPolicyFile.finishWrite(outfile);
+            } catch (IOException e) {
+                if (outfile != null) {
+                    mPolicyFile.failWrite(outfile);
+                }
+            }
+        }
+    }
+
+    private synchronized void writeHaloBlockDb() {
+        FileOutputStream outfile = null;
+        try {
+            outfile = mHaloPolicyFile.startWrite();
+
+            XmlSerializer out = new FastXmlSerializer();
+            out.setOutput(outfile, "utf-8");
+
+            out.startDocument(null, true);
+
+            out.startTag(null, TAG_BODY); {
+                out.attribute(null, ATTR_VERSION, String.valueOf(DB_VERSION));
+                out.attribute(null, ATTR_HALO_POLICY_IS_BLACK, (mHaloPolicyisBlack ? "1" : "0"));
+
+                    out.startTag(null, TAG_BLOCKED_PKGS); {
+                        for (String blockedPkg : mHaloBlacklist) {
+                            out.startTag(null, TAG_PACKAGE); {
+                                out.attribute(null, ATTR_NAME, blockedPkg);
+                            } out.endTag(null, TAG_PACKAGE);
+                        }
+                    } out.endTag(null, TAG_BLOCKED_PKGS);
+                    
+                    out.startTag(null, TAG_ALLOWED_PKGS); {
+                        for (String allowedPkg : mHaloWhitelist) {
+                            out.startTag(null, TAG_PACKAGE); {
+                                out.attribute(null, ATTR_NAME, allowedPkg);
+                            } out.endTag(null, TAG_PACKAGE);
+                        }
+                    } out.endTag(null, TAG_ALLOWED_PKGS);
+
+            } out.endTag(null, TAG_BODY);
+
+            out.endDocument();
+
+            mHaloPolicyFile.finishWrite(outfile);
+        } catch (IOException e) {
+            if (outfile != null) {
+                mHaloPolicyFile.failWrite(outfile);
+            }
+        }
+    }
+
+    public void setHaloPolicyBlack(boolean state) {
+        mHaloPolicyisBlack = state;
+        writeHaloBlockDb();
+    }
+
+    public void setHaloStatus(String pkg, boolean status) {
+        if (mHaloPolicyisBlack) {
+            setHaloBlacklistStatus(pkg, status);
+        } else {
+            setHaloWhitelistStatus(pkg, status);
+        }
+    }
+
+    public void setHaloBlacklistStatus(String pkg, boolean status) {
+        if (status) {
+            mHaloBlacklist.add(pkg);            
+        } else {
+            mHaloBlacklist.remove(pkg);
+        }
+        writeHaloBlockDb();
+    }
+
+    public void setHaloWhitelistStatus(String pkg, boolean status) {
+        if (status) {
+            mHaloWhitelist.add(pkg);            
+        } else {
+            mHaloWhitelist.remove(pkg);
+        }
+        writeHaloBlockDb();
+    }
+
+    public boolean isHaloPolicyBlack() {
+        return mHaloPolicyisBlack;
+    }
+
+    public boolean isPackageAllowedForHalo(String pkg) {
+        if (mHaloPolicyisBlack) {
+            return !mHaloBlacklist.contains(pkg);
+        } else {
+            return mHaloWhitelist.contains(pkg);
         }
     }
 
@@ -1399,6 +1544,8 @@ public class NotificationManagerService extends INotificationManager.Stub
         mAppOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
 
         importOldBlockDb();
+        loadBlockDb();
+        loadHaloBlockDb();
 
         mStatusBar = statusBar;
         statusBar.setNotificationCallbacks(mNotificationCallbacks);
diff --git a/services/java/com/android/server/PrivacyTelephonyRegistry.java b/services/java/com/android/server/PrivacyTelephonyRegistry.java
new file mode 100644
index 0000000..7e7d457
--- /dev/null
+++ b/services/java/com/android/server/PrivacyTelephonyRegistry.java
@@ -0,0 +1,402 @@
+package com.android.server;
+
+import com.android.internal.telephony.IPhoneStateListener;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.privacy.IPrivacySettingsManager;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.telephony.CellInfo;
+import android.telephony.CellInfoGsm;
+import android.telephony.CellIdentityGsm;
+import android.telephony.PhoneStateListener;
+import android.telephony.ServiceState;
+import android.telephony.SignalStrength;
+import android.telephony.TelephonyManager;
+import android.telephony.cdma.CdmaCellLocation;
+import android.telephony.gsm.GsmCellLocation;
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Arrays;
+import android.util.Log;
+import android.os.Process;
+
+
+public class PrivacyTelephonyRegistry extends TelephonyRegistry{
+
+	private static final String P_TAG = "PrivacyTelephonyRegistry";
+	
+	private PrivacySettingsManager pSetMan;
+	
+	private static final int PERMISSION_CELL_LOCATION = 0;
+	
+	private static final int PERMISSION_CELL_INFO = 1;
+	
+	private static final int PERMISSION_SIGNAL_STRENGTH = 2;
+	
+	private static final int PERMISSION_CALL_STATE = 3;
+	
+	private static final int PERMISSION_SERVICE_STATE = 4;
+	
+	public PrivacyTelephonyRegistry(Context context) {
+		super(context);
+		pSetMan = new PrivacySettingsManager(context, IPrivacySettingsManager.Stub.asInterface(ServiceManager.getService("privacy")));
+		try{
+			registerPrivacy();
+		} catch(Exception e){
+			Log.e(P_TAG,"failed to register privacy broadcastreceiver");
+		}
+		Log.i(P_TAG,"constructor ready");
+	}
+	
+	/** This broadCastReceiver receives the privacy intent for blocking phonecalls and faking phonestate */
+	private final BroadcastReceiver privacyReceiver = new BroadcastReceiver()
+    {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if(intent.getAction().equals("android.privacy.BLOCKED_PHONE_CALL")){
+            	Bundle data = new Bundle();
+            	data = intent.getExtras();
+            	String packageName = data.getString("packageName");
+            	if(data.containsKey("packageName")){
+            		Log.i(P_TAG, "got blocked phone call INTENT from package: " + data.getString("packageName"));
+            	} else{
+            		Log.i(P_TAG, "got blocked phone call INTENT without package information");
+            	}
+            	if(packageName == null) return;
+            	if(data.containsKey("phoneState")){
+            		int state = data.getInt("phoneState");
+            		switch(state){
+            			case TelephonyManager.CALL_STATE_IDLE:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_IDLE, null, packageName);
+            				return;
+            			case TelephonyManager.CALL_STATE_OFFHOOK:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_OFFHOOK, null, packageName);
+            				return;
+            			case TelephonyManager.CALL_STATE_RINGING:
+            				notifyPrivacyCallState(TelephonyManager.CALL_STATE_RINGING, "12345", packageName);
+            				return;
+            			default:
+            				return;
+            		}
+            	}
+            	Log.i(P_TAG,"we forgot to put phoneState in Intent?");
+            }
+        }
+    };
+    
+    /**
+     * This method allows us to fake a call state if application uses phoneStateListener. It will call the onCallStateChanged method with faked state and number
+     * @param state {@link TelephonyManager} TelephonyManager.CALL_STATE_IDLE <br> TelephonyManager.CALL_STATE_OFFHOOK <br> TelephonyManager.CALL_STATE_RINGING <br>
+     * @param incomingNumber pass null if you don't choose ringing!
+     * @param packageName the affected package to fake callstate!
+     * @author CollegeDev
+     */
+    public void notifyPrivacyCallState(int state, String incomingNumber, String packageName) {
+    	//we do not need to check for permissions
+//        if (!checkNotifyPermission("notifyCallState()")) {
+//            return;
+//        }
+        synchronized (mRecords) {
+            //mCallState = state;
+            //mCallIncomingNumber = incomingNumber;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
+                    try {
+                    	//only notify the affected application
+                    	if(r.pkgForDebug.equals(packageName)){
+                    		r.callback.onCallStateChanged(state, incomingNumber);
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        //broadcastCallStateChanged(state, incomingNumber);
+    }
+    
+    private void registerPrivacy(){
+    	 IntentFilter intentFilter = new IntentFilter("android.privacy.BLOCKED_PHONE_CALL");
+    	 mContext.registerReceiver(privacyReceiver, intentFilter);
+    }
+	
+	public void listen(String pkgForDebug, IPhoneStateListener callback, int events,
+            boolean notifyNow) {
+        // Slog.d(TAG, "listen pkg=" + pkgForDebug + " events=0x" +
+        // Integer.toHexString(events));
+		try{
+			registerPrivacy();
+		} catch(Exception e){
+			Log.e(P_TAG,"failed to register privacy broadcastreceiver");
+		}
+        if (events != 0) {
+            /* Checks permission and throws Security exception */
+            checkListenerPermission(events);
+
+            synchronized (mRecords) {
+                // register
+                Record r = null;
+                find_and_add: {
+                    IBinder b = callback.asBinder();
+                    final int N = mRecords.size();
+                    for (int i = 0; i < N; i++) {
+                        r = mRecords.get(i);
+                        if (b == r.binder) {
+                            break find_and_add;
+                        }
+                    }
+                    r = new Record();
+                    r.binder = b;
+                    r.callback = callback;
+                    r.pkgForDebug = pkgForDebug;
+                    mRecords.add(r);
+                }
+                int send = events & (events ^ r.events);
+                r.events = events;
+                if (notifyNow) {
+                    if ((events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
+//                        try {
+//                        	//not forward now, wait for next
+//                            //r.callback.onServiceStateChanged(new ServiceState(mServiceState));
+//                        } catch (RemoteException ex) {
+//                            remove(r.binder);
+//                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTH) != 0) {
+                        try {
+                            int gsmSignalStrength = mSignalStrength.getGsmSignalStrength();
+                            r.callback.onSignalStrengthChanged((gsmSignalStrength == 99 ? -1
+                                    : gsmSignalStrength));
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR) != 0) {
+                        try {
+                            r.callback.onMessageWaitingIndicatorChanged(mMessageWaiting);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR) != 0) {
+                        try {
+                            r.callback.onCallForwardingIndicatorChanged(mCallForwarding);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
+//                        try {
+//                        	//we do not forward now!
+//                            //r.callback.onCellLocationChanged(new Bundle(mCellLocation));
+//                        } catch (RemoteException ex) {
+//                            remove(r.binder);
+//                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CALL_STATE) != 0) {
+                        try {
+                            r.callback.onCallStateChanged(mCallState, mCallIncomingNumber);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_DATA_CONNECTION_STATE) != 0) {
+                        try {
+                            r.callback.onDataConnectionStateChanged(mDataConnectionState,
+                                mDataConnectionNetworkType);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_DATA_ACTIVITY) != 0) {
+                        try {
+                            r.callback.onDataActivity(mDataActivity);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_SIGNAL_STRENGTHS) != 0) {
+                        try {
+                            r.callback.onSignalStrengthsChanged(mSignalStrength);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_OTASP_CHANGED) != 0) {
+                        try {
+                            r.callback.onOtaspChanged(mOtaspMode);
+                        } catch (RemoteException ex) {
+                            remove(r.binder);
+                        }
+                    }
+                    if ((events & PhoneStateListener.LISTEN_CELL_INFO) != 0) {
+//                        try {
+//                        	//we also do not forward now
+//                            //r.callback.onCellInfoChanged(new CellInfo(mCellInfo));
+//                        } catch (RemoteException ex) {
+//                            remove(r.binder);
+//                        }
+                    }
+                }
+            }
+        } else {
+            remove(callback.asBinder());
+        }
+    }
+	
+	
+	private boolean isPackageAllowed(int PERMISSION, String packageName){
+		PrivacySettings settings = pSetMan.getSettings(packageName, Process.myUid());
+		if(settings == null) return false;
+		switch(PERMISSION){
+			case PERMISSION_CELL_LOCATION:
+				if(((settings.getLocationNetworkSetting() != PrivacySettings.REAL) || (settings.getLocationGpsSetting() != PrivacySettings.REAL)))
+					return false;
+				else 
+					return true;
+			case PERMISSION_CELL_INFO:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_SIGNAL_STRENGTH:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_CALL_STATE:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			case PERMISSION_SERVICE_STATE:
+				if(settings.getLocationNetworkSetting() != PrivacySettings.REAL)
+					return false;
+				else
+					return true;
+			default:
+				return false;
+		}
+	}
+
+	@Override
+	public void notifyServiceState(ServiceState state) {
+        if (!checkNotifyPermission("notifyServiceState()")){
+            return;
+        }
+        synchronized (mRecords) {
+            mServiceState = state;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
+                    try {
+                    	if(!isPackageAllowed(PERMISSION_SERVICE_STATE,r.pkgForDebug)){
+                    		 state.setOperatorName("", "", "");
+                    		 Log.i(P_TAG,"package: " + r.pkgForDebug + " blocked for Cellinfo");
+                    	}
+                    	else
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " allowed for Cellinfo");
+                        r.callback.onServiceStateChanged(new ServiceState(state));
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+        broadcastServiceStateChanged(state);
+    }
+	
+	@Override
+	public void notifyCellInfo(List<CellInfo> cellInfo) {
+        if (!checkNotifyPermission("notifyCellInfo()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCellInfo = cellInfo;
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CELL_INFO) != 0) {
+                    try {
+                    	if(!isPackageAllowed(PERMISSION_CELL_INFO,r.pkgForDebug)){
+                    		//for testings only at first
+                            CellInfoGsm fakeCellInfo = new CellInfoGsm(); 
+                            CellIdentityGsm fakeCellIdentity = new CellIdentityGsm(11,11,549,525);
+                            fakeCellInfo.setCellIdentity(fakeCellIdentity);
+                    		//r.callback.onCellInfoChanged(new CellInfoGsm(CellInfo.TIMESTAMP_TYPE_UNKNOWN,System.currentTimeMillis(),System.currentTimeMillis(),true,new SignalStrength(),new CellIdentityGsm(11,11,549,545,2,"unknown")));
+                    		r.callback.onCellInfoChanged(new ArrayList<CellInfo>(Arrays.asList(fakeCellInfo)));
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " blocked for Cellinfo");
+                    	}
+                    	else{
+                    		r.callback.onCellInfoChanged(cellInfo);
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " allowed for Cellinfo");
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+	
+	@Override
+	public void notifyCellLocation(Bundle cellLocation) {
+        if (!checkNotifyPermission("notifyCellLocation()")) {
+            return;
+        }
+        synchronized (mRecords) {
+            mCellLocation = cellLocation;
+            boolean isCDMA = false;
+            boolean goNormal = false;
+            try{
+            	if(cellLocation.containsKey("lac")){
+            		//it is gsm cell location object, handle it!
+            		isCDMA = false;
+            	}
+            	else{
+            		//it is cdma cell location object, handle it!
+            		isCDMA = true;
+            	}
+            }
+            catch(Exception e){
+            	//nothing here at all
+            	goNormal = true;
+            }
+            for (Record r : mRecords) {
+                if ((r.events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
+                    try {
+                    	if(!isPackageAllowed(PERMISSION_CELL_LOCATION,r.pkgForDebug) && !goNormal){
+                    		Bundle output = new Bundle();
+                    		if(isCDMA){
+                    			CdmaCellLocation tmp = new CdmaCellLocation();
+                    			tmp.fillInNotifierBundle(output);
+                    		}
+                    		else{
+                    			GsmCellLocation tmp = new GsmCellLocation();
+                    			tmp.fillInNotifierBundle(output);
+                    		}
+                    		r.callback.onCellLocationChanged(new Bundle(output));
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " blocked for CellLocation");
+                    	}
+                    	else{
+                    		r.callback.onCellLocationChanged(new Bundle(cellLocation));
+                    		Log.i(P_TAG,"package: " + r.pkgForDebug + " allowed for CellLocation");
+                    	}
+                    } catch (RemoteException ex) {
+                        mRemoveList.add(r.binder);
+                    }
+
+                }
+            }
+            handleRemoveListLocked();
+        }
+    }
+}
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 32031cb..a63cfe3 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -79,6 +79,12 @@ import dalvik.system.Zygote;
 import java.io.File;
 import java.util.Timer;
 import java.util.TimerTask;
+
+// BEGIN privacy-added
+import android.privacy.PrivacySettingsManagerService;
+//import android.privacy.surrogate.PrivacyTelephonyRegistry;
+// END privacy-added
+
 import com.stericsson.hardware.fm.FmReceiverService;
 import com.stericsson.hardware.fm.FmTransmitterService;
 
@@ -243,7 +249,10 @@ class ServerThread extends Thread {
             ServiceManager.addService(Context.DISPLAY_SERVICE, display, true);
 
             Slog.i(TAG, "Telephony Registry");
-            telephonyRegistry = new TelephonyRegistry(context);
+            // BEGIN privacy-modified
+            // telephonyRegistry = new TelephonyRegistry(context);
+            telephonyRegistry = new PrivacyTelephonyRegistry(context);
+            // END privacy-modified
             ServiceManager.addService("telephony.registry", telephonyRegistry);
 
             Slog.i(TAG, "Scheduling Policy");
@@ -301,6 +310,10 @@ class ServerThread extends Thread {
             contentService = ContentService.main(context,
                     factoryTest == SystemServer.FACTORY_TEST_LOW_LEVEL);
 
+            // BEGIN privacy-added
+            addPrivacyService(context);
+            // END privacy-added
+
             Slog.i(TAG, "System Content Providers");
             ActivityManagerService.installSystemProviders();
 
@@ -1123,6 +1136,19 @@ class ServerThread extends Thread {
         //Slog.d(TAG, "Starting service: " + intent);
         context.startServiceAsUser(intent, UserHandle.OWNER);
     }
+
+    // BEGIN privacy-added
+    private void addPrivacyService(Context context) {
+        try {
+            Slog.i(TAG, "Privacy Service");
+            ServiceManager.addService("privacy", new PrivacySettingsManagerService(context));
+        } catch (Throwable e) {
+            Log.e(TAG, "Failure starting Privacy Service", e);
+        }
+    }
+    // END privacy-added
+
+
 }
 
 public class SystemServer {
diff --git a/services/java/com/android/server/TelephonyRegistry.java b/services/java/com/android/server/TelephonyRegistry.java
index 17260d5..2b2177d 100644
--- a/services/java/com/android/server/TelephonyRegistry.java
+++ b/services/java/com/android/server/TelephonyRegistry.java
@@ -63,7 +63,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     private static final boolean DBG = false;
     private static final boolean DBG_LOC = false;
 
-    private static class Record {
+    // BEGIN privacy-modified
+    // private static class Record {
+    public static class Record {
+    // END privacy-modified
         String pkgForDebug;
 
         IBinder binder;
@@ -81,29 +84,32 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private final Context mContext;
+    // BEGIN privacy-modified
+    // these were all private, now protected
+
+    protected final Context mContext;
 
     // access should be inside synchronized (mRecords) for these two fields
-    private final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
-    private final ArrayList<Record> mRecords = new ArrayList<Record>();
+    protected final ArrayList<IBinder> mRemoveList = new ArrayList<IBinder>();
+    protected final ArrayList<Record> mRecords = new ArrayList<Record>();
 
     private final IBatteryStats mBatteryStats;
 
-    private int mCallState = TelephonyManager.CALL_STATE_IDLE;
+    protected int mCallState = TelephonyManager.CALL_STATE_IDLE;
 
-    private String mCallIncomingNumber = "";
+    protected String mCallIncomingNumber = "";
 
-    private ServiceState mServiceState = new ServiceState();
+    protected ServiceState mServiceState = new ServiceState();
 
-    private SignalStrength mSignalStrength = new SignalStrength();
+    protected SignalStrength mSignalStrength = new SignalStrength();
 
-    private boolean mMessageWaiting = false;
+    protected boolean mMessageWaiting = false;
 
-    private boolean mCallForwarding = false;
+    protected boolean mCallForwarding = false;
 
-    private int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
+    protected int mDataActivity = TelephonyManager.DATA_ACTIVITY_NONE;
 
-    private int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
+    protected int mDataConnectionState = TelephonyManager.DATA_UNKNOWN;
 
     private boolean mDataConnectionPossible = false;
 
@@ -117,14 +123,14 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
 
     private LinkCapabilities mDataConnectionLinkCapabilities;
 
-    private Bundle mCellLocation = new Bundle();
+    protected Bundle mCellLocation = new Bundle();
 
-    private int mDataConnectionNetworkType;
+    protected int mDataConnectionNetworkType;
 
-    private int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
-
-    private List<CellInfo> mCellInfo = null;
+    protected int mOtaspMode = ServiceStateTracker.OTASP_UNKNOWN;
 
+    protected List<CellInfo> mCellInfo = null;
+    // END privacy-modified
     static final int PHONE_STATE_PERMISSION_MASK =
                 PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR |
                 PhoneStateListener.LISTEN_CALL_STATE |
@@ -165,7 +171,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     // calls go through a oneway interface and local calls going through a
     // handler before they get to app code.
 
-    TelephonyRegistry(Context context) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    // TelephonyRegistry(Context context) {
+    protected TelephonyRegistry(Context context) {
+    // END privacy-modified
         CellLocation  location = CellLocation.getEmpty();
 
         // Note that location can be null for non-phone builds like
@@ -312,7 +322,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private void remove(IBinder binder) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    // private void remove(IBinder binder) {
+    protected void remove(IBinder binder) {
+    // END privacy-modified
         synchronized (mRecords) {
             final int recordCount = mRecords.size();
             for (int i = 0; i < recordCount; i++) {
@@ -351,9 +365,15 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
         synchronized (mRecords) {
             mServiceState = state;
+            // BEGIN privacy-added
+	        mServiceState.setOperatorName("", "", "");
+	        // END privacy-added
             for (Record r : mRecords) {
                 if ((r.events & PhoneStateListener.LISTEN_SERVICE_STATE) != 0) {
                     try {
+                        // BEGIN privacy-added
+			            state.setOperatorName("", "", "");
+			            // END privacy-added
                         r.callback.onServiceStateChanged(new ServiceState(state));
                     } catch (RemoteException ex) {
                         mRemoveList.add(r.binder);
@@ -639,7 +659,11 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
     // the legacy intent broadcasting
     //
 
-    private void broadcastServiceStateChanged(ServiceState state) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    // private void broadcastServiceStateChanged(ServiceState state) {
+    protected void broadcastServiceStateChanged(ServiceState state) {
+    // END privacy-modified
         long ident = Binder.clearCallingIdentity();
         try {
             mBatteryStats.notePhoneState(state.getState());
@@ -738,7 +762,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
     }
 
-    private boolean checkNotifyPermission(String method) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    protected boolean checkNotifyPermission(String method) {
+    // END privacy-modified
         if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)
                 == PackageManager.PERMISSION_GRANTED) {
             return true;
@@ -749,7 +776,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         return false;
     }
 
-    private void checkListenerPermission(int events) {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    protected void checkListenerPermission(int events) {
+    // END privacy-modified
         if ((events & PhoneStateListener.LISTEN_CELL_LOCATION) != 0) {
             mContext.enforceCallingOrSelfPermission(
                     android.Manifest.permission.ACCESS_COARSE_LOCATION, null);
@@ -768,7 +798,10 @@ class TelephonyRegistry extends ITelephonyRegistry.Stub {
         }
     }
 
-    private void handleRemoveListLocked() {
+    // BEGIN privacy-modified
+    // made protected to allow subclassing
+    protected void handleRemoveListLocked() {
+    // END privacy-modified
         if (mRemoveList.size() > 0) {
             for (IBinder b: mRemoveList) {
                 remove(b);
diff --git a/services/java/com/android/server/am/ActivityRecord.java b/services/java/com/android/server/am/ActivityRecord.java
index aa82be3..d5e0b4b 100644
--- a/services/java/com/android/server/am/ActivityRecord.java
+++ b/services/java/com/android/server/am/ActivityRecord.java
@@ -23,6 +23,7 @@ import com.android.server.am.ActivityStack.ActivityState;
 import android.app.Activity;
 import android.app.ActivityOptions;
 import android.content.ComponentName;
+import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
@@ -42,6 +43,7 @@ import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
 import android.util.TimeUtils;
+import android.view.ContextThemeWrapper;
 import android.view.IApplicationToken;
 import android.view.WindowManager;
 
@@ -127,6 +129,10 @@ final class ActivityRecord {
     int launchCount;        // count of launches since last state
     long lastLaunchTime;    // time of last lauch of this activity
 
+    boolean topIntent;
+    boolean newTask;
+    boolean floatingWindow;
+
     String stringName;      // for caching of toString().
     
     private boolean inHistory;  // are we in the history stack?
@@ -390,6 +396,7 @@ final class ActivityRecord {
                 labelRes = app.labelRes;
             }
             icon = aInfo.getIconResource();
+
             theme = aInfo.getThemeResource();
             realTheme = theme;
             if (realTheme == 0) {
@@ -398,6 +405,51 @@ final class ActivityRecord {
                         ? android.R.style.Theme
                         : android.R.style.Theme_Holo;
             }
+
+            // This is where the package gets its first context from the attribute-cache
+            // In order to hook its attributes we set up our check for floating mutil windows here.
+            topIntent = true;
+
+            floatingWindow = (intent.getFlags() & Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+
+            ActivityRecord baseRecord = stack.mHistory.size() > 0 ? stack.mHistory.get(stack.mHistory.size() -1) : null;
+
+            if (baseRecord != null) {
+
+                final boolean floats = (baseRecord.intent.getFlags() & Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+                final boolean taskAffinity = aInfo.applicationInfo.packageName.equals(baseRecord.packageName);
+                newTask = (intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == Intent.FLAG_ACTIVITY_NEW_TASK;
+
+                // If the current intent is not a new task we will check its top parent.
+                // Perhaps it started out as a multiwindow in which case we pass the flag on
+                if (floats && (!newTask || taskAffinity)) {
+                    intent.addFlags(Intent.FLAG_FLOATING_WINDOW);
+                    // Flag the activity as sub-task
+                    topIntent = false;
+                    floatingWindow = true;
+                }
+            }
+
+            // If this is a multiwindow activity we prevent it from messing up the history stack,
+            // like jumping back home, killing the current activity or polluting recents
+            if (floatingWindow) {
+                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_TASK_ON_HOME);
+                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_SINGLE_TOP);
+                intent.setFlags(intent.getFlags() & ~Intent.FLAG_ACTIVITY_CLEAR_TOP);
+                intent.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NO_USER_ACTION);
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                
+                // If this is the mother-intent we make it volatile
+                if (topIntent) {
+                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
+                }
+
+                // Change theme
+                realTheme = com.android.internal.R.style.Theme_DeviceDefault_FloatingWindow;
+            }
+
             if ((aInfo.flags&ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0) {
                 windowFlags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
             }
@@ -416,9 +468,10 @@ final class ActivityRecord {
             
             packageName = aInfo.applicationInfo.packageName;
             launchMode = aInfo.launchMode;
-            
+
             AttributeCache.Entry ent = AttributeCache.instance().get(packageName,
                     realTheme, com.android.internal.R.styleable.Window, userId);
+
             fullscreen = ent != null && !ent.array.getBoolean(
                     com.android.internal.R.styleable.Window_windowIsFloating, false)
                     && !ent.array.getBoolean(
diff --git a/services/java/com/android/server/am/ActivityStack.java b/services/java/com/android/server/am/ActivityStack.java
index e94f584..cc15fb7 100644
--- a/services/java/com/android/server/am/ActivityStack.java
+++ b/services/java/com/android/server/am/ActivityStack.java
@@ -62,10 +62,12 @@ import android.os.ServiceManager;
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
 import android.view.Display;
+import android.view.WindowManagerPolicy;
 import com.android.internal.app.ActivityTrigger;
 
 import java.io.IOException;
@@ -1566,7 +1568,7 @@ final class ActivityStack {
         
         // We need to start pausing the current activity so the top one
         // can be resumed...
-        if (mResumedActivity != null) {
+        if (mResumedActivity != null && (pauseActiveAppWhenUsingHalo() || !next.floatingWindow)) {
             if (DEBUG_SWITCH) Slog.v(TAG, "Skip resume: need to start pausing");
             // At this point we want to put the upcoming activity's process
             // at the top of the LRU list, since we know we will be needing it
@@ -1645,7 +1647,7 @@ final class ActivityStack {
             if (prev.finishing) {
                 if (DEBUG_TRANSITION) Slog.v(TAG,
                         "Prepare close transition: prev=" + prev);
-                if (mNoAnimActivities.contains(prev)) {
+                if (mNoAnimActivities.contains(prev) || next.floatingWindow) {
                     mService.mWindowManager.prepareAppTransition(
                             AppTransition.TRANSIT_NONE, false);
                 } else {
@@ -1658,7 +1660,7 @@ final class ActivityStack {
             } else {
                 if (DEBUG_TRANSITION) Slog.v(TAG,
                         "Prepare open transition: prev=" + prev);
-                if (mNoAnimActivities.contains(next)) {
+                if (mNoAnimActivities.contains(next) || next.floatingWindow) {
                     noAnim = true;
                     mService.mWindowManager.prepareAppTransition(
                             AppTransition.TRANSIT_NONE, false);
@@ -1790,7 +1792,7 @@ final class ActivityStack {
                 if (!next.hasBeenLaunched) {
                     next.hasBeenLaunched = true;
                 } else {
-                    if (SHOW_APP_STARTING_PREVIEW && mMainStack) {
+                    if (SHOW_APP_STARTING_PREVIEW && mMainStack && !next.floatingWindow) {
                         mService.mWindowManager.setAppStartingWindow(
                                 next.appToken, next.packageName, next.theme,
                                 mService.compatibilityInfoForPackageLocked(
@@ -1824,7 +1826,7 @@ final class ActivityStack {
             if (!next.hasBeenLaunched) {
                 next.hasBeenLaunched = true;
             } else {
-                if (SHOW_APP_STARTING_PREVIEW) {
+                if (SHOW_APP_STARTING_PREVIEW && !next.floatingWindow) {
                     mService.mWindowManager.setAppStartingWindow(
                             next.appToken, next.packageName, next.theme,
                             mService.compatibilityInfoForPackageLocked(
@@ -1951,12 +1953,13 @@ final class ActivityStack {
             }
             if (DEBUG_TRANSITION) Slog.v(TAG,
                     "Prepare open transition: starting " + r);
-            if ((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+
+            if (((r.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) || (r.floatingWindow && !r.topIntent)) {
                 mService.mWindowManager.prepareAppTransition(
                         AppTransition.TRANSIT_NONE, keepCurTransition);
                 mNoAnimActivities.add(r);
             } else {
-                mService.mWindowManager.prepareAppTransition(newTask
+                mService.mWindowManager.prepareAppTransition(newTask && !r.floatingWindow
                         ? AppTransition.TRANSIT_TASK_OPEN
                         : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition);
                 mNoAnimActivities.remove(r);
@@ -1978,7 +1981,7 @@ final class ActivityStack {
                     doShow = topRunningNonDelayedActivityLocked(null) == r;
                 }
             }
-            if (SHOW_APP_STARTING_PREVIEW && doShow) {
+            if (SHOW_APP_STARTING_PREVIEW && doShow && !r.floatingWindow) {
                 // Figure out if we are transitioning from another activity that is
                 // "has the same starting icon" as the next one.  This allows the
                 // window manager to keep the previous window it had previously
@@ -3348,6 +3351,11 @@ final class ActivityStack {
         try {
             synchronized (mService) {
 
+                // we must resolve if the last intent in the stack is floating to give the flag to the previous
+                boolean floating = false;
+                if (intents.length > 0) {
+                    floating = (intents[intents.length - 1].getFlags()&Intent.FLAG_FLOATING_WINDOW) == Intent.FLAG_FLOATING_WINDOW;
+                }
                 for (int i=0; i<intents.length; i++) {
                     Intent intent = intents[i];
                     if (intent == null) {
@@ -3376,6 +3384,10 @@ final class ActivityStack {
                                 "FLAG_CANT_SAVE_STATE not supported here");
                     }
 
+                    if (floating) {
+                        intent.addFlags(Intent.FLAG_FLOATING_WINDOW);
+                    }
+
                     Bundle theseOptions;
                     if (options != null && i == intents.length-1) {
                         theseOptions = options;
@@ -3884,7 +3896,7 @@ final class ActivityStack {
                     || (mHistory.get(index-1)).task != r.task;
             if (DEBUG_TRANSITION) Slog.v(TAG,
                     "Prepare close transition: finishing " + r);
-            mService.mWindowManager.prepareAppTransition(endTask
+            mService.mWindowManager.prepareAppTransition(endTask && !r.floatingWindow
                     ? AppTransition.TRANSIT_TASK_CLOSE
                     : AppTransition.TRANSIT_ACTIVITY_CLOSE, false);
     
@@ -4390,7 +4402,7 @@ final class ActivityStack {
         if (top < 0 || (mHistory.get(top)).task.taskId == task) {
             // nothing to do!
             if (reason != null &&
-                    (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                    ((reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0 || reason.floatingWindow)) {
                 ActivityOptions.abort(options);
             } else {
                 updateTransitLocked(AppTransition.TRANSIT_TASK_TO_FRONT, options);
@@ -4429,7 +4441,7 @@ final class ActivityStack {
         if (DEBUG_TRANSITION) Slog.v(TAG,
                 "Prepare to front transition: task=" + tr);
         if (reason != null &&
-                (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                ((reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0 || reason.floatingWindow)) {
             mService.mWindowManager.prepareAppTransition(
                     AppTransition.TRANSIT_NONE, false);
             ActivityRecord r = topRunningActivityLocked(null);
@@ -4522,7 +4534,7 @@ final class ActivityStack {
         }
 
         if (reason != null &&
-                (reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
+                ((reason.intent.getFlags()&Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0 || reason.floatingWindow)) {
             mService.mWindowManager.prepareAppTransition(
                     AppTransition.TRANSIT_NONE, false);
             ActivityRecord r = topRunningActivityLocked(null);
@@ -4844,7 +4856,13 @@ final class ActivityStack {
 
         return true;
     }
-    
+
+    private boolean pauseActiveAppWhenUsingHalo() {
+        int isLowRAM = (ActivityManager.isLargeRAM()) ? 0 : 1;
+        return Settings.System.getInt(mContext.getContentResolver(),
+                Settings.System.HALO_PAUSE, isLowRAM) == 1;
+    }
+
     public void dismissKeyguardOnNextActivityLocked() {
         mDismissKeyguardOnNextActivity = true;
     }
diff --git a/services/java/com/android/server/am/BroadcastQueue.java b/services/java/com/android/server/am/BroadcastQueue.java
index d9a6c22..75c8035 100644
--- a/services/java/com/android/server/am/BroadcastQueue.java
+++ b/services/java/com/android/server/am/BroadcastQueue.java
@@ -42,6 +42,8 @@ import android.util.EventLog;
 import android.util.Log;
 import android.util.Slog;
 
+import android.privacy.surrogate.PrivacyActivityManagerService;
+
 /**
  * BROADCASTS
  *
@@ -674,6 +676,29 @@ public class BroadcastQueue {
             }
 
             Object nextReceiver = r.receivers.get(recIdx);
+            // BEGIN privacy-added
+            enforcePrivacyPermission(nextReceiver, r);
+            boolean empty = false;
+            if(r != null && r.intent != null && r.intent.getAction() != null && r.intent.getAction().equals("catchBootComplete")){
+               empty = true;
+//             String packageName = null;
+//             try { // try to get intent receiver information
+//                    if (nextReceiver instanceof BroadcastFilter) {
+//                        packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+//                    } else if (nextReceiver instanceof ResolveInfo) {
+//                        packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+//                    }
+//                } catch (Exception e) {
+//                    // if above information is not available, exception will be thrown
+//                    // do nothing, this is not our intent
+//
+//                }
+//             if(packageName != null)
+//                     Log.i("PrivacyBroadcast", "empty=true -> INTENT_BOOT_COMPLETE should be skipped! package: " + packageName);
+//             else
+//                     Log.i("PrivacyBroadcast", "empty=true -> INTENT_BOOT_COMPLETE should be skipped! package: " + "UNKNOWN");
+            }
+            // END privacy-added
             if (nextReceiver instanceof BroadcastFilter) {
                 // Simple case: this is a registered receiver who gets
                 // a direct call.
@@ -682,7 +707,15 @@ public class BroadcastQueue {
                         "Delivering ordered ["
                         + mQueueName + "] to registered "
                         + filter + ": " + r);
-                deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                if(!empty){
+                       deliverToRegisteredReceiverLocked(r, filter, r.ordered);
+                } else{
+                       //Log.i("PrivacyBroadcast","set r.receiver to null");
+                       r.receiver = null;
+                    r.curFilter = null;
+                    //re-initalize
+                    r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+                }
                 if (r.receiver == null || !r.ordered) {
                     // The receiver has already finished, so schedule to
                     // process the next one.
@@ -785,6 +818,12 @@ public class BroadcastQueue {
                 skip = true;
             }
 
+            //PRIVACY BEGIN
+            if(empty){
+               skip = true;
+               r.intent.setAction(Intent.ACTION_BOOT_COMPLETED);
+            }
+            //PRIVACY END
             if (skip) {
                 if (DEBUG_BROADCAST)  Slog.v(TAG,
                         "Skipping delivery of ordered ["
@@ -880,6 +919,33 @@ public class BroadcastQueue {
         }
     }
 
+    // BEGIN privacy-added
+    private void enforcePrivacyPermission(Object nextReceiver, BroadcastRecord r) {
+        if (r != null && r.intent != null && r.intent.getAction() != null) {
+
+            String packageName = null;
+            int uid = -1;
+            try { // try to get intent receiver information
+                if (nextReceiver instanceof BroadcastFilter) {
+                    packageName = ((BroadcastFilter) nextReceiver).receiverList.app.info.packageName;
+                    uid = ((BroadcastFilter) nextReceiver).receiverList.app.info.uid;
+                } else if (nextReceiver instanceof ResolveInfo) {
+                    packageName = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.packageName;
+                    uid = ((ResolveInfo) nextReceiver).activityInfo.applicationInfo.uid;
+                }
+            } catch (Exception e) {
+                // if above information is not available, exception will be thrown
+                // do nothing, this is not our intent
+                return;
+            }
+
+            if (packageName != null && uid != -1) {
+                PrivacyActivityManagerService.enforcePrivacyPermission(packageName, uid, r.intent, null, r.receivers.size());
+            }
+        }
+    }
+    // END privacy-added
+
     final void setBroadcastTimeoutLocked(long timeoutTime) {
         if (! mPendingBroadcastTimeoutMessage) {
             Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
diff --git a/services/java/com/android/server/location/BTGPSService.java b/services/java/com/android/server/location/BTGPSService.java
new file mode 100644
index 0000000..c0ead04
--- /dev/null
+++ b/services/java/com/android/server/location/BTGPSService.java
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2011 Cuong Bui
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.server.location;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.util.UUID;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.bluetooth.BluetoothSocket;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+
+public class BTGPSService {
+    private static final boolean D = true;
+    private static final String TAG = "BTGPSService";
+    private static final UUID BT_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB");
+    private final BluetoothAdapter mAdapter;
+    private final Handler mHandler;
+    private WatchdogThread mWatchdogThread = null;
+    private ConnectThread mConnectThread = null;
+    private ConnectedThread mConnectedThread = null;
+    private final int mMaxNMEABuffer=4096;
+    private final char[] buffer = new char[mMaxNMEABuffer];
+    int bytes;
+    private long refreshRate = 1000;
+    private long lastActivity = 0;
+    // MAX_ACTIVITY_TIMEOUT * refresh time window should have at least one activity.
+    private int MAX_ACTIVITY_TIMEOUT = 5;
+    // Maximum connect retry attempt
+    private int MAX_RECONNECT_RETRIES = 5;
+    // time window for one single connection (ms). socket connect timeout is around 12 sec
+    private int MAX_CONNECT_TIMEOUT = 13000;
+    // last connected device. is used to auto reconnect.
+    private BluetoothDevice lastConnectedDevice=null;
+
+    private int mState = 0;
+    // Constants that indicate the current connection state
+    public static final int STATE_NONE = 0;       // we're doing nothing
+    public static final int STATE_LISTEN = 1;     // now listening for incoming connections
+    public static final int STATE_CONNECTING = 2; // now initiating an outgoing connection
+    public static final int STATE_CONNECTED = 3;  // now connected to a remote device
+
+    public synchronized void setRefreshRate(long r) {
+        refreshRate = r;
+    }
+
+    public synchronized long getRefreshRate() {
+        return refreshRate;
+    }
+
+    public BTGPSService(Handler h) {
+        mAdapter = BluetoothAdapter.getDefaultAdapter();
+        mHandler = h;
+    }
+
+    private void sendMessage(int message, int arg, Object obj) {
+        Message m = Message.obtain(mHandler, message);
+        m.arg1 = arg;
+        m.obj = obj;
+        mHandler.sendMessage(m);
+    }
+
+    private void handleFailedConnection() {
+        if (getServiceState() != STATE_NONE) {
+            if (D) Log.d(TAG, "Connection failed with status != 0. try to reconnect");
+            connect(lastConnectedDevice);
+        } else {
+            if (D) Log.d(TAG, "Connection stopped with status = 0.");
+        }
+    }
+
+    /**
+     * Set the current state of the chat connection
+     * @param state  An integer defining the current connection state
+     */
+    private synchronized void setState(int state) {
+        if (D) Log.d(TAG, "setState() " + mState + " -> " + state);
+        mState = state;
+        if (mState == STATE_NONE) {
+            sendMessage(BTGpsLocationProvider.GPS_STATUS_UPDATE, 0, null);
+        } else if (mState == STATE_CONNECTED) {
+            sendMessage(BTGpsLocationProvider.GPS_STATUS_UPDATE, 1, null);
+        }
+    }
+
+    /**
+     * Return the current connection state. */
+    public synchronized int getServiceState() {
+        return mState;
+    }
+
+    /**
+     * Start the chat service. Specifically start AcceptThread to begin a
+     * session in listening (server) mode. Called by the Activity onResume() */
+    public synchronized void start() {
+
+        if (D) Log.d(TAG, "start");
+        if (!mAdapter.isEnabled()) {
+            setState(STATE_NONE);
+            return;
+        }
+        // Cancel any thread attempting to make a connection
+        if (mConnectThread != null) {
+            mConnectThread.cancel();
+            mConnectThread = null;
+        }
+        // Cancel any thread currently running a connection
+        if (mConnectedThread != null) {
+            mConnectedThread.cancel();
+            mConnectedThread = null;
+        }
+        setState(STATE_LISTEN);
+    }
+
+    /**
+     * Start the ConnectThread to initiate a connection to a remote device.
+     * @param device  The BluetoothDevice to connect
+     */
+    public synchronized boolean connect(BluetoothDevice device) {
+        lastConnectedDevice = device;
+        if (D) Log.d(TAG, "connect to: " + device);
+        // Cancel any thread attempting to make a connection
+        if (mConnectThread != null) {
+            mConnectThread.cancel();
+            mConnectThread = null;
+        }
+        if (mWatchdogThread != null) {
+            mWatchdogThread.cancel();
+            mWatchdogThread = null;
+        }
+        // Cancel any thread currently running a connection
+        if (mConnectedThread != null) {
+            mConnectedThread.cancel();
+            mConnectedThread = null;
+        }
+        // Helper thread that monitors and retries to connect after time out
+        mWatchdogThread = new WatchdogThread(device);
+        mWatchdogThread.start();
+        return true;
+    }
+
+    /**
+     * Start the ConnectedThread to begin managing a Bluetooth connection
+     * @param socket  The BluetoothSocket on which the connection was made
+     * @param device  The BluetoothDevice that has been connected
+     */
+    public synchronized void connected(BluetoothSocket socket) {
+        // reset connect thread
+        if (mConnectThread != null) mConnectThread = null;
+
+        // kill watchdog, since we are connected
+        if (mWatchdogThread != null) {
+            mWatchdogThread.cancel();
+            mWatchdogThread = null;
+        }
+        // Cancel any thread currently running a connection
+        if (mConnectedThread != null) {
+            mConnectedThread.cancel();
+            mConnectedThread = null;
+        }
+
+        // Start the thread to manage the connection and perform transmissions
+        mConnectedThread = new ConnectedThread(socket);
+        mConnectedThread.start();
+        setState(STATE_CONNECTED);
+    }
+
+    /**
+     * Stop all threads
+     */
+    public synchronized void stop() {
+        if (D) Log.d(TAG, "Stopping btsvc, Set state to None");
+        setState(STATE_NONE);
+
+        if (mWatchdogThread != null) {
+            if (D) Log.d(TAG, "Cancelling watchdog thread");
+            mWatchdogThread.cancel();
+            mWatchdogThread = null;
+        }
+
+        if (mConnectThread != null) {
+            if (D) Log.d(TAG, "Cancelling connect thread");
+            mConnectThread.cancel();
+            mConnectThread = null;
+        }
+        if (mConnectedThread != null) {
+            if (D) Log.d(TAG, "Cancelling connected thread");
+            mConnectedThread.cancel();
+            mConnectedThread = null;
+        }
+    }
+
+    /**
+     * Write to the ConnectedThread in an unsynchronized manner
+     * @param out The bytes to write
+     * @see ConnectedThread#write(byte[])
+     */
+    public void write(byte[] out) {
+        // Create temporary object
+        ConnectedThread r;
+        // Synchronize a copy of the ConnectedThread
+        synchronized (this) {
+            if (mState != STATE_CONNECTED) return;
+            r = mConnectedThread;
+        }
+        r.write(out);
+    }
+
+    /**
+     * This thread runs while attempting to make an outgoing connection
+     * with a device. It runs straight through; the connection either
+     * succeeds or fails.
+     */
+    private class ConnectThread extends Thread {
+        private BluetoothSocket mmSocket;
+        private final BluetoothDevice mmDevice;
+        private String mSocketType;
+
+        public ConnectThread(BluetoothDevice device) {
+            mmDevice = device;
+        }
+
+        private void closeSocket() {
+            if (D) Log.d(TAG, getId()+":close socket");
+            if (mmSocket == null) {
+                Log.e(TAG, getId()+":Socket not ready. Aborting Close");
+                return;
+            }
+
+            try {
+                mmSocket.close();
+                mmSocket = null;
+            } catch (IOException e) {
+                Log.e(TAG, getId()+":close() of connect " + mSocketType + " socket failed", e);
+            }
+        }
+
+        public void run() {
+            Log.i(TAG, getId() + ":begin mConnectThread");
+            BluetoothSocket tmp = null;
+            // Always cancel discovery because it will slow down a connection
+
+            try {
+                tmp = mmDevice.createRfcommSocketToServiceRecord(BT_UUID);
+            } catch (IOException e) {
+                Log.e(TAG, "Socket create() failed", e);
+                return;
+            }
+            mmSocket = tmp;
+            // Make a connection to the BluetoothSocket
+            if (mAdapter.isEnabled()) mAdapter.cancelDiscovery();
+            try {
+                // This is a blocking call and will only return on a
+                // successful connection or an exception
+                if (D)  Log.d(TAG, getId() + ":Connecting to socket...");
+                mmSocket.connect();
+                if (D) Log.d(TAG, "connected with remote device: "
+                        + mmDevice.getName() + " at address " + mmDevice.getAddress());
+                connected(mmSocket);
+            } catch (IOException e) {
+                Log.w(TAG, getId() + ":connect failed.", e);
+                return;
+            }
+        }
+
+        public synchronized void cancel() {
+            closeSocket();
+        }
+    }
+
+    /**
+     * This thread runs during a connection with a remote device.
+     * It handles all incoming and outgoing transmissions.
+     */
+    private class ConnectedThread extends Thread {
+        private BluetoothSocket mmSocket;
+        private InputStream mmInStream;
+        private OutputStream mmOutStream;
+        private boolean cancelled = false;
+
+        private void closeSocket() {
+            if (D) Log.d(TAG, getId()+":close socket");
+            if (mmSocket == null) {
+                Log.e(TAG, getId()+":Socket not ready. Aborting Close");
+                return;
+            }
+            try {
+                mmSocket.close();
+                mmSocket = null;
+            } catch (IOException e) {
+                Log.e(TAG, getId()+": close() of connect socket failed", e);
+            }
+        }
+
+        public ConnectedThread(BluetoothSocket socket) {
+            Log.d(TAG, getId() + ":begin ConnectedThread");
+            mmSocket = socket;
+            InputStream tmpIn = null;
+            OutputStream tmpOut = null;
+
+            // Get the BluetoothSocket input and output streams
+            try {
+                tmpIn = socket.getInputStream();
+                tmpOut = socket.getOutputStream();
+            } catch (IOException e) {
+                Log.e(TAG, "temp sockets not created", e);
+            }
+            mmInStream = tmpIn;
+            mmOutStream = tmpOut;
+        }
+
+        public void run() {
+            if (mmSocket == null || mmInStream == null) {
+                Log.e(TAG, "Input stream or socket is null. Aborting thread");
+                return;
+            }
+            if (D) Log.d(TAG, getId() + ":BEGIN mConnectedThread");
+            java.util.Arrays.fill(buffer, (char) ' ');
+            // reset refresh rate to 1000
+            refreshRate = 1000;
+            lastActivity = 0;
+            BufferedReader reader = new BufferedReader(new InputStreamReader(mmInStream));
+            // Keep listening to the InputStream while connected
+            while (true) {
+                try {
+                    if (reader.ready()) {
+                        bytes = reader.read(buffer, 0, mMaxNMEABuffer);
+                        Message msg = mHandler.obtainMessage(
+                                BTGpsLocationProvider.GPS_DATA_AVAILABLE,buffer);
+                        lastActivity = System.currentTimeMillis();
+                        msg.arg1 = bytes;
+                        mHandler.sendMessage(msg);
+                    }
+                    if (lastActivity != 0 && (System.currentTimeMillis() - lastActivity)  >
+                            MAX_ACTIVITY_TIMEOUT*refreshRate) {
+                        Log.w(TAG, getId() + ":BT activity timeout.");
+                        closeSocket();
+                        handleFailedConnection();
+                        return;
+                    }
+                    try {
+                        // get default sleep time
+                        Thread.sleep(getRefreshRate());
+                    } catch (InterruptedException e) {
+                        if (cancelled) {
+                            closeSocket();
+                            return;
+                        }
+                    }
+                } catch (IOException e) {
+                    Log.w(TAG, getId() + ":disconnected.", e);
+                    closeSocket();
+                    handleFailedConnection();
+                    return;
+                }
+            }
+        }
+
+        /**
+         * Write to the connected OutStream.
+         * @param buffer  The bytes to write
+         */
+        public void write(byte[] buffer) {
+            try {
+                mmOutStream.write(buffer);
+                mmOutStream.flush();
+            } catch (IOException e) {
+                Log.e(TAG, "Exception during write", e);
+            }
+        }
+
+        public void cancel() {
+            try {
+                if (mmSocket == null) {
+                    Log.e(TAG, "Input stream null. Aborting Cacnel");
+                    return;
+                }
+                mmSocket.close();
+            } catch (IOException e) {
+                Log.e(TAG, "close() of connect socket failed", e);
+            } finally {
+                cancelled = true;
+                interrupt();
+            }
+        }
+    }
+    /*
+     * Thread that starts the connection thread an monitors it.
+     * Thread will be cancelled if timeot occurs
+     */
+    private class WatchdogThread extends Thread {
+        private final BluetoothDevice btdevice;
+        private int retries = 0;
+        private boolean sleep = false;
+        private boolean cancelled = false;
+
+        public WatchdogThread(BluetoothDevice dev) {
+            btdevice = dev;
+        }
+
+        public void run() {
+            while(retries < MAX_RECONNECT_RETRIES) {
+                if (mConnectThread != null) {
+                    mConnectThread.cancel();
+                    mConnectThread = null;
+                }
+                if (mConnectedThread != null) {
+                    mConnectedThread.cancel();
+                    mConnectedThread = null;
+                }
+
+                mConnectThread = new ConnectThread(btdevice);
+                mConnectThread.start();
+                setState(STATE_CONNECTING);
+                // monitor connection and cancel if timeout
+                if (D) Log.d(TAG, getId() + ":Waiting " + MAX_CONNECT_TIMEOUT
+                        + " (ms) for service to connect...");
+                try {
+                    sleep = true;
+                    Thread.sleep(MAX_CONNECT_TIMEOUT);
+                    sleep = false;
+                    if (D) Log.d(TAG, getId() + ":Connecting timeout.");
+                } catch (InterruptedException e) {
+                    if (D) Log.d(TAG, getId() + ":Watchdog interrupted. probably by cancel.");
+                }
+                if (getServiceState() == STATE_CONNECTED) {
+                    if (D) Log.d(TAG, getId() + ":Connected. aborting watchdog");
+                    return;
+                }
+                if (cancelled) {
+                    if (D) Log.d(TAG, getId() + ":Cancelled. aborting watchdog");
+                    return;
+                }
+                retries++;
+            }
+            // max timeout, so stopping service
+            if (D) Log.d(TAG, getId() + ":Max connection retries exceeded. stopping services.");
+            BTGPSService.this.stop();
+        }
+
+        public void cancel() {
+            cancelled = true;
+            if (sleep) interrupt();
+        }
+    }
+}
\ No newline at end of file
diff --git a/services/java/com/android/server/location/BTGpsLocationProvider.java b/services/java/com/android/server/location/BTGpsLocationProvider.java
new file mode 100644
index 0000000..4a63da3
--- /dev/null
+++ b/services/java/com/android/server/location/BTGpsLocationProvider.java
@@ -0,0 +1,989 @@
+/*
+ * Copyright (C) 2011 Cuong Bui
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.location;
+
+import android.bluetooth.BluetoothAdapter;
+import android.bluetooth.BluetoothDevice;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.location.Criteria;
+import android.location.IGpsStatusListener;
+import android.location.IGpsStatusProvider;
+import android.location.ILocationManager;
+import android.location.INetInitiatedListener;
+import android.location.Location;
+import android.location.LocationManager;
+import android.location.LocationProvider;
+import android.net.NetworkInfo;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.PowerManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemClock;
+import android.os.WorkSource;
+import android.provider.Settings;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseIntArray;
+
+import com.android.internal.app.IBatteryStats;
+import com.android.internal.location.ProviderProperties;
+import com.android.internal.location.ProviderRequest;
+
+import java.io.FileDescriptor;
+import java.io.PrintWriter;
+import java.util.ArrayList;
+import java.util.concurrent.CountDownLatch;
+
+public class BTGpsLocationProvider implements LocationProviderInterface {
+    private static final boolean D = true;
+    private final String PROVIDER = "External Bleutooth Location Provider";
+    private final String TAG = "BTGpsLocationProvider";
+    private final NMEAParser nmeaparser = new NMEAParser(LocationManager.GPS_PROVIDER);
+
+    private final BluetoothAdapter mAdapter = BluetoothAdapter.getDefaultAdapter();
+
+    private static final ProviderProperties PROPERTIES = new ProviderProperties(
+            false, false, false, false, true, true, true,
+            Criteria.POWER_LOW, Criteria.ACCURACY_FINE);
+
+    /** simpler wrapper for ProviderRequest + Worksource */
+    private static class GpsRequest {
+        public ProviderRequest request;
+        public WorkSource source;
+
+        public GpsRequest(ProviderRequest request, WorkSource source) {
+            this.request = request;
+            this.source = source;
+        }
+    }
+
+    // GPS update codes
+    public static final int GPS_DATA_AVAILABLE = 1000;
+    public static final int GPS_STATUS_UPDATE = 1001;
+    public static final int GPS_CUSTOM_COMMAND = 1002;
+
+    // Wakelocks
+    private final static String WAKELOCK_KEY = "GpsLocationProvider";
+    private final PowerManager.WakeLock mWakeLock;
+    // bitfield of pending messages to our Handler
+    // used only for messages that cannot have multiple instances queued
+    private int mPendingMessageBits;
+    // separate counter for ADD_LISTENER and REMOVE_LISTENER messages,
+    // which might have multiple instances queued
+    private int mPendingListenerMessages;
+
+    private final IBatteryStats mBatteryStats;
+    private final SparseIntArray mClientUids = new SparseIntArray();
+
+    // Handler messages
+    private static final int CHECK_LOCATION = 1;
+    private static final int ENABLE = 2;
+    private static final int SET_REQUEST = 3;
+    private static final int UPDATE_NETWORK_STATE = 4;
+    private static final int INJECT_NTP_TIME = 5;
+    private static final int DOWNLOAD_XTRA_DATA = 6;
+    private static final int UPDATE_LOCATION = 7;
+    private static final int ADD_LISTENER = 8;
+    private static final int REMOVE_LISTENER = 9;
+    private static final int INJECT_NTP_TIME_FINISHED = 10;
+    private static final int DOWNLOAD_XTRA_DATA_FINISHED = 11;
+
+    // for calculating time to first fix
+    private long mFixRequestTime = 0;
+    // time to first fix for most recent session
+    private int mTTFF = 0;
+    // time we received our last fix
+    private long mLastFixTime;
+
+    // time for last status update
+    private long mStatusUpdateTime = SystemClock.elapsedRealtime();
+
+    // true if we are enabled
+    private volatile boolean mEnabled;
+
+    // true if GPS is navigating
+    private boolean mNavigating;
+
+    private int mSvCount;
+    // current status
+    private int mStatus = LocationProvider.TEMPORARILY_UNAVAILABLE;
+
+    private Bundle mLocationExtras = new Bundle();
+    private Location mLocation = new Location(LocationManager.GPS_PROVIDER);
+
+    private final Context mContext;
+    private final ILocationManager mLocationManager;
+
+    private final IntentFilter mIntentBTFilter;
+
+    private final Thread mMessageLoopThread = new BTGPSMessageThread();
+    private final CountDownLatch mInitializedLatch = new CountDownLatch(1);
+
+    /**
+     * Listen for BT changes. If BT is turned off, disable GPS services
+     */
+    private final BroadcastReceiver mReceiver;
+
+    /**
+     * Message handler Receives nmea sentences receives connection lost signals
+     * enabling/disabling gps signals adding/removing listeners
+     */
+    private Handler mHandler;
+
+    // BT gps service. This class handles the actual BT connection and data xfer
+    private final BTGPSService btsvc;
+
+    // BT Location provider , uses the same method signature as the org GPS
+    // location provider
+    public BTGpsLocationProvider(Context context, ILocationManager locationManager,
+            Looper looper) {
+
+        mContext = context;
+        mLocationManager = locationManager;
+        // innit message handler
+        mMessageLoopThread.start();
+        // wait for message handler to be ready
+        while (true) {
+            try {
+                mInitializedLatch.await();
+                break;
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        }
+        // instantiate BTGPSService
+        btsvc = new BTGPSService(mHandler);
+
+        // Create a wake lock.
+        PowerManager powerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        mWakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKELOCK_KEY);
+        mWakeLock.setReferenceCounted(false);
+
+        // Battery statistics service to be notified when GPS turns on or off
+        mBatteryStats = IBatteryStats.Stub.asInterface(ServiceManager.getService("batteryinfo"));
+
+        // receive BT state changes
+        mReceiver = new BroadcastReceiver() {
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                String action = intent.getAction();
+                if (BluetoothAdapter.ACTION_STATE_CHANGED.equals(action)) {
+                    int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE,
+                            BluetoothAdapter.ERROR);
+                    switch (state) {
+                        case BluetoothAdapter.STATE_ON:
+                            if (D)
+                                Log.i(TAG, "BT turned on -> notify services?");
+                            break;
+                        case BluetoothAdapter.STATE_TURNING_OFF:
+                            if (btsvc.getServiceState() != BTGPSService.STATE_NONE) {
+                                if (D)
+                                    Log.i(TAG, "BT turned off -> stopping services");
+                                btsvc.stop();
+                            }
+                            break;
+                    }
+                }
+            }
+        };
+        mIntentBTFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
+        mContext.registerReceiver(mReceiver, mIntentBTFilter);
+
+        // TODO: Something with looper?
+    }
+
+    private final class BTGPSMessageThread extends Thread {
+
+        public void run() {
+            try {
+                Looper.prepare();
+            } catch (RuntimeException e) {
+                // ignored: Looper already prepared
+            }
+            mHandler = new Handler() {
+                @Override
+                public void handleMessage(Message msg) {
+                    int message = msg.what;
+                    switch (message) {
+                        case GPS_DATA_AVAILABLE:
+                            char[] writeBuf = (char[]) msg.obj;
+                            int bytes = msg.arg1;
+                            if ((writeBuf != null) && (mEnabled && bytes > 0)) {
+                                String writeMessage = new String(writeBuf, 0, bytes);
+                                handleNMEAMessages(writeMessage);
+                                java.util.Arrays.fill(writeBuf, (char) ' ');
+                            }
+                            break;
+                        case GPS_STATUS_UPDATE:
+                            notifyEnableDisableGPS(msg.arg1 == 1);
+                            break;
+                        case GPS_CUSTOM_COMMAND:
+                            if (mEnabled && btsvc.getServiceState() == BTGPSService.STATE_CONNECTED) {
+                                // sends custom commands
+                                byte[] cmds = (byte[]) msg.obj;
+                                btsvc.write(cmds);
+                            }
+                            break;
+                        case ENABLE:
+                            if (msg.arg1 == 1) {
+                                handleEnable();
+                            } else {
+                                handleDisable();
+                            }
+                            break;
+                        // case REQUEST_SINGLE_SHOT:
+                        // case ENABLE_TRACKING:
+                        case UPDATE_NETWORK_STATE:
+                        case INJECT_NTP_TIME:
+                        case DOWNLOAD_XTRA_DATA:
+                            break;
+                        case UPDATE_LOCATION:
+                            handleUpdateLocation((Location) msg.obj);
+                            break;
+                        case ADD_LISTENER:
+                            handleAddListener(msg.arg1);
+                            break;
+                        case REMOVE_LISTENER:
+                            handleRemoveListener(msg.arg1);
+                            break;
+                    }
+                    // release wake lock if no messages are pending
+                    synchronized (mWakeLock) {
+                        mPendingMessageBits &= ~(1 << message);
+                        if (message == ADD_LISTENER || message == REMOVE_LISTENER) {
+                            mPendingListenerMessages--;
+                        }
+                        if (mPendingMessageBits == 0 && mPendingListenerMessages == 0) {
+                            mWakeLock.release();
+                        }
+                    }
+                }
+            };
+            mInitializedLatch.countDown();
+            Looper.loop();
+        }
+    }
+
+    @Override
+    public void enable() {
+        synchronized (mHandler) {
+            sendMessage(ENABLE, 1, null);
+        }
+    }
+
+    /**
+     * Enables BT GPS provider
+     */
+    private synchronized void handleEnable() {
+        if (D)
+            Log.d(TAG, "handleEnable");
+        if (mEnabled)
+            return;
+        // check if BT is enabled
+        if (!mAdapter.isEnabled()) {
+            int state = mAdapter.getState();
+            if (state == BluetoothAdapter.STATE_OFF) {
+                if (D)
+                    Log.d(TAG, "BT not available. Enable and wait for it...");
+                mAdapter.enable();
+            }
+            // wait for adapter to be ready
+            while (true) {
+                try {
+                    state = mAdapter.getState();
+                    if (state == BluetoothAdapter.STATE_ON) {
+                        break;
+                    } else if (state == BluetoothAdapter.STATE_TURNING_ON) {
+                        if (D)
+                            Log.d(TAG, "BT not available yet. waiting for another 400ms");
+                        Thread.sleep(400);
+                    } else {
+                        if (D)
+                            Log.d(TAG, "BT got disabled or interrupted by other source");
+                        return;
+                    }
+
+                } catch (InterruptedException e) {
+                    Log.w(TAG, e.getMessage());
+                }
+            }
+        }
+        if (D)
+            Log.d(TAG, "mEnabled -> true");
+        mEnabled = true;
+        if (D)
+            Log.d(TAG, "mStatus -> temp unavailable");
+        mStatus = LocationProvider.TEMPORARILY_UNAVAILABLE;
+        if (D)
+            Log.d(TAG, "btservice start");
+        btsvc.start();
+        mFixRequestTime = System.currentTimeMillis();
+        mTTFF = 0;
+        String btDevice = Settings.System.getString(mContext.getContentResolver(),
+                Settings.Secure.EXTERNAL_GPS_BT_DEVICE);
+        if (D)
+            Log.d(TAG, "Connecting to saved pref: " + btDevice);
+        if ((btDevice != null) && !"0".equals(btDevice)) {
+            if ((mAdapter != null) && (mAdapter.isEnabled())) {
+                for (BluetoothDevice d : mAdapter.getBondedDevices()) {
+                    if (btDevice.equals(d.getAddress())) {
+                        if (D)
+                            Log.d(TAG, "Connecting...");
+                        btsvc.connect(d);
+                        return;
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Disables this provider.
+     */
+    @Override
+    public void disable() {
+        synchronized (mHandler) {
+            sendMessage(ENABLE, 0, null);
+        }
+    }
+
+    private synchronized void handleDisable() {
+        if (D)
+            Log.d(TAG, "handleDisable");
+        if (!mEnabled)
+            return;
+        if (D)
+            Log.d(TAG, "mEnabled -> false");
+        mEnabled = false;
+        if (D)
+            Log.d(TAG, "reportstatus notify listeners and system");
+        notifyEnableDisableGPS(false);
+        if (D)
+            Log.d(TAG, "update to out of service");
+        updateStatus(LocationProvider.OUT_OF_SERVICE, mSvCount);
+        if (D)
+            Log.d(TAG, "btservice Stop");
+        btsvc.stop();
+    }
+
+    /*
+     * We do not need to implement scheduled tracking. With internal gps
+     * providers it makes sence to hibernate and resume periodically. With BT
+     * GPS providers it doesn't make sense
+     * @see
+     * com.android.server.location.LocationProviderInterface#enableLocationTracking
+     * (boolean)
+     */
+    // @Override
+    public void enableLocationTracking(boolean enable) {
+    }
+
+    // @Override
+    public int getAccuracy() {
+        return Criteria.ACCURACY_FINE;
+    }
+
+    /*
+     * Debug native state used by normal GPS provider only
+     * @see
+     * com.android.server.location.LocationProviderInterface#getInternalState()
+     */
+    // @Override
+    public String getInternalState() {
+        return null;
+    }
+
+    @Override
+    public String getName() {
+        return LocationManager.GPS_PROVIDER;
+    }
+
+    @Override
+    public ProviderProperties getProperties() {
+        return PROPERTIES;
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
+        /*
+         * StringBuilder s = new StringBuilder();
+         * s.append("  mFixInterval=").append(mFixInterval).append("\n");
+         * s.append("  mEngineCapabilities=0x").append(Integer.toHexString(
+         * mEngineCapabilities)).append(" ("); if
+         * (hasCapability(GPS_CAPABILITY_SCHEDULING)) s.append("SCHED "); if
+         * (hasCapability(GPS_CAPABILITY_MSB)) s.append("MSB "); if
+         * (hasCapability(GPS_CAPABILITY_MSA)) s.append("MSA "); if
+         * (hasCapability(GPS_CAPABILITY_SINGLE_SHOT)) s.append("SINGLE_SHOT ");
+         * if (hasCapability(GPS_CAPABILITY_ON_DEMAND_TIME))
+         * s.append("ON_DEMAND_TIME "); s.append(")\n");
+         * s.append(native_get_internal_state());
+         */
+        pw.append("BTGpsLocationProvider");
+    }
+
+    /**
+     * Returns the power requirement for this provider.
+     * 
+     * @return the power requirement for this provider, as one of the constants
+     *         Criteria.POWER_REQUIREMENT_*.
+     */
+    public int getPowerRequirement() {
+        return Criteria.POWER_MEDIUM;
+    }
+
+    /**
+     * Returns true if this provider meets the given criteria, false otherwise.
+     */
+    public boolean meetsCriteria(Criteria criteria) {
+        return (criteria.getPowerRequirement() != Criteria.POWER_LOW);
+    }
+
+    @Override
+    public int getStatus(Bundle extras) {
+        if (extras != null) {
+            extras.putInt("satellites", mSvCount);
+        }
+        return mStatus;
+    }
+
+    @Override
+    public long getStatusUpdateTime() {
+        return mStatusUpdateTime;
+    }
+
+    @Override
+    public void setRequest(ProviderRequest request, WorkSource source) {
+        sendMessage(SET_REQUEST, 0, new GpsRequest(request, source));
+    }
+
+    // =============================================================
+    // NI Client support
+    // =============================================================
+    private final INetInitiatedListener mNetInitiatedListener = new INetInitiatedListener.Stub() {
+        // Sends a response for an NI reqeust to HAL.
+        @Override
+        public boolean sendNiResponse(int notificationId, int userResponse)
+        {
+            // TODO Add Permission check
+
+            if (D)
+                Log.d(TAG, "sendNiResponse, notifId: " + notificationId +
+                        ", response: " + userResponse);
+            native_send_ni_response(notificationId, userResponse);
+            return true;
+        }
+    };
+
+    public INetInitiatedListener getNetInitiatedListener() {
+        return mNetInitiatedListener;
+    }
+
+    // @Override
+    public boolean hasMonetaryCost() {
+        return false;
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return mEnabled;
+    }
+
+    // @Override
+    public boolean requestSingleShotFix() {
+        return false;
+    }
+
+    // @Override
+    public boolean requiresCell() {
+        return false;
+    }
+
+    // @Override
+    public boolean requiresNetwork() {
+        return false;
+    }
+
+    // @Override
+    public boolean requiresSatellite() {
+        return true;
+    }
+
+    @Override
+    public boolean sendExtraCommand(String command, Bundle extras) {
+        if (TextUtils.isEmpty(command))
+            return false;
+        synchronized (mHandler) {
+            String customCommand = command + "\r\n";
+            sendMessage(GPS_CUSTOM_COMMAND, customCommand.length(), customCommand.getBytes());
+        }
+        return true;
+    }
+
+    /*
+     * GPS scheduling stuff, not needed
+     * @see
+     * com.android.server.location.LocationProviderInterface#setMinTime(long,
+     * android.os.WorkSource)
+     */
+    // @Override
+    public void setMinTime(long minTime, WorkSource ws) {
+
+    }
+
+    // @Override
+    public boolean supportsAltitude() {
+        return mLocation.hasAltitude();
+    }
+
+    // @Override
+    public boolean supportsBearing() {
+        return mLocation.hasBearing();
+    }
+
+    // @Override
+    public boolean supportsSpeed() {
+        return mLocation.hasSpeed();
+    }
+
+    // @Override
+    /**
+     * This is called to inform us when another location provider returns a
+     * location. Someday we might use this for network location injection to aid
+     * the GPS
+     */
+    public void updateLocation(Location location) {
+        sendMessage(UPDATE_LOCATION, 0, location);
+    }
+
+    private void handleUpdateLocation(Location location) {
+        if (location.hasAccuracy()) {
+            // Allow other provider GPS data ? discard for now
+        }
+    }
+
+    /*
+     * unneeded by BT GPS provider
+     * @see
+     * com.android.server.location.LocationProviderInterface#updateNetworkState
+     * (int, android.net.NetworkInfo)
+     */
+    // @Override
+    public void updateNetworkState(int state, NetworkInfo info) {
+        // TODO Auto-generated method stub
+
+    }
+
+    /**
+     * @param loc Location object representing the fix
+     * @param isValid true if fix was valid
+     */
+    private void reportLocation(Location loc, boolean isValid) {
+        if (D)
+            Log.d(TAG,
+                    "Reporting Location (" + loc.isComplete() + "): Lng: " + loc.getLatitude() +
+                            "Lng: " + loc.getLongitude());
+
+        if (!isValid) {
+            if (mStatus == LocationProvider.AVAILABLE && mTTFF > 0) {
+                if (D)
+                    Log.d(TAG, "Invalid sat fix -> sending notification to system");
+                // send an intent to notify that the GPS is no longer receiving
+                // fixes.
+                Intent intent = new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
+                intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, false);
+                mContext.sendBroadcast(intent);
+                updateStatus(LocationProvider.TEMPORARILY_UNAVAILABLE, mSvCount);
+            }
+            return;
+        }
+
+        synchronized (mLocation) {
+            if (D && !loc.isComplete()) {
+                Log.d(TAG, "Location: hasProvider? '" + loc.getProvider() + "'" +
+                        ", hasAccuracy? '" + loc.hasAccuracy() + "'" +
+                        ", hasTime? '" + loc.getTime() + "'" +
+                        ", mElapsedRealtimeNanos? '" + loc.getElapsedRealtimeNanos() + "'");
+
+            }
+
+            mLocation.set(loc);
+            mLocation.setProvider(this.getName());
+            if (D) {
+                Log.d(TAG,
+                        "reportLocation lat: " + mLocation.getLatitude() +
+                                " long: " + mLocation.getLongitude() + " alt: "
+                                + mLocation.getAltitude() +
+                                " accuracy: " + mLocation.getAccuracy() + " timestamp: "
+                                + mLocation.getTime());
+            }
+            try {
+                mLocationManager.reportLocation(mLocation, false);
+            } catch (RemoteException e) {
+                Log.e(TAG, "RemoteException calling reportLocation");
+            }
+        }
+
+        mLastFixTime = System.currentTimeMillis();
+        // report time to first fix
+        if ((mTTFF == 0) && (isValid)) {
+            mTTFF = (int) (mLastFixTime - mFixRequestTime);
+            if (D)
+                Log.d(TAG, "TTFF: " + mTTFF);
+
+            // notify status listeners
+            synchronized (mListeners) {
+                int size = mListeners.size();
+                for (int i = 0; i < size; i++) {
+                    Listener listener = mListeners.get(i);
+                    try {
+                        listener.mListener.onFirstFix(mTTFF);
+                    } catch (RemoteException e) {
+                        Log.w(TAG, "RemoteException in first fix notification");
+                        mListeners.remove(listener);
+                        // adjust for size of list changing
+                        size--;
+                    }
+                }
+            }
+        }
+
+        if (mStatus != LocationProvider.AVAILABLE) {
+            if (D)
+                Log.d(TAG, "Notify that we're receiving fixes");
+            // send an intent to notify that the GPS is receiving fixes.
+            Intent intent = new Intent(LocationManager.GPS_FIX_CHANGE_ACTION);
+            intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, true);
+            mContext.sendBroadcast(intent);
+            updateStatus(LocationProvider.AVAILABLE, mSvCount);
+        }
+
+    }
+
+    /*
+     * report sats status
+     */
+    private void reportSvStatus(int svCount, int mSvs[], float mSnrs[],
+            float mSvElevations[], float mSvAzimuths[], int mSvMasks[]) {
+
+        if (D)
+            Log.d(TAG, "About to report sat status svcount: " + svCount);
+        synchronized (mListeners) {
+            int size = mListeners.size();
+            for (int i = 0; i < size; i++) {
+                Listener listener = mListeners.get(i);
+                try {
+                    listener.mListener.onSvStatusChanged(svCount, mSvs, mSnrs, mSvElevations,
+                            mSvAzimuths, mSvMasks[NMEAParser.EPHEMERIS_MASK],
+                            mSvMasks[NMEAParser.ALMANAC_MASK],
+                            mSvMasks[NMEAParser.USED_FOR_FIX_MASK]);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "RemoteException in reportSvInfo");
+                    mListeners.remove(listener);
+                    // adjust for size of list changing
+                    size--;
+                }
+            }
+        }
+
+        // return number of sets used in fix instead of total
+        updateStatus(mStatus, Integer.bitCount(mSvMasks[NMEAParser.USED_FOR_FIX_MASK]));
+    }
+
+    /**
+     * Handles GPS status. will also inform listeners when GPS started/stopped
+     * 
+     * @param status new GPS status
+     */
+    private void notifyEnableDisableGPS(boolean status) {
+        if (D)
+            Log.v(TAG, "notifyEnableDisableGPS status: " + status);
+
+        synchronized (mListeners) {
+            mNavigating = status;
+            int size = mListeners.size();
+            for (int i = 0; i < size; i++) {
+                Listener listener = mListeners.get(i);
+                try {
+                    if (status) {
+                        listener.mListener.onGpsStarted();
+                    } else {
+                        listener.mListener.onGpsStopped();
+                    }
+                } catch (RemoteException e) {
+                    Log.w(TAG, "RemoteException in reportStatus");
+                    mListeners.remove(listener);
+                    // adjust for size of list changing
+                    size--;
+                }
+            }
+            try {
+                // update battery stats
+                for (int i = mClientUids.size() - 1; i >= 0; i--) {
+                    int uid = mClientUids.keyAt(i);
+                    if (mNavigating) {
+                        mBatteryStats.noteStartGps(uid);
+                    } else {
+                        mBatteryStats.noteStopGps(uid);
+                    }
+                }
+            } catch (RemoteException e) {
+                Log.w(TAG, "RemoteException in reportStatus");
+            }
+            // send an intent to notify that the GPS has been enabled or
+            // disabled.
+            Intent intent = new Intent(LocationManager.GPS_ENABLED_CHANGE_ACTION);
+            intent.putExtra(LocationManager.EXTRA_GPS_ENABLED, status);
+            mContext.sendBroadcast(intent);
+        }
+        try {
+            if (D)
+                Log.d(TAG, "Setting System GPS status to " + status);
+            Settings.Secure.setLocationProviderEnabled(mContext.getContentResolver(),
+                    LocationManager.GPS_PROVIDER, status);
+        } catch (Exception e) {
+            Log.e(TAG, e.getMessage());
+        }
+    }
+
+    /**
+     * sends nmea sentences to NMEA parsers. Some apps use raw nmea data
+     * 
+     * @param nmeaString nmea string
+     * @param timestamp time stamp
+     */
+    private void reportNmea(String nmeaString, long timestamp) {
+        synchronized (mListeners) {
+            int size = mListeners.size();
+            for (int i = 0; i < size; i++) {
+                Listener listener = mListeners.get(i);
+                try {
+                    listener.mListener.onNmeaReceived(timestamp, nmeaString);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "RemoteException in reportNmea");
+                    mListeners.remove(listener);
+                    // adjust for size of list changing
+                    size--;
+                }
+            }
+        }
+    }
+
+    /**
+     * This methods parses the nmea sentences and sends the location updates and
+     * sats updates to listeners.
+     * 
+     * @param sentences raw nmea sentences received by BT GPS Mouse
+     */
+    private void handleNMEAMessages(String sentences) {
+        Log.d(TAG, "handleNMEAMessages");
+        String sentenceArray[] = sentences.split("\r\n");
+        nmeaparser.reset();
+        for (int i = 0; i < sentenceArray.length; i++) {
+            if (D)
+                Log.d(TAG, "About to parse: " + sentenceArray[i]);
+            if ((sentenceArray[i] != null) && ("".equals(sentenceArray[i])))
+                continue;
+            boolean parsed = nmeaparser.parseNMEALine(sentenceArray[i]);
+            // handle nmea message. Also report messages that we could not parse
+            // as these
+            // might be propriatery messages that other listeners could support.
+            reportNmea(sentenceArray[i], System.currentTimeMillis());
+        }
+        Location loc = nmeaparser.getLocation();
+        // handle location update if valid
+        reportLocation(loc, nmeaparser.isValid());
+        if (nmeaparser.isSatdataReady()) {
+            reportSvStatus(nmeaparser.getmSvCount(), nmeaparser.getmSvs(), nmeaparser.getmSnrs(),
+                    nmeaparser.getmSvElevations(), nmeaparser.getmSvAzimuths(),
+                    nmeaparser.getmSvMasks());
+        }
+
+        // adjust refresh rate based on received timestamp of mouse
+        // min 1hz and max 10 hz
+        long newRate = nmeaparser.getApproximatedRefreshRate();
+        if (btsvc.getRefreshRate() != newRate) {
+            if (D)
+                Log.d(TAG, "Setting refresh rate to: " + newRate
+                        + " was: " + btsvc.getRefreshRate());
+            btsvc.setRefreshRate(newRate);
+        }
+    }
+
+    /*
+     * Stuff below is taken from the android GPS location provider. Does
+     * handling of messages/listeners and so on.
+     */
+
+    private void sendMessage(int message, int arg, Object obj) {
+        // hold a wake lock while messages are pending
+        synchronized (mWakeLock) {
+            mPendingMessageBits |= (1 << message);
+            mWakeLock.acquire();
+            mHandler.removeMessages(message);
+            Message m = Message.obtain(mHandler, message);
+            m.arg1 = arg;
+            m.obj = obj;
+            mHandler.sendMessage(m);
+        }
+    }
+
+    private void updateStatus(int status, int svCount) {
+        if (status != mStatus || svCount != mSvCount) {
+            mStatus = status;
+            mSvCount = svCount;
+            mLocationExtras.putInt("satellites", svCount);
+            mStatusUpdateTime = SystemClock.elapsedRealtime();
+        }
+    }
+
+    private ArrayList<Listener> mListeners = new ArrayList<Listener>();
+
+    private final class Listener implements IBinder.DeathRecipient {
+        final IGpsStatusListener mListener;
+
+        Listener(IGpsStatusListener listener) {
+            mListener = listener;
+        }
+
+        public void binderDied() {
+            if (D)
+                Log.d(TAG, "GPS status listener died");
+
+            synchronized (mListeners) {
+                mListeners.remove(this);
+            }
+            if (mListener != null) {
+                mListener.asBinder().unlinkToDeath(this, 0);
+            }
+        }
+    }
+
+    private final IGpsStatusProvider mGpsStatusProvider = new IGpsStatusProvider.Stub() {
+        public void addGpsStatusListener(IGpsStatusListener listener) throws RemoteException {
+            if (listener == null) {
+                throw new NullPointerException("listener is null in addGpsStatusListener");
+            }
+            synchronized (mListeners) {
+                IBinder binder = listener.asBinder();
+                int size = mListeners.size();
+                for (int i = 0; i < size; i++) {
+                    Listener test = mListeners.get(i);
+                    if (binder.equals(test.mListener.asBinder())) {
+                        // listener already added
+                        return;
+                    }
+                }
+                Listener l = new Listener(listener);
+                binder.linkToDeath(l, 0);
+                mListeners.add(l);
+            }
+        }
+
+        public void removeGpsStatusListener(IGpsStatusListener listener) {
+            if (listener == null) {
+                throw new NullPointerException("listener is null in addGpsStatusListener");
+            }
+
+            synchronized (mListeners) {
+                IBinder binder = listener.asBinder();
+                Listener l = null;
+                int size = mListeners.size();
+                for (int i = 0; i < size && l == null; i++) {
+                    Listener test = mListeners.get(i);
+                    if (binder.equals(test.mListener.asBinder())) {
+                        l = test;
+                    }
+                }
+
+                if (l != null) {
+                    mListeners.remove(l);
+                    binder.unlinkToDeath(l, 0);
+                }
+            }
+        }
+    };
+
+    public IGpsStatusProvider getGpsStatusProvider() {
+        return mGpsStatusProvider;
+    }
+
+    public void addListener(int uid) {
+        synchronized (mWakeLock) {
+            mPendingListenerMessages++;
+            mWakeLock.acquire();
+            Message m = Message.obtain(mHandler, ADD_LISTENER);
+            m.arg1 = uid;
+            mHandler.sendMessage(m);
+        }
+    }
+
+    private void handleAddListener(int uid) {
+        synchronized (mListeners) {
+            if (mClientUids.indexOfKey(uid) >= 0) {
+                // Shouldn't be here -- already have this uid.
+                Log.w(TAG, "Duplicate add listener for uid " + uid);
+                return;
+            }
+            mClientUids.put(uid, 0);
+            if (mNavigating) {
+                try {
+                    mBatteryStats.noteStartGps(uid);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "RemoteException in addListener");
+                }
+            }
+        }
+    }
+
+    public void removeListener(int uid) {
+        synchronized (mWakeLock) {
+            mPendingListenerMessages++;
+            mWakeLock.acquire();
+            Message m = Message.obtain(mHandler, REMOVE_LISTENER);
+            m.arg1 = uid;
+            mHandler.sendMessage(m);
+        }
+    }
+
+    private void handleRemoveListener(int uid) {
+        synchronized (mListeners) {
+            if (mClientUids.indexOfKey(uid) < 0) {
+                // Shouldn't be here -- don't have this uid.
+                Log.w(TAG, "Unneeded remove listener for uid " + uid);
+                return;
+            }
+            mClientUids.delete(uid);
+            if (mNavigating) {
+                try {
+                    mBatteryStats.noteStopGps(uid);
+                } catch (RemoteException e) {
+                    Log.w(TAG, "RemoteException in removeListener");
+                }
+            }
+        }
+    }
+
+    // Network-initiated (NI) Support
+    private native void native_send_ni_response(int notificationId, int userResponse);
+}
diff --git a/services/java/com/android/server/location/GpsLocationProvider.java b/services/java/com/android/server/location/GpsLocationProvider.java
index ee01c7d..661f9e1 100644
--- a/services/java/com/android/server/location/GpsLocationProvider.java
+++ b/services/java/com/android/server/location/GpsLocationProvider.java
@@ -921,6 +921,11 @@ public class GpsLocationProvider implements LocationProviderInterface {
 
     @Override
     public boolean sendExtraCommand(String command, Bundle extras) {
+        // arararagi
+        Log.i(TAG, "sendExtraCommand: " + command);
+        for (String k : extras.keySet()) {
+            Log.i(TAG, "extras: " + k + "=" + extras.get(k));
+        }
 
         long identity = Binder.clearCallingIdentity();
         boolean result = false;
diff --git a/services/java/com/android/server/location/NMEAParser.java b/services/java/com/android/server/location/NMEAParser.java
new file mode 100644
index 0000000..ec50704
--- /dev/null
+++ b/services/java/com/android/server/location/NMEAParser.java
@@ -0,0 +1,607 @@
+/*
+ * Copyright (C) 2011 Cuong Bui
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.server.location;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.TimeZone;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import android.location.Location;
+import android.location.LocationManager;
+import android.os.Bundle;
+import android.os.SystemClock;
+import android.text.TextUtils;
+import android.util.Log;
+
+public class NMEAParser {
+    private static final String TAG = "NMEAParser";
+    private static final String DELIM = ",";
+
+    // NMEA sentence pattern
+    private final Pattern sentencePattern = Pattern.compile("\\$([^*$]{5,})(\\*\\w{2})?");
+    private final SimpleDateFormat timeFormatter = new SimpleDateFormat("HHmmss.S");
+    private final TimeZone GPSTimezone = TimeZone.getTimeZone("UTC");
+    private GregorianCalendar GPSCalendar = new GregorianCalendar(GPSTimezone);
+
+    private HashMap<String, ParseInterface> parseMap = new HashMap<String, ParseInterface>();
+    private String provider;
+
+    private static final String BUNDLE_SATS = "satellites";
+    private static final String BUNDLE_ISVALID = "isValid";
+
+    // for GPS SV statistics
+    private static final int MAX_SVS = 32;
+    public static final int EPHEMERIS_MASK = 0;
+    public static final int ALMANAC_MASK = 1;
+    public static final int USED_FOR_FIX_MASK = 2;
+
+    // preallocated arrays, to avoid memory allocation in reportStatus()
+    private int mSvs[] = new int[MAX_SVS];
+    private float mSnrs[] = new float[MAX_SVS];
+    private float mSvElevations[] = new float[MAX_SVS];
+    private float mSvAzimuths[] = new float[MAX_SVS];
+    private int mSvMasks[] = new int[3];
+    private int mSvCount;
+
+    private float PDOP = 0f;
+    private float HDOP = 0f;
+    private float VDOP = 0f;
+
+    private boolean isValid = false;
+    private long mFixDateTimeStamp = 0;
+    private double mFixLongitude = 0.0;
+    private double mFixLatitude = 0.0;
+    private float mFixAltitude = 0f;
+    private float mFixSpeed = 0f;
+    private float mFixBearing = 0f;
+    private float mFixAccuracy = 0f;
+    private int mFixSatsTracked = 0;
+    private int mFixQuality = 0;
+
+    // horizontal estimated position error
+    private float HEPE_FACTOR = 4f;
+
+    // last fix timestamp. Is used to approximate and adjust gps mouse refresh
+    // rate.
+    private long mFixTimestampDelta = 500;
+
+    private boolean mSatsReady = true;
+    private Location loc = new Location(LocationManager.GPS_PROVIDER);
+
+    /**
+     * @param prov Location provider name
+     */
+    public NMEAParser(String prov) {
+        // init parser map with all known parsers
+        parseMap.put("GPRMC", new GPRMCParser());
+        parseMap.put("GPGGA", new GPGGAParser());
+        parseMap.put("GPGSA", new GPGSAParser());
+        parseMap.put("GPGSV", new GPGSVParser());
+        parseMap.put("GPZDA", new GPZDAParser());
+        parseMap.put("GPGLL", new GPGLLParser());
+
+        provider = prov;
+        timeFormatter.setTimeZone(TimeZone.getTimeZone("UTC"));
+
+    }
+
+    private void updateTimeStamp(long in) {
+        if (mFixDateTimeStamp != 0 && in != mFixDateTimeStamp) {
+            mFixTimestampDelta = in - mFixDateTimeStamp;
+            if (mFixTimestampDelta < 100)
+                mFixTimestampDelta = 100;
+            if (mFixTimestampDelta > 1000)
+                mFixTimestampDelta = 1000;
+        }
+        mFixDateTimeStamp = in;
+    }
+
+    public long getApproximatedRefreshRate() {
+        return mFixTimestampDelta;
+    }
+
+    /**
+     * @return if nmea sentence are valid then true
+     */
+    public boolean isValid() {
+        return isValid;
+    }
+
+    /**
+     * resets fix variables
+     */
+    public void reset() {
+        mFixLongitude = 0.0;
+        mFixLatitude = 0.0;
+        mFixAltitude = 0f;
+        mFixSpeed = 0f;
+        mFixAccuracy = 0f;
+        mFixQuality = 0;
+        mFixSatsTracked = 0;
+        isValid = false;
+    }
+
+    private void resetSats() {
+        mSvCount = 0;
+        java.util.Arrays.fill(mSvs, 0);
+        java.util.Arrays.fill(mSnrs, 0f);
+        java.util.Arrays.fill(mSvElevations, 0f);
+        java.util.Arrays.fill(mSvAzimuths, 0f);
+    }
+
+    /**
+     * @return a Location object if valid null otherwise
+     */
+    public Location getLocation() {
+        loc.reset();
+        if (mFixDateTimeStamp != 0)
+            loc.setTime(mFixDateTimeStamp);
+        loc.setProvider(provider);
+        loc.setLatitude(mFixLatitude);
+        loc.setLongitude(mFixLongitude);
+        Bundle extras = new Bundle();
+        extras.putInt(BUNDLE_SATS, mFixSatsTracked);
+        extras.putBoolean(BUNDLE_ISVALID, isValid);
+        loc.setExtras(extras);
+        loc.setAccuracy(mFixAccuracy);
+        loc.setTime(System.currentTimeMillis());
+        loc.setAltitude(mFixAltitude);
+        loc.setSpeed(mFixSpeed);
+        loc.setBearing(mFixBearing);
+
+        // It would be nice to push the elapsed real-time timestamp
+        // further down the stack, but this is still useful
+        loc.setElapsedRealtimeNanos(SystemClock.elapsedRealtimeNanos());
+
+        Log.d(TAG, "getLocation returning loc: " + loc);
+
+        return loc;
+    }
+
+    /**
+     * @param time UTC time
+     * @return nr seconds since 1970
+     */
+    private long parseTimeToDate(String time) {
+        try {
+            // parse time , We only get timestamp from sentences
+            // use UTC calendar to set the date.
+            Date btTime = timeFormatter.parse(time);
+            Calendar localCalendar = Calendar.getInstance(GPSTimezone);
+            GPSCalendar.setTimeInMillis(btTime.getTime());
+            GPSCalendar.set(localCalendar.get(Calendar.YEAR), localCalendar.get(Calendar.MONTH),
+                    localCalendar.get(Calendar.DAY_OF_MONTH));
+            return GPSCalendar.getTimeInMillis();
+        } catch (ParseException e) {
+            Log.e(TAG, "Could not parse: " + time);
+            return 0;
+        }
+    }
+
+    private int parseStringToInt(String str) {
+        if (TextUtils.isEmpty(str))
+            return 0;
+        int res = 0;
+        try {
+            res = Integer.parseInt(str);
+        } catch (Exception e) {
+            Log.e(TAG, e.getMessage());
+        }
+        return res;
+    }
+
+    private float parseStringToFloat(String str) {
+        if (TextUtils.isEmpty(str))
+            return 0.0f;
+
+        float res = 0.0f;
+        try {
+            res = Float.parseFloat(str);
+        } catch (Exception e) {
+            Log.e(TAG, e.getMessage());
+        }
+        return res;
+    }
+
+    /**
+     * @param in Longitude/Latitude
+     * @param orientation N,W,S,E
+     * @return The double representation of a Longitude/Latitude
+     */
+    private double parseCoordinate(String in, String orientation) {
+        // dec = deg + mins.sec/60
+        double c = Double.parseDouble(in);
+        int deg = (int) (c / 100);
+        double res = deg + (c - deg * 100.0) * 0.016666666666667;
+        if ("S".equalsIgnoreCase(orientation) || "W".equalsIgnoreCase(orientation))
+            return -res;
+        return res;
+    }
+
+    private float parseSpeedInKnots(String str) {
+        float res = 0.0f;
+        res = Float.parseFloat(str) * 0.514444444f;
+        return res;
+    }
+
+    private float parseSpeedInKMH(String str) {
+        float res = 0.0f;
+        res = Float.parseFloat(str) * 0.277777778f;
+        return res;
+    }
+
+    /**
+     * Interface that all sentence parsers have to implement. Every sentence is
+     * implemented as a seperate class. The Nmea parser will select the correct
+     * parser based on the sentence identifier. It will get or instantiate a
+     * parser to do the job.
+     */
+    private interface ParseInterface {
+        public void parse(String sentence);
+    }
+
+    public class GPRMCParser implements ParseInterface {
+        /*
+         * $GPRMC,123519,A,4807.038,N,01131.000,E,022.4,084.4,230394,003.1,W*6A
+         * Where: RMC Recommended Minimum sentence C 123519 Fix taken at
+         * 12:35:19 UTC A Status A=active or V=Void. 4807.038,N Latitude 48 deg
+         * 07.038' N 01131.000,E Longitude 11 deg 31.000' E 022.4 Speed over the
+         * ground in knots 084.4 Track angle in degrees True 230394 Date - 23rd
+         * of March 1994 003.1,W Magnetic Variation6A The checksum data, always
+         * begins with *
+         */
+        @Override
+        public void parse(String sentence) {
+            String[] tmp = sentence.split(DELIM);
+            if (tmp.length > 3) {
+                updateTimeStamp(parseTimeToDate(tmp[1]));
+                if (!"A".equals(tmp[2])) {
+                    return;
+                }
+                mFixLatitude = parseCoordinate(tmp[3], tmp[4]);
+                mFixLongitude = parseCoordinate(tmp[5], tmp[6]);
+                mFixSpeed = parseSpeedInKnots(tmp[7]);
+                mFixBearing = parseStringToFloat(tmp[8]);
+            }
+        }
+    }
+
+    public class GPGLLParser implements ParseInterface {
+        /*
+         * $GPGLL,4916.45,N,12311.12,W,225444,A 1 2 3 4 5 6 Where GLL Geographic
+         * Position, Latitude / Longitude and time 1 4916.45 Current latitude 2
+         * N North/South 3 12311.12 Current longitude 4 W East/West 5 225444 Fix
+         * taken at 22:54:44 UTC 6 A Status $GPGLL,5133.81,N,00042.25,W*75 1 2 3
+         * 4 5 Where 1 5133.81 Current latitude 2 N North/South 3 00042.25
+         * Current longitude 4 W East/West 5 *75 checksum
+         */
+        @Override
+        public void parse(String sentence) {
+            String[] tmp = sentence.split(DELIM);
+            if (tmp.length > 4) {
+                // fits example 1
+                updateTimeStamp(parseTimeToDate(tmp[5]));
+                if (!"A".equals(tmp[6])) {
+                    return;
+                }
+                mFixLatitude = parseCoordinate(tmp[1], tmp[2]);
+                mFixLongitude = parseCoordinate(tmp[3], tmp[4]);
+            } else if (tmp.length > 3) {
+                // fits example 2
+                mFixLatitude = parseCoordinate(tmp[1], tmp[2]);
+                mFixLongitude = parseCoordinate(tmp[3], tmp[4]);
+            }
+        }
+    }
+
+    public class GPZDAParser implements ParseInterface {
+        /*
+         * $GPZDA,hhmmss.ss,xx,xx,xxxx,xx,xx 1 2 3 4 5 6 Where ZDA Date & Time 1
+         * hhmmss.ss = UTC 2 xx = Day, 01 to 31 3 xx = Month, 01 to 12 4 xxxx =
+         * Year 5 xx = Local zone description, 00 to +/- 13 hours 6 xx = Local
+         * zone minutes description (same sign as hours)
+         */
+        @Override
+        public void parse(String sentence) {
+            String[] tmp = sentence.split(DELIM);
+            if (tmp.length > 5) {
+                try {
+
+                    Date btTime = timeFormatter.parse(tmp[1]);
+
+                    // Timezone code
+                    /*
+                     * int timeZone = parseStringToInt(tmp[5]); int
+                     * offSetMinutes; if (timeZone < 0) { offSetMinutes =
+                     * timeZone*60 - parseStringToInt(tmp[6]); } else {
+                     * offSetMinutes = timeZone*60 + parseStringToInt(tmp[6]); }
+                     * TimeZone myGPSTimezone = TimeZone.getTimeZone("UTC");
+                     * myGPSTimezone.setRawOffset(offSetMinutes*60*1000);
+                     */
+                    GPSCalendar.setTimeInMillis(btTime.getTime());
+                    GPSCalendar.set(parseStringToInt(tmp[4]), parseStringToInt(tmp[3]),
+                            parseStringToInt(tmp[2]));
+
+                    updateTimeStamp(GPSCalendar.getTimeInMillis());
+                    if (!"A".equals(tmp[6])) {
+                        return;
+                    }
+                } catch (ParseException e) {
+                    Log.e(TAG, "Could not parse: " + tmp[1]);
+                    return;
+                }
+            }
+        }
+    }
+
+    public class GPGGAParser implements ParseInterface {
+        /*
+         * $GPGGA,123519,4807.038,N,01131.000,E,1,08,0.9,545.4,M,46.9,M,,*47
+         * Where: GGA Global Positioning System Fix Data 123519 Fix taken at
+         * 12:35:19 UTC 4807.038,N Latitude 48 deg 07.038' N 01131.000,E
+         * Longitude 11 deg 31.000' E 1 Fix quality: 0 = invalid 1 = GPS fix
+         * (SPS) 2 = DGPS fix 3 = PPS fix 4 = Real Time Kinematic 5 = Float RTK
+         * 6 = estimated (dead reckoning) (2.3 feature) 7 = Manual input mode 8
+         * = Simulation mode 08 Number of satellites being tracked 0.9
+         * Horizontal dilution of position 545.4,M Altitude, Meters, above mean
+         * sea level 46.9,M Height of geoid (mean sea level) above WGS84
+         * ellipsoid (empty field) time in seconds since last DGPS update (empty
+         * field) DGPS station ID number47 the checksum data, always begins with
+         * *
+         */
+        @Override
+        public void parse(String sentence) {
+            String[] tmp = sentence.split(DELIM);
+            if (tmp.length > 7) {
+                // always parse timestamp
+                updateTimeStamp(parseTimeToDate(tmp[1]));
+                mFixQuality = Integer.parseInt(tmp[6]);
+                if (mFixQuality == 0) {
+                    // return invalid location
+                    isValid = false;
+                    return;
+                }
+                mFixLatitude = parseCoordinate(tmp[2], tmp[3]);
+                mFixLongitude = parseCoordinate(tmp[4], tmp[5]);
+                mFixSatsTracked = parseStringToInt(tmp[7]);
+                mFixAccuracy = parseStringToFloat(tmp[8]) * HEPE_FACTOR;
+                mFixAltitude = parseStringToFloat(tmp[9]);
+                isValid = true;
+            }
+        }
+    }
+
+    public class GPGSAParser implements ParseInterface {
+        /*
+         * $GPGSA,A,3,04,05,,09,12,,,24,,,,,2.5,1.3,2.1*39 Where: GSA Satellite
+         * status A Auto selection of 2D or 3D fix (M = manual) 3 3D fix -
+         * values include: 1 = no fix 2 = 2D fix 3 = 3D fix 04,05... PRNs of
+         * satellites used for fix (space for 12) 2.5 PDOP (dilution of
+         * precision) 1.3 Horizontal dilution of precision (HDOP) 2.1 Vertical
+         * dilution of precision (VDOP)39 the checksum data, always begins with
+         * *
+         */
+        @Override
+        public void parse(String sentence) {
+            String[] tmp = sentence.split(DELIM);
+            if (tmp.length >= 16) {
+                if ("1".equals(tmp[2])) {
+                    // return invalid location or invalid sentence
+                    return;
+                }
+                for (int i = 3; i < 15; i++) {
+                    // tag sats used for fix
+                    int sat = parseStringToInt(tmp[i]);
+                    if (sat > 0)
+                        mSvMasks[USED_FOR_FIX_MASK] |= (1 << (sat - 1));
+                }
+                if (tmp.length > 15)
+                    PDOP = parseStringToFloat(tmp[15]);
+                if (tmp.length > 16)
+                    HDOP = parseStringToFloat(tmp[16]);
+                if (tmp.length > 17)
+                    VDOP = parseStringToFloat(tmp[17]);
+            }
+        }
+    }
+
+    /**
+     * Parse sats information. Use same structure as internal GPS provider
+     */
+    public class GPGSVParser implements ParseInterface {
+        /*
+         * $GPGSV,2,1,08,01,40,083,46,02,17,308,41,12,07,344,39,14,22,228,45*75
+         * Where: GSV Satellites in view 2 Number of sentences for full data 1
+         * sentence 1 of 2 08 Number of satellites in view 01 Satellite PRN
+         * number 40 Elevation, degrees 083 Azimuth, degrees 46 SNR - higher is
+         * better for up to 4 satellites per sentence75 the checksum data,
+         * always begins with *
+         */
+        @Override
+        public void parse(String sentence) {
+            String[] tmp = sentence.split(DELIM);
+            if (tmp.length > 4) {
+                mSvCount = parseStringToInt(tmp[3]);
+                if (mSvCount == 0) {
+                    return;
+                }
+                int totalSentences = parseStringToInt(tmp[1]);
+                int currSentence = parseStringToInt(tmp[2]);
+
+                if (mSatsReady) {
+                    resetSats();
+                    mSatsReady = false;
+                } else if ((currSentence == totalSentences) && !mSatsReady) {
+                    // tag data as dirty when we have parsed the last part
+                    mSatsReady = true;
+                }
+                int idx = 0;
+                while ((currSentence <= totalSentences) && (idx < 4)) {
+                    int offset = idx << 2;
+                    int base_offset = (currSentence - 1) << 2;
+                    if (offset + 4 < tmp.length)
+                        mSvs[base_offset + idx] = parseStringToInt(tmp[4 + offset]);
+                    if (offset + 5 < tmp.length)
+                        mSvElevations[base_offset + idx] = parseStringToInt(tmp[5 + offset]);
+                    if (offset + 6 < tmp.length)
+                        mSvAzimuths[base_offset + idx] = parseStringToInt(tmp[6 + offset]);
+                    if (offset + 7 < tmp.length)
+                        mSnrs[base_offset + idx] = parseStringToInt(tmp[7 + offset]);
+                    idx++;
+                }
+            }
+        }
+    }
+
+    /**
+     * Using non static dynamic innerclass instantiation.
+     * 
+     * @param sid sentence identifier
+     * @return parser associated with the sid
+     */
+    private ParseInterface getParser(String sid) {
+        if (parseMap.containsKey(sid)) {
+            return parseMap.get(sid);
+        } else {
+            Log.d(TAG, "Could not instantiate " + sid + "parser");
+        }
+        return null;
+    }
+
+    /**
+     * @param in nmea sentence
+     * @return String representing checksum of the input
+     */
+    private String computeChecksum(String in) {
+        byte result = 0;
+        char[] chars = in.toCharArray();
+        for (int i = 0; i < chars.length; i++)
+            result ^= (byte) chars[i];
+        return String.format("%02X", result);
+    }
+
+    public boolean parseNMEALine(String sentence) {
+        Matcher m = sentencePattern.matcher(sentence);
+        if (m.matches()) {
+            String nmeaSentence = m.group(1);
+            String command = nmeaSentence.substring(0, 5);
+            String checksum = m.group(2);
+            if (checksum != null) {
+                // checksums are optional
+                // strip off *, checksum always have length 3 here. else the
+                // regex will not match
+                checksum = checksum.substring(1, 3).toUpperCase();
+                if (!computeChecksum(nmeaSentence).equals(checksum)) {
+                    Log.w(TAG, "skipping sentence: " + sentence + " due to checksum error "
+                            + checksum + " - " + computeChecksum(nmeaSentence));
+                    return false;
+                }
+            }
+            Log.d(TAG, "Parsing nmeaSentence: " + nmeaSentence);
+            ParseInterface parser = getParser(command);
+            if (parser != null) {
+                try {
+                    parser.parse(nmeaSentence);
+                } catch (Exception e) {
+                    // catch exception thrown by parsers
+                    // mostly bad input causing out of bounds
+                    Log.e(TAG, nmeaSentence, e);
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    public int getmSvCount() {
+        return mSvCount;
+    }
+
+    public float getPDOP() {
+        return PDOP;
+    }
+
+    public float getHDOP() {
+        return HDOP;
+    }
+
+    public float getVDOP() {
+        return VDOP;
+    }
+
+    public long getmFixDate() {
+        return mFixDateTimeStamp;
+    }
+
+    public double getmFixLongitude() {
+        return mFixLongitude;
+    }
+
+    public double getmFixLatitude() {
+        return mFixLatitude;
+    }
+
+    public float getmFixAltitude() {
+        return mFixAltitude;
+    }
+
+    public float getmFixSpeed() {
+        return mFixSpeed;
+    }
+
+    public float getmFixAccuracy() {
+        return mFixAccuracy;
+    }
+
+    public int getmFixQuality() {
+        return mFixQuality;
+    }
+
+    public int[] getmSvs() {
+        return mSvs;
+    }
+
+    public float[] getmSnrs() {
+        return mSnrs;
+    }
+
+    public float[] getmSvElevations() {
+        return mSvElevations;
+    }
+
+    public float[] getmSvAzimuths() {
+        return mSvAzimuths;
+    }
+
+    public int[] getmSvMasks() {
+        return mSvMasks;
+    }
+
+    public int getmFixSatsTracked() {
+        return mFixSatsTracked;
+    }
+
+    public boolean isSatdataReady() {
+        return mSatsReady;
+    }
+}
diff --git a/services/java/com/android/server/power/PowerManagerService.java b/services/java/com/android/server/power/PowerManagerService.java
index 779722d..f40a776 100644
--- a/services/java/com/android/server/power/PowerManagerService.java
+++ b/services/java/com/android/server/power/PowerManagerService.java
@@ -364,6 +364,14 @@ public final class PowerManagerService extends IPowerManager.Stub
     // Use -1 to disable.
     private int mButtonBrightnessOverrideFromWindowManager = -1;
 
+    // The button backlight preference from settings
+    // 0 = turn on when screen touched
+    // 1 = off
+    // 2 = on
+    // 3 = force off
+    // 4 = force on
+    private int mButtonModeSetting = 0;
+
     // The user activity timeout override from the window manager
     // to allow the current foreground activity to override the user activity timeout.
     // Use -1 to disable.
@@ -532,6 +540,9 @@ public final class PowerManagerService extends IPowerManager.Stub
             resolver.registerContentObserver(Settings.System.getUriFor(
                     Settings.System.AUTO_BRIGHTNESS_RESPONSIVENESS),
                     false, mSettingsObserver, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(
+                    Settings.System.BUTTON_BACKLIGHT_MODE),
+                    false, mSettingsObserver, UserHandle.USER_ALL);
 
             // Go.
             readConfigurationLocked();
@@ -612,6 +623,10 @@ public final class PowerManagerService extends IPowerManager.Stub
         mAutoBrightnessResponsitivityFactor =
                 Math.min(Math.max(newAutoBrightnessResponsitivityFactor, 0.2f), 3.0f);
 
+        mButtonModeSetting = Settings.System.getIntForUser(resolver,
+                Settings.System.BUTTON_BACKLIGHT_MODE,
+                0, UserHandle.USER_CURRENT);
+
         mDirty |= DIRTY_SETTINGS;
     }
 
@@ -1411,14 +1426,27 @@ public final class PowerManagerService extends IPowerManager.Stub
                     nextTimeout = mLastUserActivityTime
                             + screenOffTimeout - screenDimDuration;
                     if (now < nextTimeout) {
-                        int brightness = mButtonBrightnessOverrideFromWindowManager >= 0
-                                ? mButtonBrightnessOverrideFromWindowManager
-                                : mDisplayPowerRequest.screenBrightness;
-                        mKeyboardLight.setBrightness(mKeyboardVisible ? brightness : 0);
                         if (now > mLastUserActivityTime + BUTTON_ON_DURATION) {
-                            mButtonsLight.setBrightness(0);
+                            // Default or force on
+                            int brightness = mButtonModeSetting == 2
+                                    || mButtonModeSetting == 4
+                                    ? mDisplayPowerRequest.screenBrightness : 0;
+                            mButtonsLight.setBrightness(brightness);
+                            mKeyboardLight.setBrightness(brightness);
                         } else {
+                            int brightness = mDisplayPowerRequest.screenBrightness;
+                            if (mButtonModeSetting == 1
+                                    || mButtonModeSetting == 3) {
+                                // Default or force off
+                                brightness = 0;
+                            }
+                            if (mButtonModeSetting < 3) { // Not forcing
+                                brightness = mButtonBrightnessOverrideFromWindowManager >= 0
+                                        ? mButtonBrightnessOverrideFromWindowManager
+                                        : brightness;
+                            }
                             mButtonsLight.setBrightness(brightness);
+                            mKeyboardLight.setBrightness(brightness);
                             if (brightness != 0) {
                                 nextTimeout = now + BUTTON_ON_DURATION;
                             }
diff --git a/telephony/java/android/telephony/CellInfoGsm.java b/telephony/java/android/telephony/CellInfoGsm.java
index 1bedddb..0a91fda 100644
--- a/telephony/java/android/telephony/CellInfoGsm.java
+++ b/telephony/java/android/telephony/CellInfoGsm.java
@@ -48,7 +48,7 @@ public final class CellInfoGsm extends CellInfo implements Parcelable {
     public CellIdentityGsm getCellIdentity() {
         return mCellIdentityGsm;
     }
-    /** @hide */
+
     public void setCellIdentity(CellIdentityGsm cid) {
         mCellIdentityGsm = cid;
     }
diff --git a/telephony/java/android/telephony/PhoneStateListener.java b/telephony/java/android/telephony/PhoneStateListener.java
index ff77fc0..f31f990 100644
--- a/telephony/java/android/telephony/PhoneStateListener.java
+++ b/telephony/java/android/telephony/PhoneStateListener.java
@@ -16,16 +16,23 @@
 
 package android.telephony;
 
+// BEGIN privacy-added
+import com.android.internal.telephony.IPhoneStateListener;
+import android.privacy.PrivacySettings;
+import android.privacy.PrivacySettingsManager;
+import android.content.Context;
+// END privacy-added
+
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
-import android.telephony.ServiceState;
-import android.telephony.SignalStrength;
-import android.telephony.CellLocation;
+//import android.telephony.ServiceState;
+//import android.telephony.SignalStrength;
+//import android.telephony.CellLocation;
 import android.telephony.CellInfo;
 import android.telephony.Rlog;
 
-import com.android.internal.telephony.IPhoneStateListener;
+//import com.android.internal.telephony.IPhoneStateListener;
 
 import java.util.List;
 
@@ -158,6 +165,29 @@ public class PhoneStateListener {
      */
     public static final int LISTEN_OTASP_CHANGED                            = 0x00000200;
 
+    // BEGIN privacy-added
+    private Context context;
+    private String packageName;
+    private int uid;
+    private final static String TAG = "PhoneStateListener"; 
+    
+    /** {@hide} */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+    
+    /** {@hide} */
+    public void setPackageName(String packageName) {
+        this.packageName = packageName;
+    }
+    
+    /** {@hide} */
+    public void setUid(int uid) {
+        this.uid = uid;
+    }    
+    // END privacy-added
+ 
+
     /**
      * Listen for changes to observed cell info.
      *
@@ -317,11 +347,51 @@ public class PhoneStateListener {
 
         public void onCellLocationChanged(Bundle bundle) {
             CellLocation location = CellLocation.newFromBundle(bundle);
-            Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            //Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+            // BEGIN privacy-modified
+            if (context != null) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+//                String output;
+                if (pSet != null && pSet.getLocationNetworkSetting() != PrivacySettings.REAL) {
+                    // simply block the method call, since simulating cell location is not feasible
+//                    output = "[no output]";
+                    pSetMan.notification(packageName, uid, pSet.getLocationNetworkSetting(), PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                } else {
+//                    output = location.toString();
+                    Message.obtain(mHandler, LISTEN_CELL_LOCATION, 0, 0, location).sendToTarget();
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_LOCATION_NETWORK, null, pSet);            
+                }
+//                Log.d(TAG, "onCellLocationChanged - " + context.getPackageName() + " (" + 
+//                        Binder.getCallingUid() + ") output: " + output);
+            }
+            // END privacy-modified
         }
 
         public void onCallStateChanged(int state, String incomingNumber) {
-            Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            //Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            // BEGIN privacy-modified
+//            Log.d(TAG, "onCallStateChanged - state:" + state + " incoming number:" + incomingNumber);
+            // only take action if an incoming phone number is actually transmitted
+            if (context != null && incomingNumber != null && !incomingNumber.isEmpty()) {
+                PrivacySettingsManager pSetMan = (PrivacySettingsManager) context.getSystemService("privacy");
+                PrivacySettings pSet = pSetMan.getSettings(packageName, uid);
+                String output;
+                if (pSet != null && pSet.getIncomingCallsSetting() != PrivacySettings.REAL) {
+                    output = "";
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, output).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged BLOCK - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + output);
+                    pSetMan.notification(packageName, uid, PrivacySettings.EMPTY, PrivacySettings.DATA_INCOMING_CALL, output, pSet);
+                } else {
+                    Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+//                    Log.d(TAG, "onCallStateChanged REAL 1 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                    pSetMan.notification(packageName, uid, PrivacySettings.REAL, PrivacySettings.DATA_INCOMING_CALL, incomingNumber, pSet);
+                }
+            } else {
+//                Log.d(TAG, "onCallStateChanged REAL 2 - package:" + packageName + " uid:" + uid + " state:" + state + " output: " + incomingNumber);
+                Message.obtain(mHandler, LISTEN_CALL_STATE, state, 0, incomingNumber).sendToTarget();
+            }
+            // END privacy-modified
         }
 
         public void onDataConnectionStateChanged(int state, int networkType) {
diff --git a/telephony/java/android/telephony/ServiceState.java b/telephony/java/android/telephony/ServiceState.java
index bcb3b02..b34f741 100644
--- a/telephony/java/android/telephony/ServiceState.java
+++ b/telephony/java/android/telephony/ServiceState.java
@@ -566,7 +566,10 @@ public class ServiceState implements Parcelable {
                 + " EmergOnly=" + mIsEmergencyOnly);
     }
 
-    private void setNullState(int state) {
+   // BEGIN privacy-modified
+   // Was originally private
+   void setNullState(int state) {
+   // END privacy-modified
         if (DBG) Rlog.d(LOG_TAG, "[ServiceState] setNullState=" + state);
         mVoiceRegState = state;
         mDataRegState = state;
diff --git a/wifi/java/android/net/wifi/WifiInfo.java b/wifi/java/android/net/wifi/WifiInfo.java
index 502d1ab..6d7b5f8 100644
--- a/wifi/java/android/net/wifi/WifiInfo.java
+++ b/wifi/java/android/net/wifi/WifiInfo.java
@@ -78,6 +78,24 @@ public class WifiInfo implements Parcelable {
      */
     private boolean mMeteredHint;
 
+
+    // BEGIN privacy-added
+    /**
+     * Constructor for faking WifiInfo
+     * @hide
+     */
+    public WifiInfo(boolean fake){
+    	mWifiSsid = WifiSsid.createFromAsciiEncoded("");
+        mBSSID = "";
+        mNetworkId = -1;
+        mSupplicantState = SupplicantState.UNINITIALIZED;
+        mRssi = -9999;
+        mLinkSpeed = -1;
+        mHiddenSSID = false;
+    }
+    // END privacy-added
+
+
     WifiInfo() {
         mWifiSsid = null;
         mBSSID = null;
